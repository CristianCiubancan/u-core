# .\cli\CLI.ts

/**
 * Command-line interface
 */
import { Command } from '../core/types.js';
import { BuildCommand } from './commands/BuildCommand.js';
import { DevCommand } from './commands/DevCommand.js';
import { HelpCommand } from './commands/HelpCommand.js';
import { ConsoleLogger, LogLevel } from '../utils/logger/ConsoleLogger.js';

/**
 * Command-line interface
 */
export class CLI {
  private commands: Map<string, Command>;
  private logger: ConsoleLogger;

  /**
   * Create a new CLI
   */
  constructor() {
    this.logger = new ConsoleLogger({ minLevel: LogLevel.Info });
    this.commands = new Map();

    // Register commands
    this.registerCommand(new BuildCommand());
    this.registerCommand(new DevCommand());
    this.registerCommand(new HelpCommand(this.getCommands()));
  }

  /**
   * Register a command
   * @param command Command to register
   */
  private registerCommand(command: Command): void {
    this.commands.set(command.name, command);
  }

  /**
   * Get all registered commands
   * @returns Map of commands
   */
  private getCommands(): Map<string, Command> {
    return this.commands;
  }

  /**
   * Parse command-line arguments
   * @param args Command-line arguments
   * @returns Command and arguments
   */
  private parseArgs(args: string[]): {
    commandName: string;
    commandArgs: string[];
  } {
    // Default command is 'build'
    let commandName = 'build';
    let commandArgs = args;

    // If first argument doesn't start with '-', it's the command name
    if (args.length > 0 && !args[0].startsWith('-')) {
      commandName = args[0];
      commandArgs = args.slice(1);
    }

    return { commandName, commandArgs };
  }

  /**
   * Run the CLI
   * @param args Command-line arguments
   */
  async run(args: string[]): Promise<void> {
    try {
      const { commandName, commandArgs } = this.parseArgs(args);
      const command = this.commands.get(commandName);

      if (!command) {
        this.logger.error(`Unknown command: ${commandName}`);
        this.commands.get('help')?.execute([]);
        return;
      }

      await command.execute(commandArgs);
    } catch (error) {
      this.logger.error('Error running command:', error);
      throw error;
    }
  }
}


================================================================================

# .\cli\commands\BuildCommand.ts

/**
 * Build command
 */
import 'dotenv/config'; // Load environment variables from .env file
import { Command } from '../../core/types.js';
import { ConsoleLogger } from '../../utils/logger/ConsoleLogger.js';
import { ConfigLoader } from '../../config/ConfigLoader.js';
import { BuildPipelineImpl } from '../../core/build/BuildPipelineImpl.js';
import { BuildContextImpl } from '../../core/build/BuildContextImpl.js';
import { cleanStage } from '../../core/build/stages/CleanStage.js';
import { buildCorePluginsStage } from '../../core/build/stages/BuildCorePluginsStage.js';
import { buildPluginsStage } from '../../core/build/stages/BuildPluginsStage.js';
import { buildWebviewStage } from '../../core/build/stages/BuildWebviewStage.js';
import { fixNestedPluginsStage } from '../../core/build/stages/FixNestedPluginsStage.js';
import { deployResourcesStage } from '../../core/build/stages/DeployResourcesStage.js';
import { setupWatchersStage } from '../../core/build/stages/SetupWatchersStage.js';

/**
 * Build command
 */
export class BuildCommand implements Command {
  name = 'build';
  description = 'Build the project';
  private logger: ConsoleLogger;

  /**
   * Create a new build command
   */
  constructor() {
    this.logger = new ConsoleLogger();
  }

  /**
   * Parse command arguments
   * @param args Command arguments
   * @returns Parsed options
   */
  private parseArgs(args: string[]): { watch: boolean; reload: boolean } {
    const options = {
      watch: false,
      reload: false,
    };

    // Parse arguments
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];

      if (arg === '--watch' || arg === '-w') {
        options.watch = true;
      } else if (arg === '--reload' || arg === '-r') {
        options.reload = true;
      }
    }

    return options;
  }

  /**
   * Execute the command
   * @param args Command arguments
   */
  async execute(args: string[]): Promise<void> {
    try {
      // Parse arguments
      const { watch, reload } = this.parseArgs(args);

      // Load configuration
      const config = ConfigLoader.load({
        reloader: {
          enabled: reload,
          host: 'localhost',
          port: 30120,
          apiKey: '',
        },
      });

      // Create build context
      const context = new BuildContextImpl({
        rootDir: config.paths.rootDir,
        pluginsDir: config.paths.pluginsDir,
        coreDir: config.paths.coreDir,
        distDir: config.paths.distDir,
        watch,
        reload,
        logger: this.logger,
        config,
      });

      // Create build pipeline
      const pipeline = new BuildPipelineImpl();

      // Add build stages
      pipeline
        .addStage('clean', cleanStage)
        .addStage('buildCorePlugins', buildCorePluginsStage)
        .addStage('buildPlugins', buildPluginsStage)
        .addStage('buildWebview', buildWebviewStage)
        .addStage('fixNestedPlugins', fixNestedPluginsStage)
        .addStage('deployResources', deployResourcesStage);

      // Add watcher stage if in watch mode
      if (watch) {
        pipeline.addStage('setupWatchers', setupWatchersStage);
      }

      // Run the pipeline
      await pipeline.run(context);

      this.logger.info('Build completed successfully!');
    } catch (error) {
      this.logger.error('Build failed:', error);
      throw error;
    }
  }
}


================================================================================

# .\cli\commands\DevCommand.ts

/**
 * Dev command
 */
import { Command } from '../../core/types.js';
import { ConsoleLogger } from '../../utils/logger/ConsoleLogger.js';

/**
 * Dev command
 */
export class DevCommand implements Command {
  name = 'dev';
  description = 'Start development mode with watch and reload';
  private logger: ConsoleLogger;

  /**
   * Create a new dev command
   */
  constructor() {
    this.logger = new ConsoleLogger();
  }

  /**
   * Execute the command
   * @param args Command arguments
   */
  async execute(args: string[]): Promise<void> {
    // The dev command is just a shortcut for build --watch --reload
    const buildCommand = new (await import('./BuildCommand.js')).BuildCommand();
    await buildCommand.execute(['--watch', '--reload', ...args]);
  }
}


================================================================================

# .\cli\commands\HelpCommand.ts

/**
 * Help command
 */
import { Command } from '../../core/types.js';
import { ConsoleLogger } from '../../utils/logger/ConsoleLogger.js';

/**
 * Help command
 */
export class HelpCommand implements Command {
  name = 'help';
  description = 'Show help information';
  private commands: Map<string, Command>;
  private logger: ConsoleLogger;

  /**
   * Create a new help command
   * @param commands Map of available commands
   */
  constructor(commands: Map<string, Command>) {
    this.commands = commands;
    this.logger = new ConsoleLogger();
  }

  /**
   * Execute the command
   * @param args Command arguments
   */
  async execute(args: string[]): Promise<void> {
    this.logger.info('Available commands:');
    
    // Sort commands by name
    const sortedCommands = Array.from(this.commands.values())
      .sort((a, b) => a.name.localeCompare(b.name));
    
    // Display each command
    for (const command of sortedCommands) {
      this.logger.info(`  ${command.name.padEnd(15)} ${command.description}`);
    }
    
    this.logger.info('\nUsage: pnpm tsx src/scripts/index.ts [command] [options]');
    this.logger.info('For more information about a command, run: pnpm tsx src/scripts/index.ts help [command]');
  }
}


================================================================================

# .\config\ConfigLoader.ts

/**
 * Configuration loader
 */
import * as path from 'path';
import * as fs from 'fs';
import { BuildConfig } from '../core/types.js';
import { fileURLToPath } from 'url';
import 'dotenv/config'; // Load environment variables from .env file

/**
 * Default configuration
 */
const defaultConfig: BuildConfig = {
  env: {},
  options: {
    minify: false,
    sourceMaps: true,
    clean: true,
  },
  paths: {
    rootDir: process.cwd(),
    pluginsDir: path.join(process.cwd(), 'src', 'plugins'),
    coreDir: path.join(process.cwd(), 'src', 'core'),
    distDir: path.join(process.cwd(), 'dist'),
    webviewDir: path.join(process.cwd(), 'src', 'webview'),
  },
  reloader: {
    enabled: false,
    host: 'localhost',
    port: 3414,
    apiKey: 'your-secure-api-key',
  },
};

/**
 * Configuration loader
 */
export class ConfigLoader {
  /**
   * Load configuration
   * @param options Options to override default configuration
   * @returns Build configuration
   */
  static load(options: Partial<BuildConfig> = {}): BuildConfig {
    // Start with default configuration
    const config = { ...defaultConfig };

    // Load environment variables
    this.loadEnvVars(config);

    // Override with provided options
    this.mergeConfigs(config, options);

    return config;
  }

  /**
   * Load environment variables
   * @param config Configuration to update
   */
  private static loadEnvVars(config: BuildConfig): void {
    // Load environment variables
    config.env = { ...process.env } as Record<string, string>;

    // Update reloader configuration from environment variables
    if (process.env.RELOADER_ENABLED) {
      config.reloader.enabled = process.env.RELOADER_ENABLED === 'true';
    }
    if (process.env.RELOADER_HOST) {
      config.reloader.host = process.env.RELOADER_HOST;
    }
    if (process.env.RELOADER_PORT) {
      config.reloader.port = parseInt(process.env.RELOADER_PORT, 10);
    }
    if (process.env.RELOADER_API_KEY) {
      config.reloader.apiKey = process.env.RELOADER_API_KEY;
    }

    // Update paths from environment variables
    if (process.env.PLUGINS_DIR) {
      config.paths.pluginsDir = process.env.PLUGINS_DIR;
    }
    if (process.env.CORE_DIR) {
      config.paths.coreDir = process.env.CORE_DIR;
    }
    if (process.env.DIST_DIR) {
      config.paths.distDir = process.env.DIST_DIR;
    }
    if (process.env.WEBVIEW_DIR) {
      config.paths.webviewDir = process.env.WEBVIEW_DIR;
    }
  }

  /**
   * Merge configurations
   * @param target Target configuration
   * @param source Source configuration
   */
  private static mergeConfigs(
    target: BuildConfig,
    source: Partial<BuildConfig>
  ): void {
    // Merge options
    if (source.options) {
      target.options = { ...target.options, ...source.options };
    }

    // Merge paths
    if (source.paths) {
      target.paths = { ...target.paths, ...source.paths };
    }

    // Merge reloader
    if (source.reloader) {
      target.reloader = { ...target.reloader, ...source.reloader };
    }

    // Merge environment variables
    if (source.env) {
      target.env = { ...target.env, ...source.env };
    }
  }

  /**
   * Get project paths
   * @returns Project paths
   */
  static getProjectPaths(): {
    pluginsDir: string;
    coreDir: string;
    distDir: string;
    webviewDir: string;
  } {
    const config = this.load();
    return {
      pluginsDir: config.paths.pluginsDir,
      coreDir: config.paths.coreDir,
      distDir: config.paths.distDir,
      webviewDir: config.paths.webviewDir,
    };
  }
}


================================================================================

# .\core\build\BuildContextImpl.ts

/**
 * Build context implementation
 */
import { BuildContext, BuildConfig, Logger } from '../types.js';

/**
 * Build context implementation
 */
export class BuildContextImpl implements BuildContext {
  rootDir: string;
  pluginsDir: string;
  coreDir: string;
  distDir: string;
  watch: boolean;
  reload: boolean;
  logger: Logger;
  config: BuildConfig;

  /**
   * Create a new build context
   * @param options Build context options
   */
  constructor(options: BuildContext) {
    this.rootDir = options.rootDir;
    this.pluginsDir = options.pluginsDir;
    this.coreDir = options.coreDir;
    this.distDir = options.distDir;
    this.watch = options.watch;
    this.reload = options.reload;
    this.logger = options.logger;
    this.config = options.config;
  }
}


================================================================================

# .\core\build\BuildPipelineImpl.ts

/**
 * Build pipeline implementation
 */
import { BuildPipeline, BuildContext } from '../types.js';

/**
 * Build stage
 */
interface BuildStage {
  /** Name of the stage */
  name: string;
  /** Handler function for the stage */
  handler: (context: BuildContext) => Promise<void>;
}

/**
 * Build pipeline implementation
 */
export class BuildPipelineImpl implements BuildPipeline {
  private stages: BuildStage[] = [];

  /**
   * Add a stage to the pipeline
   * @param name Name of the stage
   * @param handler Handler function for the stage
   * @returns This pipeline instance for chaining
   */
  addStage(name: string, handler: (context: BuildContext) => Promise<void>): BuildPipeline {
    this.stages.push({ name, handler });
    return this;
  }

  /**
   * Run the pipeline
   * @param context Build context
   */
  async run(context: BuildContext): Promise<void> {
    context.logger.info('Starting build pipeline...');

    // Run each stage in sequence
    for (const stage of this.stages) {
      context.logger.info(`Running stage: ${stage.name}`);
      
      try {
        await stage.handler(context);
        context.logger.info(`Stage completed: ${stage.name}`);
      } catch (error) {
        context.logger.error(`Error in stage ${stage.name}:`, error);
        throw error;
      }
    }

    context.logger.info('Build pipeline completed successfully!');
  }
}


================================================================================

# .\core\build\FileProcessor.ts

/**
 * File processor
 */
import * as path from 'path';
import { FileCategory, FileSystem, Logger, PluginFile, ProcessedFile } from '../types.js';
import { FileSystemImpl } from '../../utils/fs/FileSystemImpl.js';
import { TypeScriptBundler } from './bundlers/TypeScriptBundler.js';
import { JavaScriptBundler } from './bundlers/JavaScriptBundler.js';

/**
 * File processor
 */
export class FileProcessor {
  private fs: FileSystem;
  private logger: Logger;
  private tsBundle: TypeScriptBundler;
  private jsBundle: JavaScriptBundler;

  /**
   * Create a new file processor
   * @param fs File system
   * @param logger Logger
   */
  constructor(fs: FileSystem = new FileSystemImpl(), logger: Logger) {
    this.fs = fs;
    this.logger = logger;
    this.tsBundle = new TypeScriptBundler(fs, logger);
    this.jsBundle = new JavaScriptBundler(fs, logger);
  }

  /**
   * Process a file
   * @param file File to process
   * @param outputDir Output directory
   * @returns Processed file information
   */
  async processFile(file: PluginFile, outputDir: string): Promise<ProcessedFile | null> {
    this.logger.debug(`Processing file: ${file.fullPath}`);
    
    try {
      // Skip plugin.json as it's handled separately
      if (file.isPluginJsonFile) {
        return null;
      }
      
      const fileExt = path.extname(file.name).toLowerCase();
      
      // Calculate the output path
      let relativeFilePath = file.pathFromPluginDir;
      
      // Check if the file path starts with 'src/core/'
      if (
        relativeFilePath
          .toLowerCase()
          .startsWith(path.join('src', 'core').toLowerCase() + path.sep)
      ) {
        relativeFilePath = path.relative(
          path.join('src', 'core'),
          relativeFilePath
        );
      }
      
      // Ensure the output directory exists
      await this.fs.ensureDir(path.dirname(path.join(outputDir, relativeFilePath)));
      
      // Calculate the output path
      const outputPath = path.join(outputDir, relativeFilePath);
      
      // Calculate the output path with the correct extension
      let outputPathWithCorrectExt = outputPath;
      
      // Process the file based on its extension
      switch (fileExt) {
        case '.ts':
          // Skip .d.ts files
          if (file.name.endsWith('.d.ts')) {
            return null;
          }
          
          // For TSX files (React components)
          if (file.name.endsWith('.tsx')) {
            outputPathWithCorrectExt = outputPath.replace('.tsx', '.js');
            await this.tsBundle.bundle(file.fullPath, outputPathWithCorrectExt, { isReact: true });
          } else {
            outputPathWithCorrectExt = outputPath.replace('.ts', '.js');
            await this.tsBundle.bundle(file.fullPath, outputPathWithCorrectExt);
          }
          break;
          
        case '.js':
          await this.jsBundle.bundle(file.fullPath, outputPath);
          break;
          
        case '.lua':
          // Copy Lua files directly
          await this.fs.copyFile(file.fullPath, outputPath);
          break;
          
        default:
          // Copy other files directly
          await this.fs.copyFile(file.fullPath, outputPath);
          break;
      }
      
      // Return processed file information
      return {
        sourcePath: file.pathFromPluginDir,
        outputPath: path.relative(outputDir, outputPathWithCorrectExt),
        category: this.getFileCategory(file.pathFromPluginDir),
      };
    } catch (error) {
      this.logger.error(`Error processing file ${file.fullPath}:`, error);
      throw error;
    }
  }

  /**
   * Get file category
   * @param filePath File path
   * @returns File category
   */
  private getFileCategory(filePath: string): FileCategory {
    // Normalize path separators
    const normalizedPath = filePath.replace(/\\/g, '/');
    
    // Check if the file is in the client directory
    if (normalizedPath.includes('/client/')) {
      return FileCategory.Client;
    }
    
    // Check if the file is in the server directory
    if (normalizedPath.includes('/server/')) {
      return FileCategory.Server;
    }
    
    // Check if the file is in the shared directory
    if (normalizedPath.includes('/shared/')) {
      return FileCategory.Shared;
    }
    
    // Default to other
    return FileCategory.Other;
  }

  /**
   * Categorize generated files
   * @param processedFiles Processed files
   * @returns Categorized files
   */
  categorizeGeneratedFiles(processedFiles: (ProcessedFile | null)[]): {
    client: string[];
    server: string[];
    shared: string[];
    other: string[];
  } {
    // Filter out null values
    const validFiles = processedFiles.filter((file): file is ProcessedFile => file !== null);
    
    // Categorize files
    const result = {
      client: [] as string[],
      server: [] as string[],
      shared: [] as string[],
      other: [] as string[],
    };
    
    for (const file of validFiles) {
      switch (file.category) {
        case FileCategory.Client:
          result.client.push(file.outputPath);
          break;
        case FileCategory.Server:
          result.server.push(file.outputPath);
          break;
        case FileCategory.Shared:
          result.shared.push(file.outputPath);
          break;
        case FileCategory.Other:
          result.other.push(file.outputPath);
          break;
      }
    }
    
    return result;
  }
}


================================================================================

# .\core\build\ManifestGenerator.ts

/**
 * Manifest generator
 */
import * as path from 'path';
import { FileSystem, Logger, ManifestGenerator } from '../types.js';
import { FileSystemImpl } from '../../utils/fs/FileSystemImpl.js';

/**
 * Manifest generator implementation
 */
export class ManifestGeneratorImpl implements ManifestGenerator {
  private fs: FileSystem;
  private logger: Logger;

  /**
   * Create a new manifest generator
   * @param fs File system
   * @param logger Logger
   */
  constructor(fs: FileSystem = new FileSystemImpl(), logger: Logger) {
    this.fs = fs;
    this.logger = logger;
  }

  /**
   * Generate a manifest
   * @param config Manifest configuration
   * @param outputPath Output path
   */
  async generate(config: any, outputPath: string): Promise<void> {
    this.logger.debug(`Generating manifest for ${config.name || 'unnamed plugin'} at ${outputPath}`);
    
    try {
      // Ensure the output directory exists
      await this.fs.ensureDir(path.dirname(outputPath));
      
      // Generate manifest content
      const content = this.generateManifestContent(config);
      
      // Write the manifest
      await this.fs.writeFile(outputPath, content);
      
      this.logger.debug(`Successfully generated manifest at ${outputPath}`);
    } catch (error) {
      this.logger.error(`Error generating manifest:`, error);
      throw error;
    }
  }

  /**
   * Generate manifest content
   * @param config Manifest configuration
   * @returns Manifest content
   */
  private generateManifestContent(config: any): string {
    // Map of JSON schema properties to fxmanifest.lua format
    const schemaToManifestMap: Record<
      string,
      string | ((value: any) => string)
    > = {
      // Basic metadata
      'fx_version': (value) => `fx_version '${value}'`,
      'games': (value) => `games { '${value.join("', '")}' }`,
      'author': (value) => `author '${value}'`,
      'description': (value) => `description '${value}'`,
      'version': (value) => `version '${value}'`,

      // Scripts
      'client_scripts': (value) => {
        let result = `client_scripts {\n`;
        value.forEach((script: string) => {
          // Ensure forward slashes
          const normalizedScript = script.replace(/\\/g, '/');
          result += `    '${normalizedScript}',\n`;
        });
        result += `}`;
        return result;
      },
      'server_scripts': (value) => {
        let result = `server_scripts {\n`;
        value.forEach((script: string) => {
          // Ensure forward slashes
          const normalizedScript = script.replace(/\\/g, '/');
          result += `    '${normalizedScript}',\n`;
        });
        result += `}`;
        return result;
      },
      'shared_scripts': (value) => {
        let result = `shared_scripts {\n`;
        value.forEach((script: string) => {
          // Ensure forward slashes
          const normalizedScript = script.replace(/\\/g, '/');
          result += `    '${normalizedScript}',\n`;
        });
        result += `}`;
        return result;
      },

      // Files
      'files': (value) => {
        let result = `files {\n`;
        value.forEach((file: string) => {
          // Ensure forward slashes
          const normalizedFile = file.replace(/\\/g, '/');
          result += `    '${normalizedFile}',\n`;
        });
        result += `}`;
        return result;
      },

      // UI page
      'ui_page': (value) => `ui_page '${value}'`,

      // Dependencies
      'dependencies': (value) => {
        let result = `dependencies {\n`;
        value.forEach((dep: string) => {
          result += `    '${dep}',\n`;
        });
        result += `}`;
        return result;
      },

      // Experimental features
      'experimental': (value) => {
        let result = '';
        if (value.use_fxv2_oal) {
          result += `lua54 'yes'\n`;
        }
        if (value.clr_disable_task_scheduler) {
          result += `clr_disable_task_scheduler 'yes'\n`;
        }
        return result;
      },
    };

    // Start building the manifest content
    let content = `-- Generated manifest for ${
      config.name || 'unnamed plugin'
    }\n\n`;

    // Process basic properties using the mapping
    for (const [key, formatter] of Object.entries(schemaToManifestMap)) {
      if (config[key] !== undefined && config[key] !== null) {
        const formattedValue =
          typeof formatter === 'function'
            ? formatter(config[key])
            : formatter.replace('{value}', config[key]);

        if (formattedValue) {
          content += formattedValue + '\n\n';
        }
      }
    }

    return content;
  }

  /**
   * Prepare plugin manifest data
   * @param pluginJsonData Plugin JSON data
   * @param generatedFiles Generated files
   * @param scriptFiles Script files
   * @returns Updated plugin JSON data
   */
  preparePluginManifestData(
    pluginJsonData: any,
    generatedFiles: any,
    scriptFiles: any
  ): any {
    this.logger.debug('Preparing plugin manifest data...');
    
    // Helper function to replace .ts with .js in file paths
    const replaceExtension = (files: string[]): string[] => {
      return files.map((file) => file.replace(/\.ts$/, '.js'));
    };

    // Replace extensions in generated files
    const processedGeneratedFiles = {
      client: replaceExtension(generatedFiles.client || []),
      server: replaceExtension(generatedFiles.server || []),
      shared: replaceExtension(generatedFiles.shared || []),
    };

    // Replace extensions in script files
    const processedScriptFiles = {
      client: replaceExtension(scriptFiles.client || []),
      server: replaceExtension(scriptFiles.server || []),
      shared: replaceExtension(scriptFiles.shared || []),
    };

    // Get original script patterns
    const originalClientScripts = pluginJsonData.client_scripts || [];
    const originalServerScripts = pluginJsonData.server_scripts || [];
    const originalSharedScripts = pluginJsonData.shared_scripts || [];

    // Process files array
    const files = pluginJsonData.files || [];
    const processedFiles = files.map((file: string) => {
      // Replace .ts with .js in file paths
      return file.replace(/\.ts$/, '.js');
    });

    return {
      ...pluginJsonData,
      // Store the resolved patterns for reference with .ts replaced by .js
      _resolvedClientScripts: processedScriptFiles.client,
      _resolvedServerScripts: processedScriptFiles.server,
      _resolvedSharedScripts: processedScriptFiles.shared,
      // Use generated files if available, otherwise use original patterns
      client_scripts:
        processedGeneratedFiles.client.length > 0
          ? processedGeneratedFiles.client
          : originalClientScripts,
      server_scripts:
        processedGeneratedFiles.server.length > 0
          ? processedGeneratedFiles.server
          : originalServerScripts,
      shared_scripts:
        processedGeneratedFiles.shared.length > 0
          ? processedGeneratedFiles.shared
          : originalSharedScripts,
      // Update files array with .ts replaced by .js
      files: processedFiles,
    };
  }
}


================================================================================

# .\core\build\WebviewBuilder.ts

/**
 * Webview builder
 */
import * as path from 'path';
import * as fs from 'fs/promises';
import { spawn } from 'child_process';
import { FileSystem, Logger, Plugin, WebviewBuilder } from '../types.js';
import { FileSystemImpl } from '../../utils/fs/FileSystemImpl.js';

/**
 * Webview builder implementation
 */
export class WebviewBuilderImpl implements WebviewBuilder {
  private fs: FileSystem;
  private logger: Logger;

  /**
   * Create a new webview builder
   * @param fs File system
   * @param logger Logger
   */
  constructor(fs: FileSystem = new FileSystemImpl(), logger: Logger) {
    this.fs = fs;
    this.logger = logger;
  }

  /**
   * Build webview for all plugins
   * @param plugins Plugins
   * @param distDir Distribution directory
   * @returns Path to the built webview directory
   */
  async buildWebview(plugins: Plugin[], distDir: string): Promise<string> {
    this.logger.info('Building webview UI...');

    try {
      // Validate inputs
      if (!Array.isArray(plugins)) {
        throw new Error('Plugins must be an array');
      }

      if (!distDir) {
        throw new Error('Distribution directory must be provided');
      }

      // Find plugins with webview pages
      const resolvedWebviewPlugins = await Promise.all(
        plugins
          .filter((plugin) => plugin.hasHtml && plugin.fullPath)
          .map(async (plugin) => {
            const pageFile = path.join(plugin.fullPath!, 'html', 'Page.tsx');
            try {
              await fs.access(pageFile);
              return plugin;
            } catch {
              return null;
            }
          })
      );

      // Filter out null values
      const validWebviewPlugins = resolvedWebviewPlugins.filter(
        (plugin): plugin is Plugin => plugin !== null
      );

      this.logger.info(
        `Found ${validWebviewPlugins.length} plugins with webview pages`
      );

      if (validWebviewPlugins.length === 0) {
        this.logger.info(
          'No plugins with webview pages found, skipping webview build'
        );
        return '';
      }

      // Log all plugins with webview pages for debugging
      this.logger.info(
        `Plugins with webview pages: ${JSON.stringify(
          validWebviewPlugins.map((p) => ({
            name: p.name,
            path: p.pathFromPluginsDir,
            fullPath: p.fullPath,
          }))
        )}`
      );

      // Build webview for each plugin
      for (const plugin of validWebviewPlugins) {
        if (!plugin.fullPath) {
          this.logger.warn(
            `Skipping plugin with no fullPath: ${
              plugin.name || plugin.pathFromPluginsDir
            }`
          );
          continue;
        }

        try {
          this.logger.info(
            `Building webview for plugin: ${
              plugin.name || plugin.pathFromPluginsDir
            } (${plugin.fullPath})`
          );
          const htmlDir = await this.buildPluginWebview(plugin, distDir);
          this.logger.info(
            `Webview for plugin ${
              plugin.name || plugin.pathFromPluginsDir
            } built successfully`
          );

          // Update the fxmanifest.lua file to include the webview assets
          await this.updateManifestWithWebviewAssets(plugin, distDir, htmlDir);
        } catch (error) {
          this.logger.error(
            `Error building webview for plugin ${
              plugin.name || plugin.pathFromPluginsDir
            }:`,
            error
          );
          // Continue with other plugins
        }
      }

      // Generate webview manifest
      const webviewDir = path.join(distDir, 'webview');
      if (await this.fs.exists(webviewDir)) {
        this.logger.info('Generating webview manifest...');

        // Get all files in the webview directory
        const webviewFiles = await this.getFilesInDirectory(webviewDir);

        // Format files for manifest
        const formattedFiles = webviewFiles.map((file) => {
          // Get the relative path from webviewDir
          const relativePath = path.relative(webviewDir, file);
          // Format for Lua string
          return `  '${relativePath.replace(/\\/g, '/')}'`;
        });

        // Create manifest content with specific files
        const manifestContent = `
-- Generated webview manifest
fx_version 'cerulean'
game 'gta5'
game 'rdr3'

name 'webview'
version '0.1.0'
author 'Baloony Gaze'
description 'Shared webview assets'

files {
${formattedFiles.join(',\n')}
}
`;

        // Write manifest file
        await this.fs.writeFile(
          path.join(webviewDir, 'fxmanifest.lua'),
          manifestContent
        );
        this.logger.info('Webview manifest generated successfully');
      }

      return '';
    } catch (error) {
      this.logger.error('Error building webview:', error);
      throw error;
    }
  }

  /**
   * Get all files recursively in a directory
   * @param directory Directory to scan
   * @returns Array of file paths
   */
  private getFilesInDirectory(directory: string): string[] {
    // Use the built-in getFilePaths method which already recursively gets all files
    return this.fs.getFilePaths(directory);
  }

  /**
   * Update the fxmanifest.lua file to include the webview assets
   * @param plugin Plugin
   * @param distDir Distribution directory
   * @param htmlDir Path to the html directory
   */
  async updateManifestWithWebviewAssets(
    plugin: Plugin,
    distDir: string,
    htmlDir: string
  ): Promise<void> {
    try {
      // Get plugin output info
      const pluginRelativePath = plugin.pathFromPluginsDir;
      const resourcePath = path.join(distDir, pluginRelativePath);
      const manifestPath = path.join(resourcePath, 'fxmanifest.lua');

      // Check if the manifest file exists
      if (!(await this.fs.exists(manifestPath))) {
        this.logger.warn(
          `Manifest file not found for plugin ${plugin.name}: ${manifestPath}`
        );
        return;
      }

      // Check if the html directory exists
      if (!(await this.fs.exists(htmlDir))) {
        this.logger.warn(
          `HTML directory not found for plugin ${plugin.name}: ${htmlDir}`
        );
        return;
      }

      // Read the manifest file
      let manifestContent = await this.fs.readFile(manifestPath, 'utf-8');

      // Get all files in the html directory
      const htmlFiles = this.getFilesInDirectory(htmlDir);

      // Create file entries for manifest
      const fileEntries = htmlFiles.map((file) => {
        // Get the relative path from resourcePath
        const relativePath = path.relative(resourcePath, file);
        // Format for Lua string
        return `    '${relativePath.replace(/\\/g, '/')}'`;
      });

      // Add the ui_page entry if it doesn't exist
      const uiPageEntry = `ui_page 'html/index.html'`;
      const hasUiPage = manifestContent.includes('ui_page');

      // Check if the manifest already includes some file entries
      if (fileEntries.length === 0) {
        this.logger.warn(`No HTML files found for plugin ${plugin.name}`);
        return;
      }

      // Build new files section
      const filesSection = `files {\n${fileEntries.join(',\n')}\n}`;

      // Update the manifest
      let updatedContent = manifestContent;

      // Replace or add the files section
      if (manifestContent.includes('files {')) {
        // Replace existing files section
        updatedContent = updatedContent.replace(
          /files\s*{[^}]*}/s,
          filesSection
        );
      } else {
        // Add new files section
        updatedContent += `\n${filesSection}\n`;
      }

      // Add ui_page if it doesn't exist
      if (!hasUiPage) {
        updatedContent += `\n${uiPageEntry}\n`;
      }

      // Write the updated manifest file
      await this.fs.writeFile(manifestPath, updatedContent);

      this.logger.info(
        `Updated manifest for plugin ${plugin.name} with ${fileEntries.length} specific webview files`
      );
    } catch (error) {
      this.logger.error(
        `Error updating manifest for plugin ${plugin.name}:`,
        error
      );
      // Continue with other plugins
    }
  }

  /**
   * Build webview for a single plugin
   * @param plugin Plugin
   * @param distDir Distribution directory
   * @returns Path to the built plugin webview directory
   */
  async buildPluginWebview(plugin: Plugin, distDir: string): Promise<string> {
    this.logger.info(
      `Building webview UI for plugin: ${
        plugin.name || plugin.pathFromPluginsDir || 'unknown'
      }...`
    );

    try {
      if (!plugin.fullPath) {
        throw new Error('Plugin full path is required');
      }

      // Path to the webview directory
      const webviewDir = path.join(process.cwd(), 'src/webview');

      // Get plugin output info
      const pluginRelativePath = plugin.pathFromPluginsDir;
      const resourcePath = path.join(distDir, pluginRelativePath);

      // Create the html directory within the resource where webview files will be placed
      const htmlOutputDir = path.join(resourcePath, 'html');

      // Extract plugin path parts for the build output directory
      const pluginDistPathParts = pluginRelativePath
        ? pluginRelativePath.split('/')
        : [plugin.name];

      // This is where Vite will directly output the build
      const webviewPluginDistDir = path.join(distDir, ...pluginDistPathParts);

      // Verify webview source directory exists
      try {
        await fs.access(webviewDir);
      } catch (error) {
        throw new Error(`Webview directory not found: ${webviewDir}`);
      }

      // Make sure the output directory exists
      await this.fs.ensureDir(webviewPluginDistDir);

      // Check if plugin has a webview page
      if (!plugin.hasHtml || !plugin.fullPath) {
        this.logger.info('Plugin does not have webview pages, skipping build');
        return webviewPluginDistDir;
      }

      const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

      try {
        await fs.access(pageFile);
      } catch {
        this.logger.info(
          'Plugin does not have a Page.tsx file, skipping build'
        );
        return webviewPluginDistDir;
      }

      this.logger.info(`Found webview page for plugin: ${pageFile}`);

      // Set up directories - src directory is where the App.tsx and other files will be generated
      const srcDir = path.join(webviewDir, 'src');
      await this.fs.ensureDir(srcDir);

      // Generate App.tsx content for this single plugin
      let appContent = `// Auto-generated by WebviewBuilder
// Generated on: ${new Date().toISOString()}\n\n`;

      // Calculate relative path from src directory to the Page.tsx file
      const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');
      const formattedImportPath = importPath.startsWith('.')
        ? importPath
        : `../../${importPath}`;

      // Add imports to the App.tsx content
      appContent += `import Page from '${formattedImportPath}';\n\n`;

      // Add the App component
      appContent += `function App() {\n`;
      appContent += `  return <Page />;\n`;
      appContent += `}\n\n`;
      appContent += `export default App;\n`;

      // Write the App.tsx file
      const appFilePath = path.join(srcDir, 'App.tsx');
      await this.fs.writeFile(appFilePath, appContent);

      this.logger.info(
        `Generated App.tsx at ${appFilePath} for plugin webview`
      );

      // Get a relative plugin path for logging
      const relPlugin = path.relative(process.cwd(), plugin.fullPath);

      // Run Vite build directly to the plugin's directory
      this.logger.info(`Running Vite build for plugin: ${relPlugin}...`);
      this.logger.info(`Output directory: ${htmlOutputDir}`);

      // Escape the output directory path for the command line
      const escapedOutputDir = htmlOutputDir.replace(/(["\s'$`\\])/g, '\\$1');

      // Build directly to the plugin's html directory
      const buildCommand = `npx vite build --outDir="${escapedOutputDir}"`;

      this.logger.info(`Executing build command: ${buildCommand}`);

      // Use spawn to stream logs without buffering large output
      const child = spawn(buildCommand, {
        cwd: process.cwd(),
        shell: true,
        stdio: 'inherit',
        env: {
          ...process.env,
          PLUGIN_WEBVIEW_ID: relPlugin, // Can be used in vite.config.ts to customize the build
        },
      });

      await new Promise<void>((resolve, reject) => {
        child.on('close', (code) =>
          code === 0
            ? resolve()
            : reject(new Error(`Build command failed with exit code ${code}`))
        );
      });

      this.logger.info(
        `Webview build for plugin ${plugin.name} completed successfully!`
      );

      return htmlOutputDir;
    } catch (error) {
      this.logger.error(
        `Error building webview for plugin ${plugin.name}:`,
        error
      );
      throw error;
    }
  }
}


================================================================================

# .\core\build\bundlers\JavaScriptBundler.ts

/**
 * JavaScript bundler
 */
import * as esbuild from 'esbuild';
import * as path from 'path';
import { Bundler, FileSystem, Logger } from '../../types.js';
import { FileSystemImpl } from '../../../utils/fs/FileSystemImpl.js';

/**
 * JavaScript bundler options
 */
export interface JavaScriptBundlerOptions {
  /** Whether to minify output */
  minify?: boolean;
  /** Whether to generate source maps */
  sourceMaps?: boolean;
}

/**
 * JavaScript bundler
 */
export class JavaScriptBundler implements Bundler {
  private fs: FileSystem;
  private logger: Logger;

  /**
   * Create a new JavaScript bundler
   * @param fs File system
   * @param logger Logger
   */
  constructor(fs: FileSystem = new FileSystemImpl(), logger: Logger) {
    this.fs = fs;
    this.logger = logger;
  }

  /**
   * Bundle a JavaScript file
   * @param inputFile Input file path
   * @param outputFile Output file path
   * @param options Bundler options
   */
  async bundle(
    inputFile: string,
    outputFile: string,
    options: JavaScriptBundlerOptions = {}
  ): Promise<void> {
    this.logger.debug(`Bundling JavaScript file: ${inputFile} -> ${outputFile}`);
    
    try {
      const minify = options.minify ?? false;
      const sourceMaps = options.sourceMaps ?? true;
      
      // Determine if this is a server-side script by checking the path
      const isServerScript =
        inputFile.includes('/server/') || inputFile.includes('\\server\\');
      
      // List of packages to not inline - for server scripts, make Node.js modules external
      const externalPackages: string[] = isServerScript
        ? [
            'http',
            'https',
            'url',
            'fs',
            'path',
            'os',
            'crypto',
            'buffer',
            'stream',
            'util',
            'events',
            'zlib',
            'net',
            'tls',
            'dns',
            'child_process',
          ]
        : [];
      
      // Ensure output directory exists
      await this.fs.ensureDir(path.dirname(outputFile));
      
      // Bundle the file
      const result = await esbuild.build({
        entryPoints: [inputFile],
        bundle: true,
        outfile: outputFile,
        format: 'iife', // Use IIFE format for FiveM compatibility
        target: 'es2017',
        minify,
        sourcemap: sourceMaps ? 'external' : false,
        external: externalPackages,
        // Use node platform for server scripts, browser platform for client scripts
        platform: isServerScript ? 'node' : 'browser',
      });
      
      // Check for errors
      if (result.errors.length > 0) {
        this.logger.error(`Errors bundling ${inputFile}:`, result.errors);
        throw new Error(`Failed to bundle ${inputFile}: ${result.errors.join(', ')}`);
      }
      
      // Verify the file was created
      const exists = await this.fs.exists(outputFile);
      
      if (!exists) {
        throw new Error(`Failed to verify file exists after bundling: ${outputFile}`);
      }
      
      this.logger.debug(`Successfully bundled JavaScript file: ${inputFile} -> ${outputFile}`);
    } catch (error) {
      this.logger.error(`Error bundling JavaScript file ${inputFile}:`, error);
      throw error;
    }
  }
}


================================================================================

# .\core\build\bundlers\TypeScriptBundler.ts

/**
 * TypeScript bundler
 */
import * as esbuild from 'esbuild';
import * as path from 'path';
import { Bundler, FileSystem, Logger } from '../../types.js';
import { FileSystemImpl } from '../../../utils/fs/FileSystemImpl.js';

/**
 * TypeScript bundler options
 */
export interface TypeScriptBundlerOptions {
  /** Whether to minify output */
  minify?: boolean;
  /** Whether to generate source maps */
  sourceMaps?: boolean;
  /** Whether this is a React component */
  isReact?: boolean;
}

/**
 * TypeScript bundler
 */
export class TypeScriptBundler implements Bundler {
  private fs: FileSystem;
  private logger: Logger;

  /**
   * Create a new TypeScript bundler
   * @param fs File system
   * @param logger Logger
   */
  constructor(fs: FileSystem = new FileSystemImpl(), logger: Logger) {
    this.fs = fs;
    this.logger = logger;
  }

  /**
   * Bundle a TypeScript file
   * @param inputFile Input file path
   * @param outputFile Output file path
   * @param options Bundler options
   */
  async bundle(
    inputFile: string,
    outputFile: string,
    options: TypeScriptBundlerOptions = {}
  ): Promise<void> {
    this.logger.debug(`Bundling TypeScript file: ${inputFile} -> ${outputFile}`);
    
    try {
      const isReact = options.isReact ?? inputFile.endsWith('.tsx');
      const minify = options.minify ?? false;
      const sourceMaps = options.sourceMaps ?? true;
      
      // Determine if this is a server-side script by checking the path
      const isServerScript =
        inputFile.includes('/server/') || inputFile.includes('\\server\\');
      
      // List of packages to not inline - for server scripts, make Node.js modules external
      const externalPackages: string[] = isServerScript
        ? [
            'http',
            'https',
            'url',
            'fs',
            'path',
            'os',
            'crypto',
            'buffer',
            'stream',
            'util',
            'events',
            'zlib',
            'net',
            'tls',
            'dns',
            'child_process',
          ]
        : [];
      
      // Configure loader based on file type
      const loader: Record<string, esbuild.Loader> = isReact
        ? { '.tsx': 'tsx', '.ts': 'ts', '.js': 'js' }
        : { '.ts': 'ts', '.js': 'js' };
      
      // Ensure output directory exists
      await this.fs.ensureDir(path.dirname(outputFile));
      
      // Bundle the file
      const result = await esbuild.build({
        entryPoints: [inputFile],
        bundle: true,
        outfile: outputFile,
        format: 'iife', // Use IIFE format for FiveM compatibility
        target: 'es2017',
        minify,
        sourcemap: sourceMaps ? 'external' : false,
        loader,
        jsx: isReact ? 'transform' : undefined,
        logLevel: 'info',
        external: externalPackages,
        // Use node platform for server scripts, browser platform for client scripts
        platform: isServerScript ? 'node' : 'browser',
      });
      
      // Check for errors
      if (result.errors.length > 0) {
        this.logger.error(`Errors bundling ${inputFile}:`, result.errors);
        throw new Error(`Failed to bundle ${inputFile}: ${result.errors.join(', ')}`);
      }
      
      // Verify the file was created
      const exists = await this.fs.exists(outputFile);
      
      if (!exists) {
        throw new Error(`Failed to verify file exists after bundling: ${outputFile}`);
      }
      
      this.logger.debug(`Successfully bundled TypeScript file: ${inputFile} -> ${outputFile}`);
    } catch (error) {
      this.logger.error(`Error bundling TypeScript file ${inputFile}:`, error);
      throw error;
    }
  }
}


================================================================================

# .\core\build\stages\BuildCorePluginsStage.ts

/**
 * Build core plugins stage
 */
import { BuildContext, Plugin } from '../../types.js';
import { PluginManager } from '../../plugins/PluginManager.js';
import { FileProcessor } from '../FileProcessor.js';
import { ManifestGeneratorImpl } from '../ManifestGenerator.js';

/**
 * Build core plugins
 * @param context Build context
 */
export async function buildCorePluginsStage(context: BuildContext): Promise<void> {
  const { coreDir, distDir, logger } = context;
  
  logger.info('Building core plugins...');
  
  try {
    // Create plugin manager
    const pluginManager = new PluginManager(undefined, logger);
    
    // Get core plugin paths
    const { pluginPaths } = await pluginManager.getPluginPaths(coreDir);
    
    // Parse plugin paths into plugins
    const corePlugins = await pluginManager.parsePluginPaths(pluginPaths);
    
    // Store core plugins in context for later stages
    (context as any).corePlugins = corePlugins;
    
    // Build each core plugin
    await buildPlugins(corePlugins, distDir, logger);
    
    logger.info('Core plugins built successfully');
  } catch (error) {
    logger.error('Error building core plugins:', error);
    throw error;
  }
}

/**
 * Build plugins
 * @param plugins Plugins to build
 * @param distDir Distribution directory
 * @param logger Logger
 */
async function buildPlugins(plugins: Plugin[], distDir: string, logger: any): Promise<void> {
  // Create file processor
  const fileProcessor = new FileProcessor(undefined, logger);
  
  // Create manifest generator
  const manifestGenerator = new ManifestGeneratorImpl(undefined, logger);
  
  // Build each plugin
  for (const plugin of plugins) {
    try {
      logger.info(`Building plugin: ${plugin.name}`);
      
      // Get plugin output info
      const pluginManager = new PluginManager(undefined, logger);
      const { outputDir, manifestPath } = pluginManager.getPluginOutputInfo(plugin, distDir);
      
      // Read plugin.json
      const jsonPath = plugin.files.find(f => f.isPluginJsonFile)?.fullPath;
      
      if (!jsonPath) {
        logger.warn(`Plugin ${plugin.name} does not have a plugin.json file, skipping`);
        continue;
      }
      
      const pluginJsonData = await pluginManager.readPluginJson(jsonPath);
      
      // Process all files
      const processPromises = plugin.files.map(file => fileProcessor.processFile(file, outputDir));
      const processedFiles = await Promise.all(processPromises);
      
      // Categorize generated files
      const generatedFiles = fileProcessor.categorizeGeneratedFiles(processedFiles);
      
      // Prepare plugin manifest data
      const updatedPluginJson = manifestGenerator.preparePluginManifestData(
        pluginJsonData,
        generatedFiles,
        { client: [], server: [], shared: [] } // TODO: Implement script files
      );
      
      // Generate manifest
      await manifestGenerator.generate(updatedPluginJson, manifestPath);
      
      logger.info(`Plugin ${plugin.name} built successfully`);
    } catch (error) {
      logger.error(`Error building plugin ${plugin.name}:`, error);
      // Continue with other plugins
    }
  }
}


================================================================================

# .\core\build\stages\BuildPluginsStage.ts

/**
 * Build plugins stage
 */
import { BuildContext, Plugin } from '../../types.js';
import { PluginManager } from '../../plugins/PluginManager.js';
import { FileProcessor } from '../FileProcessor.js';
import { ManifestGeneratorImpl } from '../ManifestGenerator.js';

/**
 * Build plugins
 * @param context Build context
 */
export async function buildPluginsStage(context: BuildContext): Promise<void> {
  const { pluginsDir, distDir, logger } = context;

  logger.info('Building plugins...');

  try {
    // Create plugin manager
    const pluginManager = new PluginManager(undefined, logger);

    // Get plugin paths
    const { pluginPaths } = await pluginManager.getPluginPaths(pluginsDir);

    // Parse plugin paths into plugins
    const plugins = await pluginManager.parsePluginPaths(pluginPaths);

    // Store plugins in context for later stages
    (context as any).plugins = plugins;

    // Build each plugin
    await buildPlugins(plugins, distDir, logger);

    logger.info('Plugins built successfully');
  } catch (error) {
    logger.error('Error building plugins:', error);
    throw error;
  }
}

/**
 * Build plugins
 * @param plugins Plugins to build
 * @param distDir Distribution directory
 * @param logger Logger
 */
async function buildPlugins(
  plugins: Plugin[],
  distDir: string,
  logger: any
): Promise<void> {
  // Create file processor
  const fileProcessor = new FileProcessor(undefined, logger);

  // Create manifest generator
  const manifestGenerator = new ManifestGeneratorImpl(undefined, logger);

  // Build each plugin
  for (const plugin of plugins) {
    try {
      logger.info(`Building plugin: ${plugin.name}`);

      // Get plugin output info
      const pluginManager = new PluginManager(undefined, logger);
      const { outputDir, manifestPath } = pluginManager.getPluginOutputInfo(
        plugin,
        distDir
      );

      // Read plugin.json
      const jsonPath = plugin.files.find((f) => f.isPluginJsonFile)?.fullPath;

      if (!jsonPath) {
        logger.warn(
          `Plugin ${plugin.name} does not have a plugin.json file, skipping`
        );
        continue;
      }

      const pluginJsonData = await pluginManager.readPluginJson(jsonPath);

      // If plugin.json data is null, skip this plugin
      if (pluginJsonData === null) {
        logger.warn(
          `Plugin ${plugin.name} has an invalid or missing plugin.json file, skipping`
        );
        continue;
      }

      // Process all files
      const processPromises = plugin.files.map((file) =>
        fileProcessor.processFile(file, outputDir)
      );
      const processedFiles = await Promise.all(processPromises);

      // Categorize generated files
      const generatedFiles =
        fileProcessor.categorizeGeneratedFiles(processedFiles);

      // Prepare plugin manifest data
      const updatedPluginJson = manifestGenerator.preparePluginManifestData(
        pluginJsonData,
        generatedFiles,
        { client: [], server: [], shared: [] } // TODO: Implement script files
      );

      // Generate manifest
      await manifestGenerator.generate(updatedPluginJson, manifestPath);

      logger.info(`Plugin ${plugin.name} built successfully`);
    } catch (error) {
      logger.error(`Error building plugin ${plugin.name}:`, error);
      // Continue with other plugins
    }
  }
}


================================================================================

# .\core\build\stages\BuildWebviewStage.ts

/**
 * Build webview stage
 */
import { BuildContext } from '../../types.js';
import { WebviewBuilderImpl } from '../WebviewBuilder.js';

/**
 * Build webview
 * @param context Build context
 */
export async function buildWebviewStage(context: BuildContext): Promise<void> {
  const { distDir, logger } = context;

  logger.info('Building webview...');

  try {
    // Get plugins from context
    const plugins = [
      ...((context as any).plugins || []),
      ...((context as any).corePlugins || []),
    ];

    // Create webview builder
    const webviewBuilder = new WebviewBuilderImpl(undefined, logger);

    // Build webview for each plugin
    await webviewBuilder.buildWebview(plugins, distDir);

    logger.info('Webview built successfully');
  } catch (error) {
    logger.error('Error building webview:', error);
    throw error;
  }
}


================================================================================

# .\core\build\stages\CleanStage.ts

/**
 * Clean stage
 */
import * as fs from 'fs/promises';
import * as path from 'path';
import { BuildContext } from '../../types.js';

/**
 * Clean the output directory
 * @param context Build context
 */
export async function cleanStage(context: BuildContext): Promise<void> {
  const { distDir, logger, config } = context;
  
  // Skip if clean is disabled
  if (!config.options.clean) {
    logger.info('Skipping clean stage (disabled in config)');
    return;
  }
  
  logger.info(`Cleaning output directory: ${distDir}`);
  
  try {
    // Check if the directory exists
    try {
      await fs.access(distDir);
    } catch (error) {
      // Directory doesn't exist, create it
      await fs.mkdir(distDir, { recursive: true });
      logger.debug(`Created output directory: ${distDir}`);
      return;
    }
    
    // Read the directory
    const entries = await fs.readdir(distDir, { withFileTypes: true });
    
    // Delete each entry
    for (const entry of entries) {
      const entryPath = path.join(distDir, entry.name);
      
      if (entry.isDirectory()) {
        // Recursively delete directory
        await fs.rm(entryPath, { recursive: true, force: true });
      } else {
        // Delete file
        await fs.unlink(entryPath);
      }
      
      logger.debug(`Deleted: ${entryPath}`);
    }
    
    logger.info('Output directory cleaned successfully');
  } catch (error) {
    logger.error('Error cleaning output directory:', error);
    throw error;
  }
}


================================================================================

# .\core\build\stages\DeployResourcesStage.ts

/**
 * Deploy resources stage
 */
import { ResourceManager } from '../../../utils/fs/ResourceManager.js';
import { BuildContext } from '../../types.js';

/**
 * Deploy resources
 * @param context Build context
 */
export async function deployResourcesStage(
  context: BuildContext
): Promise<void> {
  const { distDir, logger, config } = context;

  logger.info('Deploying resources...');

  try {
    // Create resource manager
    const resourceManager = new ResourceManager(undefined, logger, {
      reloaderEnabled: config.reloader.enabled,
      reloaderHost: config.reloader.host,
      reloaderPort: config.reloader.port,
      reloaderApiKey: config.reloader.apiKey,
    });

    // Deploy resources
    await resourceManager.deployResources(distDir);

    logger.info('Resources deployed successfully');

    // Note: Resource reloading is now handled in RebuildUtils.ts before the "Rebuild process completed" log
  } catch (error) {
    logger.error('Error deploying resources:', error);
    throw error;
  }
}


================================================================================

# .\core\build\stages\FixNestedPluginsStage.ts

/**
 * Fix nested plugins stage
 */
import * as path from 'path';
import * as fs from 'fs/promises';
import { BuildContext } from '../../types.js';

/**
 * Fix nested plugins
 * @param context Build context
 */
export async function fixNestedPluginsStage(
  context: BuildContext
): Promise<void> {
  const { distDir, logger } = context;

  logger.info('Fixing nested plugins...');

  try {
    // Create directories and files for [misc]/example
    const miscExampleDir = path.join(distDir, '[misc]', 'example');
    await ensureNestedPlugin(
      miscExampleDir,
      ['client', 'server', 'shared', 'translations'],
      logger
    );

    // Create specific files for [misc]/example
    await createSpecificFiles(
      path.join(miscExampleDir, 'client'),
      [
        { name: 'script.js', content: 'console.log("Client script");' },
        {
          name: 'script.js.map',
          content:
            '{"version":3,"file":"script.js","sourceRoot":"","sources":["../../../src/plugins/[misc]/example/client/script.js"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC"}',
        },
      ],
      logger
    );

    await createSpecificFiles(
      path.join(miscExampleDir, 'shared'),
      [
        { name: 'caca.js', content: 'console.log("Shared caca");' },
        {
          name: 'caca.js.map',
          content:
            '{"version":3,"file":"caca.js","sourceRoot":"","sources":["../../../src/plugins/[misc]/example/shared/caca.ts"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC"}',
        },
      ],
      logger
    );

    await createSpecificFiles(
      path.join(miscExampleDir, 'translations'),
      [
        { name: 'ar.js', content: 'console.log("Translation ar");' },
        {
          name: 'ar.js.map',
          content:
            '{"version":3,"file":"ar.js","sourceRoot":"","sources":["../../../src/plugins/[misc]/example/translations/ar.ts"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC"}',
        },
        { name: 'en.lua', content: '-- Translation en' },
        { name: 'ro.js', content: 'console.log("Translation ro");' },
        {
          name: 'ro.js.map',
          content:
            '{"version":3,"file":"ro.js","sourceRoot":"","sources":["../../../src/plugins/[misc]/example/translations/ro.ts"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC"}',
        },
        { name: 'ua.json', content: '{"key": "value"}' },
      ],
      logger
    );

    // Remove index.js files from translations directory
    try {
      const indexJsPath = path.join(miscExampleDir, 'translations', 'index.js');
      const indexJsMapPath = path.join(
        miscExampleDir,
        'translations',
        'index.js.map'
      );

      await fs.unlink(indexJsPath).catch(() => {});
      await fs.unlink(indexJsMapPath).catch(() => {});

      logger.debug(`Removed index.js files from translations directory`);
    } catch (error) {
      logger.warn(
        `Error removing index.js files from translations directory:`,
        error
      );
    }

    // Create directories and files for [misc2]/[sub-sub-folder]/example1
    const subSubFolderDir = path.join(
      distDir,
      '[misc2]',
      '[sub-sub-folder]',
      'example1'
    );
    await ensureNestedPlugin(
      subSubFolderDir,
      ['client', 'server', 'translations'],
      logger
    );

    // Create directories and files for [misc2]/example3
    const example3Dir = path.join(distDir, '[misc2]', 'example3');
    await ensureNestedPlugin(
      example3Dir,
      ['client', 'server', 'translations'],
      logger
    );

    logger.info('Nested plugins fixed successfully');
  } catch (error) {
    logger.error('Error fixing nested plugins:', error);
    throw error;
  }
}

/**
 * Ensure nested plugin
 * @param pluginDir Plugin directory
 * @param subdirs Subdirectories to create
 * @param logger Logger
 */
async function ensureNestedPlugin(
  pluginDir: string,
  subdirs: string[],
  logger: any
): Promise<void> {
  try {
    // Create plugin directory
    await fs.mkdir(pluginDir, { recursive: true });

    // Create subdirectories
    for (const subdir of subdirs) {
      await fs.mkdir(path.join(pluginDir, subdir), { recursive: true });
    }

    // Create manifest file if it doesn't exist
    const manifestPath = path.join(pluginDir, 'fxmanifest.lua');
    try {
      await fs.access(manifestPath);
    } catch (error) {
      // Manifest doesn't exist, create it
      const manifestContent = `-- Generated manifest for ${path.basename(
        pluginDir
      )}

fx_version 'cerulean'

games { 'gta5', 'rdr3' }

author 'Baloony Gaze'

description 'Example 3'

version '0.1.0'

client_scripts {
  'client/*.js',
  'client/*.lua',
}

server_scripts {
  'server/*.ts',
  'server/*.lua',
}

shared_scripts {
  'shared/*.ts',
}

files {
  'translations/*.json',
  'translations/*.lua',
  'translations/*.ts',
}
`;

      await fs.writeFile(manifestPath, manifestContent);
      logger.debug(`Created manifest file at ${manifestPath}`);
    }

    // Create example files in each subdirectory
    for (const subdir of subdirs) {
      const subdirPath = path.join(pluginDir, subdir);

      // Create example files based on subdirectory type
      if (subdir === 'client') {
        await createExampleFiles(subdirPath, [
          { name: 'index.js', content: 'console.log("Client index");' },
          {
            name: 'index.js.map',
            content:
              '{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/plugins/example/client/index.ts"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC"}',
          },
          { name: 'index.lua', content: '-- Client index' },
          { name: 'main.lua', content: '-- Client main' },
          { name: 'other.js', content: 'console.log("Client other");' },
          {
            name: 'other.js.map',
            content:
              '{"version":3,"file":"other.js","sourceRoot":"","sources":["../../../src/plugins/example/client/other.ts"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC"}',
          },
        ]);
      } else if (subdir === 'server') {
        await createExampleFiles(subdirPath, [
          { name: 'index.js', content: 'console.log("Server index");' },
          {
            name: 'index.js.map',
            content:
              '{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/plugins/example/server/index.ts"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC"}',
          },
          { name: 'index.lua', content: '-- Server index' },
          { name: 'main.lua', content: '-- Server main' },
        ]);
      } else if (subdir === 'shared') {
        await createExampleFiles(subdirPath, [
          { name: 'index.js', content: 'console.log("Shared index");' },
          {
            name: 'index.js.map',
            content:
              '{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/plugins/example/shared/index.ts"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC"}',
          },
          { name: 'main.lua', content: '-- Shared main' },
        ]);
      } else if (subdir === 'translations') {
        await createExampleFiles(subdirPath, [
          { name: 'index.js', content: 'console.log("Translation index");' },
          {
            name: 'index.js.map',
            content:
              '{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/plugins/example/translations/index.ts"],"names":[],"mappings":"AAAA,OAAO,CAAC,GAAG,CAAC,oBAAoB,CAAC,CAAC"}',
          },
          { name: 'main.lua', content: '-- Translation main' },
        ]);
      }
    }

    logger.debug(`Nested plugin ${pluginDir} fixed successfully`);
  } catch (error) {
    logger.error(`Error fixing nested plugin ${pluginDir}:`, error);
    throw error;
  }
}

/**
 * Create example files
 * @param dir Directory
 * @param files Files to create
 */
async function createExampleFiles(
  dir: string,
  files: { name: string; content: string }[]
): Promise<void> {
  for (const file of files) {
    const filePath = path.join(dir, file.name);
    try {
      await fs.access(filePath);
    } catch (error) {
      // File doesn't exist, create it
      await fs.writeFile(filePath, file.content);
    }
  }
}

/**
 * Create specific files
 * @param dir Directory
 * @param files Files to create
 * @param logger Logger
 */
async function createSpecificFiles(
  dir: string,
  files: { name: string; content: string }[],
  logger: any
): Promise<void> {
  try {
    // Create directory if it doesn't exist
    await fs.mkdir(dir, { recursive: true });

    // Create files
    for (const file of files) {
      const filePath = path.join(dir, file.name);
      try {
        await fs.access(filePath);
      } catch (error) {
        // File doesn't exist, create it
        await fs.writeFile(filePath, file.content);
        logger.debug(`Created file: ${filePath}`);
      }
    }
  } catch (error) {
    logger.error(`Error creating specific files in ${dir}:`, error);
    throw error;
  }
}


================================================================================

# .\core\build\stages\SetupWatchersStage.ts

/**
 * Setup watchers stage
 */
import 'dotenv/config'; // Load environment variables from .env file
import { BuildContext } from '../../types.js';
import {
  WatcherManager,
  DebouncedTaskManager,
  ResourceManager,
  rebuildComponent,
} from '../../../utils/fs/index.js';

/**
 * Setup watchers
 * @param context Build context
 */
export async function setupWatchersStage(context: BuildContext): Promise<void> {
  const { pluginsDir, coreDir, distDir, watch, logger, config } = context;

  // Skip if watch is disabled
  if (!watch) {
    logger.info('Skipping watcher setup (watch mode disabled)');
    return;
  }

  logger.info('Setting up watchers...');

  try {
    // Create debounced task manager
    const debouncedTaskManager = new DebouncedTaskManager();

    // Create resource manager
    const resourceManager = new ResourceManager(undefined, logger, {
      reloaderEnabled: config.reloader.enabled,
      reloaderHost: config.reloader.host,
      reloaderPort: config.reloader.port,
      reloaderApiKey: config.reloader.apiKey,
    });

    // Create watcher manager
    const watcherManager = new WatcherManager(
      debouncedTaskManager,
      resourceManager,
      logger
    );

    // Store watcher manager in context for later use
    (context as any).watcherManager = watcherManager;

    // Set up plugin watchers
    watcherManager.setupPluginWatchers(
      pluginsDir,
      distDir,
      async (
        componentType: 'plugin' | 'core' | 'webview',
        pluginDir?: string
      ) => {
        // Rebuild the component using the consolidated function
        await rebuildComponent(componentType, pluginDir, context);
      }
    );

    // Set up core watcher
    watcherManager.setupCoreWatcher(
      coreDir,
      distDir,
      async (
        componentType: 'plugin' | 'core' | 'webview',
        pluginDir?: string
      ) => {
        // Rebuild the component using the consolidated function
        await rebuildComponent(componentType, pluginDir, context);
      }
    );

    // Set up webview watcher
    watcherManager.setupWebviewWatcher(
      pluginsDir,
      distDir,
      async (
        componentType: 'plugin' | 'core' | 'webview',
        pluginDir?: string
      ) => {
        // Rebuild the component using the consolidated function
        await rebuildComponent(componentType, pluginDir, context);
      }
    );

    logger.info('Watchers set up successfully');
  } catch (error) {
    logger.error('Error setting up watchers:', error);
    throw error;
  }
}

// The rebuildComponent function has been moved to src/scripts/utils/fs/RebuildUtils.ts


================================================================================

# .\core\plugins\PluginManager.ts

/**
 * Plugin manager
 */
import * as path from 'path';
import { Plugin, PluginFile, FileSystem, Logger } from '../types.js';
import { FileSystemImpl } from '../../utils/fs/FileSystemImpl.js';

/**
 * Plugin manager
 */
export class PluginManager {
  private fs: FileSystem;
  private logger: Logger;

  /**
   * Create a new plugin manager
   * @param fs File system
   * @param logger Logger
   */
  constructor(fs: FileSystem = new FileSystemImpl(), logger: Logger) {
    this.fs = fs;
    this.logger = logger;
  }

  /**
   * Get plugin paths
   * @param pluginsDir Plugins directory
   * @returns Plugin paths
   */
  async getPluginPaths(pluginsDir: string): Promise<{ pluginPaths: string[] }> {
    this.logger.debug(`Getting plugin paths from ${pluginsDir}`);

    try {
      // Ensure the plugins directory exists
      await this.fs.ensureDir(pluginsDir);

      // Use Node.js fs module directly for readdir
      const fs = await import('fs');

      // Get all plugin paths recursively
      const allPluginPaths: string[] = [];

      // Helper function to scan directories recursively
      const scanDirectory = async (dir: string, isRoot = false) => {
        // Check if the directory itself has a plugin.json file
        const hasPluginJson = await this.fs.exists(
          path.join(dir, 'plugin.json')
        );

        if (hasPluginJson) {
          // This is a plugin directory
          allPluginPaths.push(dir);
          // Continue scanning subdirectories in case there are nested plugins
        }

        const entries = await fs.promises.readdir(dir, { withFileTypes: true });

        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);

          if (entry.isDirectory()) {
            // Check if this directory has a plugin.json file
            const hasPluginJson = await this.fs.exists(
              path.join(fullPath, 'plugin.json')
            );

            if (hasPluginJson) {
              // This is a plugin directory
              allPluginPaths.push(fullPath);
            } else if (isRoot || entry.name.startsWith('[')) {
              // This is a container directory, scan it recursively
              await scanDirectory(fullPath);
            }
          }
        }
      };

      // Start scanning from the plugins directory
      await scanDirectory(pluginsDir, true);

      this.logger.debug(`Found ${allPluginPaths.length} plugin paths`);
      return { pluginPaths: allPluginPaths };
    } catch (error) {
      this.logger.error(`Error getting plugin paths: ${error}`);
      throw error;
    }
  }

  /**
   * Parse plugin paths into plugins
   * @param pluginPaths Plugin paths
   * @returns Plugins
   */
  async parsePluginPaths(pluginPaths: string[]): Promise<Plugin[]> {
    this.logger.debug(`Parsing ${pluginPaths.length} plugin paths`);

    const plugins: Plugin[] = [];

    for (const pluginPath of pluginPaths) {
      try {
        // Get plugin name from path
        const name = path.basename(pluginPath);

        // Check if the plugin has HTML content
        const hasHtml = await this.fs.exists(path.join(pluginPath, 'html'));

        // Calculate the path relative to the plugins directory
        // This is important for nested plugins
        const pluginsDir = pluginPath.includes('src\\plugins')
          ? path.join(process.cwd(), 'src', 'plugins')
          : path.join(process.cwd(), 'src', 'core');

        const pathFromPluginsDir = path.relative(pluginsDir, pluginPath);

        // Create plugin object
        const plugin: Plugin = {
          name,
          pathFromPluginsDir,
          hasHtml,
          fullPath: pluginPath,
          files: [],
        };

        // Get plugin files
        plugin.files = await this.getPluginFiles(pluginPath);

        plugins.push(plugin);
      } catch (error) {
        this.logger.error(`Error parsing plugin path ${pluginPath}: ${error}`);
        // Continue with other plugins
      }
    }

    this.logger.debug(`Parsed ${plugins.length} plugins`);
    return plugins;
  }

  /**
   * Get plugin files
   * @param pluginDir Plugin directory
   * @returns Plugin files
   */
  private async getPluginFiles(pluginDir: string): Promise<PluginFile[]> {
    this.logger.debug(`Getting files for plugin ${path.basename(pluginDir)}`);

    try {
      // Use Node.js fs module directly instead of glob for better handling of special characters
      const fs = await import('fs');
      const pluginFiles: PluginFile[] = [];

      // Helper function to scan directories recursively
      const scanDirectory = async (dir: string, relativePath: string = '') => {
        try {
          const entries = await fs.promises.readdir(dir, {
            withFileTypes: true,
          });

          for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            const entryRelativePath = path.join(relativePath, entry.name);

            if (entry.isDirectory()) {
              // Skip node_modules and dist directories
              if (entry.name !== 'node_modules' && entry.name !== 'dist') {
                await scanDirectory(fullPath, entryRelativePath);
              }
            } else {
              // This is a file
              const fileName = entry.name;
              const isPluginJsonFile = fileName === 'plugin.json';

              // Create plugin file object
              const file: PluginFile = {
                name: fileName,
                pathFromPluginDir: entryRelativePath,
                isPluginJsonFile,
                fullPath: fullPath,
              };

              pluginFiles.push(file);
            }
          }
        } catch (error) {
          this.logger.error(`Error scanning directory ${dir}: ${error}`);
        }
      };

      // Start scanning from the plugin directory
      await scanDirectory(pluginDir);

      this.logger.debug(
        `Found ${pluginFiles.length} files for plugin ${path.basename(
          pluginDir
        )}`
      );
      return pluginFiles;
    } catch (error) {
      this.logger.error(`Error getting plugin files: ${error}`);
      throw error;
    }
  }

  /**
   * Read plugin JSON
   * @param jsonPath Path to plugin.json
   * @returns Plugin JSON data
   */
  async readPluginJson(jsonPath: string): Promise<any> {
    this.logger.debug(`Reading plugin JSON from ${jsonPath}`);

    try {
      // Check if the file exists first
      if (!(await this.fs.exists(jsonPath))) {
        this.logger.warn(`Plugin.json file not found at path: ${jsonPath}`);
        return null;
      }

      const content = await this.fs.readFile(jsonPath);
      return JSON.parse(content);
    } catch (error) {
      this.logger.error(`Error reading plugin JSON: ${error}`);
      throw error;
    }
  }

  /**
   * Get plugin output info
   * @param plugin Plugin
   * @param distDir Distribution directory
   * @returns Plugin output info
   */
  getPluginOutputInfo(
    plugin: Plugin,
    distDir: string
  ): { pluginRelativePath: string; outputDir: string; manifestPath: string } {
    this.logger.debug(`Getting output info for plugin ${plugin.name}`);

    // Calculate relative path
    let pluginRelativePath = plugin.pathFromPluginsDir;

    // Special case for the core plugin
    if (plugin.name === 'core') {
      pluginRelativePath = 'core';
    }

    // Final output directory
    const outputDir = path.join(distDir, pluginRelativePath);

    return {
      pluginRelativePath,
      outputDir,
      manifestPath: path.join(outputDir, 'fxmanifest.lua'),
    };
  }
}


================================================================================

# .\core\types.ts

/**
 * Core types for the build system
 */

/**
 * Build context containing all information needed for the build
 */
export interface BuildContext {
  /** Root directory of the project */
  rootDir: string;
  /** Directory containing plugins */
  pluginsDir: string;
  /** Directory containing core plugins */
  coreDir: string;
  /** Output directory for built files */
  distDir: string;
  /** Whether to watch for changes */
  watch: boolean;
  /** Whether to enable resource reloading */
  reload: boolean;
  /** Logger instance */
  logger: Logger;
  /** Configuration */
  config: BuildConfig;
}

/**
 * Build configuration
 */
export interface BuildConfig {
  /** Environment variables */
  env: Record<string, string>;
  /** Build options */
  options: {
    /** Whether to minify output */
    minify: boolean;
    /** Whether to generate source maps */
    sourceMaps: boolean;
    /** Whether to clean the output directory before building */
    clean: boolean;
  };
  /** Paths configuration */
  paths: {
    /** Root directory of the project */
    rootDir: string;
    /** Directory containing plugins */
    pluginsDir: string;
    /** Directory containing core plugins */
    coreDir: string;
    /** Output directory for built files */
    distDir: string;
    /** Directory for webview assets */
    webviewDir: string;
  };
  /** Resource reloader configuration */
  reloader: {
    /** Whether to enable resource reloading */
    enabled: boolean;
    /** Host for resource reloading */
    host: string;
    /** Port for resource reloading */
    port: number;
    /** API key for resource reloading */
    apiKey: string;
  };
}

/**
 * Plugin information
 */
export interface Plugin {
  /** Name of the plugin */
  name: string;
  /** Path from plugins directory */
  pathFromPluginsDir: string;
  /** Whether the plugin has HTML content */
  hasHtml: boolean;
  /** Full path to the plugin directory */
  fullPath?: string;
  /** Files in the plugin */
  files: PluginFile[];
}

/**
 * File information
 */
export interface PluginFile {
  /** Name of the file */
  name: string;
  /** Path from plugin directory */
  pathFromPluginDir: string;
  /** Whether the file is plugin.json */
  isPluginJsonFile: boolean;
  /** Full path to the file */
  fullPath: string;
}

/**
 * Script patterns in plugin.json
 */
export interface ScriptPatterns {
  /** Client scripts */
  client_scripts?: string[];
  /** Server scripts */
  server_scripts?: string[];
  /** Shared scripts */
  shared_scripts?: string[];
  /** Other properties */
  [key: string]: any;
}

/**
 * Script files by category
 */
export interface ScriptFiles {
  /** Client scripts */
  client: string[];
  /** Server scripts */
  server: string[];
  /** Shared scripts */
  shared: string[];
}

/**
 * File category
 */
export enum FileCategory {
  Client = 'client',
  Server = 'server',
  Shared = 'shared',
  Other = 'other',
}

/**
 * Processed file information
 */
export interface ProcessedFile {
  /** Source path relative to plugin directory */
  sourcePath: string;
  /** Output path relative to output directory */
  outputPath: string;
  /** Category of the file */
  category: FileCategory;
}

/**
 * Logger interface
 */
export interface Logger {
  /** Log a debug message */
  debug(message: string, ...args: any[]): void;
  /** Log an info message */
  info(message: string, ...args: any[]): void;
  /** Log a warning message */
  warn(message: string, ...args: any[]): void;
  /** Log an error message */
  error(message: string, ...args: any[]): void;
}

/**
 * Command interface for CLI commands
 */
export interface Command {
  /** Name of the command */
  name: string;
  /** Description of the command */
  description: string;
  /** Execute the command */
  execute(args: string[]): Promise<void>;
}

/**
 * Bundler interface for bundling files
 */
export interface Bundler {
  /** Bundle a file */
  bundle(inputFile: string, outputFile: string, options?: any): Promise<void>;
}

/**
 * Enhanced file system interface
 */
export interface FileSystem {
  /** Read a file asynchronously */
  readFile(path: string, encoding?: string): Promise<string>;
  /** Read a file synchronously */
  readFileSync(path: string, encoding?: string): string;
  /** Write a file asynchronously */
  writeFile(path: string, content: string): Promise<void>;
  /** Write a file synchronously */
  writeFileSync(path: string, content: string): void;
  /** Copy a file */
  copyFile(source: string, destination: string): Promise<void>;
  /** Ensure a directory exists asynchronously */
  ensureDir(path: string): Promise<void>;
  /** Ensure a directory exists synchronously */
  ensureDirSync(path: string): void;
  /** Check if a file exists asynchronously */
  exists(path: string): Promise<boolean>;
  /** Check if a file exists synchronously */
  existsSync(path: string): boolean;
  /** Get files matching a pattern asynchronously */
  glob(pattern: string, options?: any): Promise<string[]>;
  /** Get files matching a pattern synchronously */
  globSync(pattern: string, options?: any): string[];
  /** Get all file paths within a directory recursively */
  getFilePaths(dirPath: string): string[];
  /** Find all paths containing a specific file */
  findPathsWithFile(dirPath: string, targetFileName: string): string[];
  /** Normalize a path for cross-platform consistency */
  normalizePath(filePath: string): string;
  /** Read directory contents asynchronously */
  readdir(dirPath: string): Promise<string[]>;
  /** Read directory contents synchronously */
  readdirSync(dirPath: string): string[];
}

/**
 * Resource manager interface
 */
export interface ResourceManager {
  /** Deploy resources to the server */
  deployResources(distDir: string): Promise<void>;
  /** Reload a resource */
  reloadResource(resourceName: string): Promise<void>;
}

/**
 * Watcher interface
 */
export interface Watcher {
  /** Start watching for changes */
  watch(paths: string[], onChange: (path: string) => void): void;
  /** Stop watching */
  stop(): void;
}

/**
 * Build pipeline interface
 */
export interface BuildPipeline {
  /** Add a stage to the pipeline */
  addStage(
    name: string,
    handler: (context: BuildContext) => Promise<void>
  ): BuildPipeline;
  /** Run the pipeline */
  run(context: BuildContext): Promise<void>;
}

/**
 * Manifest generator interface
 */
export interface ManifestGenerator {
  /** Generate a manifest */
  generate(config: any, outputPath: string): Promise<void>;
}

/**
 * Webview builder interface
 */
export interface WebviewBuilder {
  /** Build webview for a plugin */
  buildPluginWebview(plugin: Plugin, distDir: string): Promise<string>;
  /** Build webview for all plugins */
  buildWebview(plugins: Plugin[], distDir: string): Promise<string>;
}


================================================================================

# .\index.ts

#!/usr/bin/env node
/**
 * Main entry point for the build system
 */
import 'dotenv/config'; // Load environment variables from .env file
import { CLI } from './cli/CLI.js';

// Check if we're in watch mode
const isWatchMode =
  process.argv.includes('--watch') ||
  process.argv.includes('-w') ||
  process.argv.includes('dev');

// Initialize and run the CLI
const cli = new CLI();
cli
  .run(process.argv.slice(2))
  .then(() => {
    // Only exit if we're not in watch mode
    if (!isWatchMode) {
      process.exit(0);
    }
  })
  .catch((error) => {
    console.error('Error running CLI:', error);
    process.exit(1);
  });


================================================================================

# .\types\global.d.ts

/**
 * Global type declarations
 */

declare global {
  var isBuilding: boolean;
}

export {};


================================================================================

# .\utils\args.ts

/**
 * Utility functions for working with command line arguments
 */

/**
 * Command line arguments
 */
export interface CommandLineArgs {
  watch: boolean;
  reload: boolean;
}

/**
 * Parse command line arguments
 */
export function parseArgs(): CommandLineArgs {
  const args = process.argv.slice(2);
  return {
    watch: args.includes('--watch') || args.includes('-w'),
    reload: args.includes('--reload') || args.includes('-r'),
  };
}


================================================================================

# .\utils\builder.ts

/**
 * Build-related functions
 */
import * as path from 'path';
import * as fs from 'fs';
import { Plugin } from '../core/types.js';
import {
  fileSystem,
  categorizeFiles as categorizeGeneratedFiles,
  getPluginOutputInfo,
  getPluginScripts,
  findPluginPaths,
  parsePluginFiles as parseFilePathsIntoFiles,
  parsePluginPaths as parsePluginPathsIntoPlugins,
  processFile,
  readPluginJson,
  ResourceManager,
} from './fs/index.js';
import {
  generateManifest,
  preparePluginManifestData,
} from './fs/ConfigUtils.js';
import { verifyOutputDir } from './bundler.js';
import { buildPluginWebview } from './webview.js';
import { ConsoleLogger } from './logger/ConsoleLogger.js';
import { getProjectPaths } from './fs/PathUtils.js';

/**
 * Plugin build result
 */
export interface PluginBuildResult {
  updatedPluginJson: Record<string, any>;
  manifestPath: string;
}

/**
 * Check if a plugin has HTML content (Page.tsx)
 * @param plugin The plugin to check
 * @returns Promise<boolean> True if the plugin has HTML content
 */
export async function checkForHtmlContent(plugin: Plugin): Promise<boolean> {
  if (!plugin.fullPath) return false;

  const htmlDir = path.join(plugin.fullPath, 'html');
  const pageTsxPath = path.join(htmlDir, 'Page.tsx');

  try {
    await fs.promises.access(htmlDir);
    try {
      await fs.promises.access(pageTsxPath);
      return true;
    } catch {
      // Page.tsx doesn't exist
      return false;
    }
  } catch {
    // html directory doesn't exist
    return false;
  }
}

/**
 * Build a single plugin
 */
export async function buildPlugin(
  plugin: Plugin,
  distDir: string
): Promise<PluginBuildResult | undefined> {
  if (!plugin.fullPath) {
    console.log(`Skipping plugin with no path: ${plugin.name || 'unknown'}`);
    return;
  }

  console.log(`Building plugin: ${plugin.name}`);

  try {
    // Get plugin output info
    const { outputDir, manifestPath } = getPluginOutputInfo(plugin, distDir);

    // Ensure output directory exists
    await fileSystem.ensureDir(outputDir);

    // Read plugin.json
    const jsonPath = path.join(plugin.fullPath, 'plugin.json');

    const pluginJsonData = readPluginJson(jsonPath);

    // If plugin.json is not found, skip this plugin
    if (pluginJsonData === null) {
      console.warn(
        `Plugin ${plugin.name} does not have a plugin.json file, skipping`
      );
      return undefined;
    }

    // Get the files for this plugin
    const pluginFiles = parseFilePathsIntoFiles(plugin.fullPath);
    plugin.files = plugin.files || [];
    plugin.files.push(...pluginFiles);

    // Check if plugin has HTML content to build webview
    // This should be determined by checking if there's a 'html' directory with a Page.tsx file
    plugin.hasHtml = plugin.hasHtml || (await checkForHtmlContent(plugin));

    // Build the webview first if the plugin has HTML content
    // This way, we can include the webview assets in the manifest
    if (plugin.hasHtml && plugin.fullPath) {
      try {
        const webviewResult = await buildPluginWebview(plugin, distDir);

        if (webviewResult.success) {
          console.log(
            `Webview built successfully at: ${webviewResult.htmlDir}`
          );

          // Check if the html directory exists and contains files
          const htmlDir = path.join(outputDir, 'html');
          if (fs.existsSync(htmlDir)) {
            // Add html/**/* to the files array in the plugin.json data
            if (!pluginJsonData.files) {
              pluginJsonData.files = ['html/**/*'];
            } else if (!pluginJsonData.files.includes('html/**/*')) {
              pluginJsonData.files.push('html/**/*');
            }

            // Set the ui_page in the plugin.json data
            pluginJsonData.ui_page = 'html/index.html';

            // Log detailed information about what's being included in the manifest
            console.log(
              `Including webview assets in plugin.json for ${plugin.name}:`
            );
            console.log(`  - Added 'html/**/*' to files array`);
            console.log(`  - Set ui_page to 'html/index.html'`);
          } else {
            console.warn(
              `Webview build for plugin ${plugin.name} succeeded but html directory not found at ${htmlDir}.`
            );
            console.warn(`Not including webview assets in manifest.`);
          }
        } else {
          console.warn(
            `Webview build for plugin ${plugin.name} did not produce expected files.`
          );
          console.warn(`Not including webview assets in manifest.`);
        }
      } catch (error) {
        console.error(
          `Error building webview for plugin ${plugin.name}:`,
          error
        );
        // Continue with the build even if webview fails
      }
    }

    // Get script files based on patterns in plugin.json
    const scriptFiles = getPluginScripts(pluginJsonData, plugin.fullPath);

    // Process all files
    const processPromises = plugin.files.map((file) =>
      processFile(file, outputDir)
    );
    const processedFiles = await Promise.all(processPromises);

    // Categorize generated files
    const generatedFiles = categorizeGeneratedFiles(processedFiles);

    // Prepare manifest data
    const updatedPluginJson = preparePluginManifestData(
      pluginJsonData,
      generatedFiles,
      scriptFiles
    );

    // Verify the output directory content
    await verifyOutputDir(outputDir);

    return { updatedPluginJson, manifestPath };
  } catch (error) {
    console.error(`Error building plugin ${plugin.name}:`, error);
    return undefined;
  }
}

/**
 * Build plugins and generate manifests
 */
export async function buildAndGenerateManifests(
  plugins: Plugin[],
  distDir: string
) {
  for (const plugin of plugins) {
    const result = await buildPlugin(plugin, distDir);
    if (!result) continue;
    const { updatedPluginJson, manifestPath } = result;

    // Generate manifest with the updated plugin JSON data
    generateManifest(updatedPluginJson, manifestPath);
  }
}

/**
 * Main build function to build all plugins and resources
 */
export async function build() {
  const { pluginsDir, coreDir, distDir } = getProjectPaths();

  try {
    await fileSystem.ensureDir(distDir);
    await fileSystem.ensureDir(coreDir);

    const pluginPaths = findPluginPaths(pluginsDir);
    const corePluginPaths = findPluginPaths(coreDir);

    const plugins = parsePluginPathsIntoPlugins(pluginPaths);
    const corePlugins = parsePluginPathsIntoPlugins(corePluginPaths);

    console.log(
      `Found ${plugins.length} plugins and ${corePlugins.length} core plugins`
    );

    // Build order:
    // 1. Build core plugins first
    console.log('Building core plugins...');
    await buildAndGenerateManifests(corePlugins, distDir);

    // 2. Build regular plugins
    console.log('Building regular plugins...');
    await buildAndGenerateManifests(plugins, distDir);

    // 3. Generate webview manifest if needed
    const webviewDir = path.join(distDir, 'webview');
    if (fs.existsSync(webviewDir)) {
      console.log('Generating webview manifest...');
      generateManifest(
        {
          name: 'webview',
          version: '0.1.0',
          fx_version: 'cerulean',
          author: 'Baloony Gaze',
          games: ['gta5', 'rdr3'],
          description: 'Shared webview assets',
          files: ['index.html', 'assets/**/*'],
        },
        path.join(webviewDir, 'fxmanifest.lua')
      );
    }

    console.log('Build completed successfully!');

    // 4. Deploy built resources
    const logger = new ConsoleLogger();
    const resourceManager = new ResourceManager(fileSystem, logger, {
      reloaderEnabled: process.env.RELOADER_ENABLED === 'true',
      reloaderHost: process.env.RELOADER_HOST || 'localhost',
      reloaderPort: parseInt(process.env.RELOADER_PORT || '3414', 10),
      reloaderApiKey: process.env.RELOADER_API_KEY || 'your-secure-api-key',
    });
    await resourceManager.deployResources(distDir);

    return { plugins, corePlugins };
  } catch (error) {
    console.error('Build failed:', error);
    throw error;
  }
}

// The rebuildComponent function has been moved to src/scripts/utils/fs/RebuildUtils.ts


================================================================================

# .\utils\bundler.ts

import * as path from 'path';
import * as esbuild from 'esbuild';
import * as fsPromises from 'fs/promises';

/**
 * Bundle TypeScript file to ES2017 JS with all imports inlined
 */
export async function bundleTypeScript(
  inputFile: string,
  outputFile: string,
  isReact = false
): Promise<void> {
  try {
    const loader: Record<string, esbuild.Loader> = isReact
      ? { '.tsx': 'tsx', '.ts': 'ts', '.js': 'js' }
      : { '.ts': 'ts', '.js': 'js' };

    // Determine if this is a server-side script by checking the path
    const isServerScript =
      inputFile.includes('/server/') || inputFile.includes('\\server\\');

    // List of packages to not inline - for server scripts, make Node.js modules external
    const externalPackages: string[] = isServerScript
      ? [
          'http',
          'https',
          'url',
          'fs',
          'path',
          'os',
          'crypto',
          'buffer',
          'stream',
          'util',
          'events',
          'zlib',
          'net',
          'tls',
          'dns',
          'child_process',
        ]
      : [];

    const result = await esbuild.build({
      entryPoints: [inputFile],
      bundle: true,
      outfile: outputFile,
      format: 'iife', // Use IIFE format for FiveM compatibility
      target: 'es2017',
      minify: false,
      sourcemap: 'external',
      loader: loader,
      jsx: isReact ? 'transform' : undefined,
      logLevel: 'info',
      external: externalPackages,
      // Use node platform for server scripts, browser platform for client scripts
      platform: isServerScript ? 'node' : 'browser',
    });

    if (result.errors.length > 0) {
      console.error(`Errors bundling ${inputFile}:`, result.errors);
    } else {
      // Verify the file was created
      const exists = await fsPromises
        .access(outputFile)
        .then(() => true)
        .catch(() => false);

      if (!exists) {
        console.error(
          `Failed to verify file exists after bundling: ${outputFile}`
        );
      }
    }
  } catch (err) {
    console.error(`Failed to bundle TypeScript file ${inputFile}:`, err);
    throw err;
  }
}

/**
 * Bundle JavaScript file with all imports inlined
 */
export async function bundleJavaScript(
  inputFile: string,
  outputFile: string
): Promise<void> {
  try {
    // Determine if this is a server-side script by checking the path
    const isServerScript =
      inputFile.includes('/server/') || inputFile.includes('\\server\\');

    // List of packages to not inline - for server scripts, make Node.js modules external
    const externalPackages: string[] = isServerScript
      ? [
          'http',
          'https',
          'url',
          'fs',
          'path',
          'os',
          'crypto',
          'buffer',
          'stream',
          'util',
          'events',
          'zlib',
          'net',
          'tls',
          'dns',
          'child_process',
        ]
      : [];

    const result = await esbuild.build({
      entryPoints: [inputFile],
      bundle: true,
      outfile: outputFile,
      format: 'iife', // Use IIFE format for FiveM compatibility
      target: 'es2017',
      minify: false,
      sourcemap: 'external',
      external: externalPackages,
      // Use node platform for server scripts, browser platform for client scripts
      platform: isServerScript ? 'node' : 'browser',
    });

    if (result.errors.length > 0) {
      console.error(`Errors bundling ${inputFile}:`, result.errors);
    } else {
      // Verify the file was created
      const exists = await fsPromises
        .access(outputFile)
        .then(() => true)
        .catch(() => false);

      if (!exists) {
        console.error(
          `Failed to verify file exists after bundling: ${outputFile}`
        );
      }
    }
  } catch (err) {
    console.error(`Failed to bundle JavaScript file ${inputFile}:`, err);
    throw err;
  }
}

/**
 * Copy Lua file to output directory
 */
export async function copyLuaFile(
  inputFile: string,
  outputFile: string
): Promise<void> {
  try {
    await fsPromises.copyFile(inputFile, outputFile);
    // Verify the file was created
    const exists = await fsPromises
      .access(outputFile)
      .then(() => true)
      .catch(() => false);

    if (!exists) {
      console.error(`Failed to verify file exists after copy: ${outputFile}`);
    }
  } catch (err) {
    console.error(
      `Error copying Lua file from ${inputFile} to ${outputFile}:`,
      err
    );
    throw err;
  }
}

/**
 * Helper function to verify files in the output directory
 */
export async function verifyOutputDir(dir: string): Promise<void> {
  try {
    // Check if directory exists
    const stats = await fsPromises.stat(dir);
    if (!stats.isDirectory()) {
      console.error(`Path exists but is not a directory: ${dir}`);
      return;
    }

    // List all files in the directory
    const files = await fsPromises.readdir(dir, { withFileTypes: true });

    if (files.length === 0) {
      console.log(`Directory is empty: ${dir}`);
      return;
    }

    // Process each entry
    for (const file of files) {
      const fullPath = path.join(dir, file.name);

      if (file.isDirectory()) {
        console.log(`  [DIR] ${file.name}`);
      } else {
        // Get file size
        const fileStats = await fsPromises.stat(fullPath);
        console.log(`  [FILE] ${file.name} (${fileStats.size} bytes)`);
      }
    }
  } catch (err) {
    console.error(`Error verifying directory ${dir}:`, err);
  }

  console.log(`--- End verification of ${dir} ---\n`);
}


================================================================================

# .\utils\env.ts

/**
 * Utility functions for working with environment variables
 */

/**
 * Configure environment for resource reloading
 */
export function configureEnvironment(reload: boolean): void {
  if (reload) {
    process.env.RELOADER_ENABLED = 'true';
    process.env.RELOADER_HOST = process.env.RELOADER_HOST || 'localhost';
    process.env.RELOADER_PORT = process.env.RELOADER_PORT || '3414';
    process.env.RELOADER_API_KEY =
      process.env.RELOADER_API_KEY || 'your-secure-api-key';
  } else {
    process.env.RELOADER_ENABLED = 'false';
  }
}


================================================================================

# .\utils\fs\ConfigUtils.ts

/**
 * Configuration utility functions for working with configuration files
 */
import * as path from 'path';
import { fileSystem } from './index.js';
import { getProjectPaths } from './PathUtils.js';

/**
 * Load environment variables from .env file
 * @param envPath Path to the .env file
 * @returns Object containing environment variables
 */
export async function loadEnvFile(
  envPath: string
): Promise<Record<string, string>> {
  const env: Record<string, string> = {};

  try {
    if (await fileSystem.exists(envPath)) {
      const content = await fileSystem.readFile(envPath, 'utf8');
      const lines = content.split('\n');

      for (const line of lines) {
        // Skip comments and empty lines
        if (line.trim().startsWith('#') || !line.trim()) {
          continue;
        }

        // Parse KEY=VALUE format
        const match = line.match(/^\s*([\w.-]+)\s*=\s*(.*)?\s*$/);
        if (match) {
          const key = match[1];
          let value = match[2] || '';

          // Remove quotes if present
          if (value.startsWith('"') && value.endsWith('"')) {
            value = value.substring(1, value.length - 1);
          } else if (value.startsWith("'") && value.endsWith("'")) {
            value = value.substring(1, value.length - 1);
          }

          env[key] = value;
        }
      }
    }
  } catch (error) {
    console.error(`Error loading .env file from ${envPath}:`, error);
  }

  return env;
}

/**
 * Get configuration from environment variables
 * @returns Configuration object
 */
export function getConfig(): Record<string, any> {
  return {
    // Default configuration values
    debounceTime: process.env.DEBOUNCE_TIME
      ? parseInt(process.env.DEBOUNCE_TIME)
      : 1000,
    distDir:
      process.env.DIST_DIR || path.join(getProjectPaths().rootDir, 'dist'),
    pluginsDir: process.env.PLUGINS_DIR || getProjectPaths().pluginsDir,
    coreDir: process.env.CORE_DIR || getProjectPaths().coreDir,
    webviewDir: process.env.WEBVIEW_DIR || getProjectPaths().webviewDir,
    // Add more configuration values as needed
  };
}

/**
 * Normalizes file paths to use forward slashes regardless of OS
 * @param value The path or array of paths to normalize
 */
function normalizePaths(value: any): any {
  if (typeof value === 'string') {
    return value.replace(/\\/g, '/');
  } else if (Array.isArray(value)) {
    return value.map((item) => {
      if (typeof item === 'string') {
        return item.replace(/\\/g, '/');
      }
      return item;
    });
  }
  return value;
}

/**
 * Generates an fxmanifest.lua file from plugin configuration
 * @param pluginJson Parsed plugin.json data or path to plugin.json file
 * @param outputPath Path where the manifest should be written
 */
export async function generateManifest(
  pluginJson: any | string,
  outputPath: string
): Promise<void> {
  try {
    // Handle both direct data and file paths
    let config: any;

    if (typeof pluginJson === 'string') {
      // If a string is provided, assume it's a file path
      try {
        const fileContent = await fileSystem.readFile(pluginJson, 'utf8');
        config = JSON.parse(fileContent);
      } catch (error) {
        throw new Error(
          `Failed to read or parse plugin.json at ${pluginJson}: ${error}`
        );
      }
    } else {
      // Otherwise use the object directly
      config = pluginJson;
    }

    if (!config) {
      throw new Error('No valid plugin configuration data provided');
    }

    // Normalize paths in script arrays and other fields that might contain file paths
    config = {
      ...config,
      client_scripts: normalizePaths(config.client_scripts),
      server_scripts: normalizePaths(config.server_scripts),
      shared_scripts: normalizePaths(config.shared_scripts),
      files: normalizePaths(config.files),
      ui_page: normalizePaths(config.ui_page),
    };

    // Map of JSON schema properties to fxmanifest.lua format
    const schemaToManifestMap: Record<
      string,
      string | ((value: any) => string)
    > = {
      // Basic metadata
      'fx_version': (value) => `fx_version '${value}'`,
      'games': (value) => `games { '${value.join("', '")}' }`,
      'author': (value) => `author '${value}'`,
      'description': (value) => `description '${value}'`,
      'version': (value) => `version '${value}'`,

      // Scripts
      'client_scripts': (value) => {
        let result = `client_scripts {\n`;
        value.forEach((script: string) => {
          // Ensure forward slashes
          const normalizedScript = script.replace(/\\/g, '/');
          result += `    '${normalizedScript}',\n`;
        });
        result += `}`;
        return result;
      },
      'server_scripts': (value) => {
        let result = `server_scripts {\n`;
        value.forEach((script: string) => {
          // Ensure forward slashes
          const normalizedScript = script.replace(/\\/g, '/');
          result += `    '${normalizedScript}',\n`;
        });
        result += `}`;
        return result;
      },
      'shared_scripts': (value) => {
        let result = `shared_scripts {\n`;
        value.forEach((script: string) => {
          // Ensure forward slashes
          const normalizedScript = script.replace(/\\/g, '/');
          result += `    '${normalizedScript}',\n`;
        });
        result += `}`;
        return result;
      },

      // Exports
      'exports': (value) => {
        let result = '';
        value.forEach((item: string) => {
          result += `export '${item}'\n`;
        });
        return result.trim();
      },
      'server_exports': (value) => {
        let result = '';
        value.forEach((item: string) => {
          result += `server_export '${item}'\n`;
        });
        return result.trim();
      },

      // UI
      'ui_page': (value) => `ui_page '${value.replace(/\\/g, '/')}'`,

      // Files
      'files': (value) => {
        let result = `files {\n`;
        value.forEach((file: string) => {
          // Ensure forward slashes
          const normalizedFile = file.replace(/\\/g, '/');
          result += `    '${normalizedFile}',\n`;
        });
        result += `}`;
        return result;
      },

      // Flags
      'is_map': (value) => (value ? `this_is_a_map 'yes'` : ''),
      'server_only': (value) => (value ? `server_only 'yes'` : ''),
      'lua54': (value) => (value ? `lua54 'yes'` : ''),

      // Other
      'provide': (value) => `provide '${value}'`,
    };

    // Start building the manifest content
    let content = `-- Generated manifest for ${
      config.name || 'unnamed plugin'
    }\n\n`;

    // Process basic properties using the mapping
    for (const [key, formatter] of Object.entries(schemaToManifestMap)) {
      if (config[key] !== undefined && config[key] !== null) {
        const formattedValue =
          typeof formatter === 'function'
            ? formatter(config[key])
            : formatter.replace('{value}', config[key]);

        if (formattedValue) {
          content += formattedValue + '\n\n';
        }
      }
    }

    // Handle complex properties that need special formatting

    // Level meta
    if (config.level_meta) {
      if (config.level_meta.before) {
        content += `before_level_meta '${config.level_meta.before}'\n`;
      }
      if (config.level_meta.after) {
        content += `after_level_meta '${config.level_meta.after}'\n`;
      }
      if (config.level_meta.replace) {
        content += `replace_level_meta '${config.level_meta.replace}'\n`;
      }
      content += '\n';
    }

    // Data files
    if (
      config.data_files &&
      Array.isArray(config.data_files) &&
      config.data_files.length > 0
    ) {
      config.data_files.forEach((item: { type: string; path: string }) => {
        // Normalize path
        const normalizedPath = item.path.replace(/\\/g, '/');
        content += `data_file '${item.type}' '${normalizedPath}'\n`;
      });
      content += '\n';
    }

    // Loadscreen
    if (config.loadscreen) {
      if (config.loadscreen.page) {
        // Normalize path
        const normalizedPage = config.loadscreen.page.replace(/\\/g, '/');
        content += `loadscreen '${normalizedPage}'\n`;
      }
      if (config.loadscreen.manual_shutdown) {
        content += `loadscreen_manual_shutdown 'yes'\n`;
      }
      content += '\n';
    }

    // Dependencies
    if (
      config.dependencies &&
      Array.isArray(config.dependencies) &&
      config.dependencies.length > 0
    ) {
      config.dependencies.forEach((dep: any) => {
        if (typeof dep === 'string') {
          content += `dependency '${dep}'\n`;
        } else if (typeof dep === 'object' && dep.resource) {
          content += `dependency '${dep.resource}'${
            dep.server ? ` /server:${dep.server}` : ''
          }\n`;
        }
      });
      content += '\n';
    }

    // Experimental features
    if (config.experimental) {
      if (config.experimental.use_fxv2_oal) {
        content += `use_experimental_fxv2_oal 'yes'\n`;
      }
      if (config.experimental.clr_disable_task_scheduler) {
        content += `clr_disable_task_scheduler 'yes'\n`;
      }
      content += '\n';
    }

    // Convars
    if (config.convars) {
      Object.entries(config.convars).forEach(([key, value]: [string, any]) => {
        content += `convar_category '${value.category || key}' {\n`;
        if (value.variables && Array.isArray(value.variables)) {
          value.variables.forEach((variable: any) => {
            content += `    {\n`;
            content += `        name = '${variable.name}',\n`;
            content += `        type = '${variable.type}',\n`;

            // Format default value based on its type
            if (typeof variable.default === 'string') {
              content += `        default = '${variable.default}'\n`;
            } else if (
              typeof variable.default === 'number' ||
              typeof variable.default === 'boolean'
            ) {
              content += `        default = ${variable.default}\n`;
            } else {
              content += `        default = '${JSON.stringify(
                variable.default
              )}'\n`;
            }

            content += `    },\n`;
          });
        }
        content += `}\n\n`;
      });
    }

    // Custom data
    if (config.custom_data) {
      Object.entries(config.custom_data).forEach(
        ([key, value]: [string, any]) => {
          if (typeof value === 'string') {
            content += `${key} '${value}'\n`;
          } else if (typeof value === 'object') {
            const firstKey = Object.keys(value)[0];
            content += `${key} '${firstKey}' {\n`;

            const subObject = value[firstKey];
            if (typeof subObject === 'object') {
              Object.entries(subObject).forEach(
                ([subKey, subValue]: [string, any]) => {
                  content += `    ${subKey} = ${
                    typeof subValue === 'string' ? `'${subValue}'` : subValue
                  }\n`;
                }
              );
            }

            content += `}\n`;
          }
        }
      );
    }

    // Create parent directory if it doesn't exist
    const outputDir = path.dirname(outputPath);
    await fileSystem.ensureDir(outputDir);

    // Write the manifest file
    await fileSystem.writeFile(outputPath, content);
    console.log(`Successfully wrote manifest to ${outputPath}`);
  } catch (error) {
    console.error(`Error writing manifest to ${outputPath}:`, error);
  }
}

/**
 * Prepare updated plugin JSON for manifest generation
 * Replaces all .ts extensions with .js in all script references
 */
export function preparePluginManifestData(
  pluginJsonData: any,
  generatedFiles: any,
  scriptFiles: any
) {
  // If pluginJsonData is null, create a default minimal configuration
  if (pluginJsonData === null) {
    console.warn(
      'No plugin JSON data provided, creating default configuration'
    );
    pluginJsonData = {
      name: 'unknown',
      version: '0.1.0',
      fx_version: 'cerulean',
      games: ['gta5', 'rdr3'],
      description: 'Auto-generated plugin configuration',
    };
  }

  console.log(
    'Preparing plugin manifest data...',
    JSON.stringify(pluginJsonData, null, 2)
  );

  // Helper function to replace .ts with .js in file paths
  const replaceExtension = (files: string[]): string[] => {
    if (!files) return [];

    return files.map((file) => {
      // Handle wildcard patterns like 'server/*.ts'
      if (file.includes('*.ts')) {
        return file.replace('*.ts', '*.js');
      }
      // Handle regular file paths
      return file.replace(/\.ts$/, '.js');
    });
  };

  // Replace extensions in generated files
  const processedGeneratedFiles = {
    client: replaceExtension(generatedFiles.client),
    server: replaceExtension(generatedFiles.server),
    shared: replaceExtension(generatedFiles.shared),
  };

  // Replace extensions in script files
  const processedScriptFiles = {
    client: replaceExtension(scriptFiles.client),
    server: replaceExtension(scriptFiles.server),
    shared: replaceExtension(scriptFiles.shared),
  };

  // Replace extensions in original plugin data if needed
  const originalClientScripts = Array.isArray(pluginJsonData.client_scripts)
    ? replaceExtension(pluginJsonData.client_scripts)
    : pluginJsonData.client_scripts;

  const originalServerScripts = Array.isArray(pluginJsonData.server_scripts)
    ? replaceExtension(pluginJsonData.server_scripts)
    : pluginJsonData.server_scripts;

  const originalSharedScripts = Array.isArray(pluginJsonData.shared_scripts)
    ? replaceExtension(pluginJsonData.shared_scripts)
    : pluginJsonData.shared_scripts;

  // Process the 'files' array if it exists
  const processedFiles = Array.isArray(pluginJsonData.files)
    ? replaceExtension(pluginJsonData.files)
    : pluginJsonData.files;

  return {
    ...pluginJsonData,
    // Store the resolved patterns for reference with .ts replaced by .js
    _resolvedClientScripts: processedScriptFiles.client,
    _resolvedServerScripts: processedScriptFiles.server,
    _resolvedSharedScripts: processedScriptFiles.shared,
    // Use generated files if available, otherwise use original patterns
    client_scripts:
      processedGeneratedFiles.client.length > 0
        ? processedGeneratedFiles.client
        : originalClientScripts,
    server_scripts:
      processedGeneratedFiles.server.length > 0
        ? processedGeneratedFiles.server
        : originalServerScripts,
    shared_scripts:
      processedGeneratedFiles.shared.length > 0
        ? processedGeneratedFiles.shared
        : originalSharedScripts,
    // Update files array with .ts replaced by .js
    files: processedFiles,
  };
}

/**
 * Generate a simple manifest file for a resource
 * @param resourceName Name of the resource
 * @param files Object containing categorized files
 * @param outputPath Path to write the manifest file
 */
export async function generateSimpleManifest(
  resourceName: string,
  files: {
    client: string[];
    server: string[];
    shared: string[];
    translations?: string[];
    [key: string]: string[] | undefined;
  },
  outputPath: string
): Promise<void> {
  // Start with the basic manifest content
  let manifestContent = `fx_version 'cerulean'
game 'gta5'

name '${resourceName}'
description '${resourceName} resource'
author 'Generated'
version '1.0.0'

`;

  // Add files by category
  if (files.client && files.client.length > 0) {
    manifestContent += 'client_scripts {\n';
    files.client.forEach((file) => {
      manifestContent += `  '${file}',\n`;
    });
    manifestContent += '}\n\n';
  }

  if (files.server && files.server.length > 0) {
    manifestContent += 'server_scripts {\n';
    files.server.forEach((file) => {
      manifestContent += `  '${file}',\n`;
    });
    manifestContent += '}\n\n';
  }

  if (files.shared && files.shared.length > 0) {
    manifestContent += 'shared_scripts {\n';
    files.shared.forEach((file) => {
      manifestContent += `  '${file}',\n`;
    });
    manifestContent += '}\n\n';
  }

  // Add translations if available
  if (files.translations && files.translations.length > 0) {
    manifestContent += 'files {\n';
    files.translations.forEach((file) => {
      manifestContent += `  '${file}',\n`;
    });
    manifestContent += '}\n\n';
  }

  // Add ui_page if html/index.html exists
  const htmlPath = path.join(path.dirname(outputPath), 'html', 'index.html');
  if (await fileSystem.exists(htmlPath)) {
    manifestContent += "ui_page 'html/index.html'\n\n";

    // Add html files to the files section if not already added
    if (
      !files.translations ||
      !files.translations.some((f) => f.startsWith('html/'))
    ) {
      manifestContent += 'files {\n';
      manifestContent += "  'html/index.html',\n";
      manifestContent += "  'html/**/*',\n";
      manifestContent += '}\n\n';
    }
  }

  // Write the manifest file
  await fileSystem.writeFile(outputPath, manifestContent);
  console.log(`Generated manifest file at: ${outputPath}`);
}

/**
 * Parse a manifest file
 * @param manifestPath Path to the manifest file
 * @returns Parsed manifest data
 */
export async function parseManifest(
  manifestPath: string
): Promise<Record<string, any>> {
  const result: Record<string, any> = {
    client_scripts: [],
    server_scripts: [],
    shared_scripts: [],
    files: [],
  };

  try {
    if (await fileSystem.exists(manifestPath)) {
      const content = await fileSystem.readFile(manifestPath, 'utf8');
      const lines = content.split('\n');

      let currentSection: string | null = null;

      for (const line of lines) {
        const trimmedLine = line.trim();

        // Skip comments and empty lines
        if (trimmedLine.startsWith('--') || !trimmedLine) {
          continue;
        }

        // Check for section start
        if (trimmedLine.endsWith('{')) {
          currentSection = trimmedLine.replace('{', '').trim();
          continue;
        }

        // Check for section end
        if (trimmedLine === '}') {
          currentSection = null;
          continue;
        }

        // Handle key-value pairs
        if (currentSection === null) {
          const match = trimmedLine.match(/^([a-zA-Z_]+)\s+['"](.+)['"]$/);
          if (match) {
            const key = match[1];
            const value = match[2];
            result[key] = value;
          }
        } else {
          // Handle array items
          if (trimmedLine.includes("'") || trimmedLine.includes('"')) {
            // Extract the value between quotes
            const match = trimmedLine.match(/['"](.+?)['"]/);
            if (match && match[1]) {
              if (!result[currentSection]) {
                result[currentSection] = [];
              }
              result[currentSection].push(match[1]);
            }
          }
        }
      }
    }
  } catch (error) {
    console.error(`Error parsing manifest file from ${manifestPath}:`, error);
  }

  return result;
}


================================================================================

# .\utils\fs\DebouncedTaskManager.ts

/**
 * Debounced task manager
 * Manages debounced execution of tasks to prevent rapid repeated executions
 */
import lodashDebounce from 'lodash.debounce';
import 'dotenv/config'; // Load environment variables

// Default debounce times
const DEFAULT_DEBOUNCE_TIME = 1000; // 1 second
const DEFAULT_RESOURCE_DEBOUNCE_TIME = 3000; // 3 seconds
const DEFAULT_WEBVIEW_DEBOUNCE_TIME = 1500; // 1.5 seconds

/**
 * Debounced task manager
 * Manages debounced execution of tasks to prevent rapid repeated executions
 */
export class DebouncedTaskManager {
  private tasks: Map<string, () => Promise<void>>;
  private debounceTime: number;
  private resourceDebounceTime: number;
  private webviewDebounceTime: number;

  /**
   * Create a new debounced task manager
   * @param debounceTime Default debounce time in milliseconds
   * @param resourceDebounceTime Debounce time for resource operations
   * @param webviewDebounceTime Debounce time for webview operations
   */
  constructor(
    debounceTime = parseInt(
      process.env.DEBOUNCE_TIME || DEFAULT_DEBOUNCE_TIME.toString(),
      10
    ),
    resourceDebounceTime = parseInt(
      process.env.RESOURCE_DEBOUNCE_TIME ||
        DEFAULT_RESOURCE_DEBOUNCE_TIME.toString(),
      10
    ),
    webviewDebounceTime = parseInt(
      process.env.WEBVIEW_DEBOUNCE_TIME ||
        DEFAULT_WEBVIEW_DEBOUNCE_TIME.toString(),
      10
    )
  ) {
    this.tasks = new Map();
    this.debounceTime = debounceTime;
    this.resourceDebounceTime = resourceDebounceTime;
    this.webviewDebounceTime = webviewDebounceTime;
  }

  /**
   * Get the appropriate debounce time based on the task key
   * @param key Task key
   * @param customDebounceTime Optional custom debounce time
   * @returns Debounce time in milliseconds
   */
  private getDebounceTime(key: string, customDebounceTime?: number): number {
    if (customDebounceTime !== undefined) {
      return customDebounceTime;
    }

    if (key.startsWith('generated-resource-')) {
      return this.resourceDebounceTime;
    }

    if (key.startsWith('webview-')) {
      return this.webviewDebounceTime;
    }

    return this.debounceTime;
  }

  /**
   * Execute a task with debouncing
   * @param key Task key
   * @param task Task to execute
   * @param customDebounceTime Optional custom debounce time for this specific task
   */
  execute(
    key: string,
    task: () => Promise<void> | void,
    customDebounceTime?: number
  ): void {
    // Get the appropriate debounce time for this task
    const debounceTime = this.getDebounceTime(key, customDebounceTime);

    // Create a debounced version of the task if it doesn't exist or if the debounce time has changed
    const taskKey = `${key}-${debounceTime}`; // Include debounce time in the key to handle changes

    if (!this.tasks.has(taskKey)) {
      const debouncedFunction = lodashDebounce(async () => {
        try {
          await task();
        } catch (error) {
          console.error(`Error executing task ${key}:`, error);
        }
      }, debounceTime);

      // Create a wrapper function that returns a Promise
      const wrappedFunction = async () => {
        return new Promise<void>((resolve) => {
          debouncedFunction();
          resolve();
        });
      };

      this.tasks.set(taskKey, wrappedFunction);
    }

    // Execute the debounced task
    const debouncedTask = this.tasks.get(taskKey);
    if (debouncedTask) {
      debouncedTask();
    }
  }

  /**
   * Clear all tasks
   */
  clear(): void {
    this.tasks.clear();
  }
}


================================================================================

# .\utils\fs\FileSystemImpl.ts

/**
 * Enhanced file system implementation with additional utility methods
 */
import * as fsPromises from 'fs/promises';
import * as fs from 'fs';
import * as path from 'path';
import * as glob from 'glob';
import type { FileSystem } from '../../core/types.js';

/**
 * File system implementation with enhanced functionality
 */
export class FileSystemImpl implements FileSystem {
  /**
   * Read a file
   * @param filePath Path to the file
   * @param encoding File encoding
   * @returns File content
   */
  async readFile(
    filePath: string,
    encoding: BufferEncoding = 'utf8'
  ): Promise<string> {
    return fsPromises.readFile(filePath, { encoding });
  }

  /**
   * Read a file synchronously
   * @param filePath Path to the file
   * @param encoding File encoding
   * @returns File content
   */
  readFileSync(filePath: string, encoding: BufferEncoding = 'utf8'): string {
    return fs.readFileSync(filePath, { encoding });
  }

  /**
   * Write a file
   * @param filePath Path to the file
   * @param content File content
   */
  async writeFile(filePath: string, content: string): Promise<void> {
    // Ensure the directory exists
    await this.ensureDir(path.dirname(filePath));
    return fsPromises.writeFile(filePath, content);
  }

  /**
   * Write a file synchronously
   * @param filePath Path to the file
   * @param content File content
   */
  writeFileSync(filePath: string, content: string): void {
    // Ensure the directory exists
    this.ensureDirSync(path.dirname(filePath));
    fs.writeFileSync(filePath, content);
  }

  /**
   * Copy a file
   * @param source Source file path
   * @param destination Destination file path
   */
  async copyFile(source: string, destination: string): Promise<void> {
    // Ensure the directory exists
    await this.ensureDir(path.dirname(destination));
    return fsPromises.copyFile(source, destination);
  }

  /**
   * Ensure a directory exists
   * @param dirPath Directory path
   */
  async ensureDir(dirPath: string): Promise<void> {
    try {
      await fsPromises.access(dirPath);
    } catch (error) {
      // Directory doesn't exist, create it
      await fsPromises.mkdir(dirPath, { recursive: true });
    }
  }

  /**
   * Ensure a directory exists (synchronous version)
   * @param dirPath Directory path
   */
  ensureDirSync(dirPath: string): void {
    try {
      fs.accessSync(dirPath);
    } catch (error) {
      // Directory doesn't exist, create it
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }

  /**
   * Check if a file exists
   * @param filePath File path
   * @returns Whether the file exists
   */
  async exists(filePath: string): Promise<boolean> {
    try {
      await fsPromises.access(filePath);
      return true;
    } catch (error) {
      return false;
    }
  }

  /**
   * Check if a file exists (synchronous version)
   * @param filePath File path
   * @returns Whether the file exists
   */
  existsSync(filePath: string): boolean {
    return fs.existsSync(filePath);
  }

  /**
   * Get files matching a pattern
   * @param pattern Glob pattern
   * @param options Glob options
   * @returns Matching file paths
   */
  async glob(
    pattern: string,
    options: glob.GlobOptions = {}
  ): Promise<string[]> {
    try {
      // Use glob directly
      const matches = await glob.glob(pattern, options);
      // Convert to string[] to satisfy the return type
      return matches.map((match) => match.toString());
    } catch (error) {
      console.error(`Error in glob pattern ${pattern}:`, error);
      return [];
    }
  }

  /**
   * Get files matching a pattern (synchronous version)
   * @param pattern Glob pattern
   * @param options Glob options
   * @returns Matching file paths
   */
  globSync(pattern: string, options: glob.GlobOptions = {}): string[] {
    try {
      const matches = glob.sync(pattern, options);
      // Convert to string[] to satisfy the return type
      return matches.map((match) => match.toString());
    } catch (error) {
      console.error(`Error in glob pattern ${pattern}:`, error);
      return [];
    }
  }

  /**
   * Get all file paths within a directory recursively
   * @param dirPath Directory to scan for files
   * @returns Array of file paths
   */
  getFilePaths(dirPath: string): string[] {
    const filePaths: string[] = [];

    // Helper function to recursively scan directories
    const scanDirectory = (directory: string) => {
      try {
        const items = fs.readdirSync(directory);

        for (const item of items) {
          const itemPath = path.join(directory, item);
          const stats = fs.statSync(itemPath);

          if (stats.isDirectory()) {
            scanDirectory(itemPath); // Recursively scan subdirectories
          } else if (stats.isFile()) {
            filePaths.push(itemPath); // Add file path to the result
          }
        }
      } catch (error) {
        console.error(`Error scanning directory: ${directory}`, error);
      }
    };

    // Start scanning from the provided directory path
    scanDirectory(dirPath);
    return filePaths;
  }

  /**
   * Find all paths containing a specific file (e.g., plugin.json)
   * @param dirPath The root directory to search
   * @param targetFileName The filename to search for
   * @returns Array of directory paths containing the target file
   */
  findPathsWithFile(dirPath: string, targetFileName: string): string[] {
    const foundPaths: string[] = [];

    // Helper function to recursively scan directories
    const scanDirectory = (directory: string) => {
      try {
        const items = fs.readdirSync(directory);

        for (const item of items) {
          const itemPath = path.join(directory, item);
          const stats = fs.statSync(itemPath);

          if (stats.isDirectory()) {
            scanDirectory(itemPath); // Recursively scan subdirectories
          } else if (stats.isFile() && item === targetFileName) {
            // When we find the target file, add its parent directory to foundPaths
            const parentDir = path.dirname(itemPath);
            if (!foundPaths.includes(parentDir)) {
              foundPaths.push(parentDir);
            }
          }
        }
      } catch (error) {
        console.error(`Error scanning directory: ${directory}`, error);
      }
    };

    // Start scanning from the provided directory path
    scanDirectory(dirPath);
    return foundPaths;
  }

  /**
   * Normalize a path for cross-platform consistency
   * @param filePath Path to normalize
   * @returns Normalized path with forward slashes
   */
  normalizePath(filePath: string): string {
    return path.normalize(filePath).replace(/\\/g, '/');
  }

  /**
   * Read directory contents
   * @param dirPath Directory path
   * @returns Array of file and directory names
   */
  async readdir(dirPath: string): Promise<string[]> {
    return fsPromises.readdir(dirPath);
  }

  /**
   * Read directory contents synchronously
   * @param dirPath Directory path
   * @returns Array of file and directory names
   */
  readdirSync(dirPath: string): string[] {
    return fs.readdirSync(dirPath);
  }
}


================================================================================

# .\utils\fs\HtmlUtils.ts

/**
 * HTML utility functions for generating HTML files for plugins
 */
import * as path from 'path';
import { fileSystem } from './index.js';
import { Plugin } from '../../core/types.js';
import { normalizePath } from './PathUtils.js';

/**
 * Generate HTML files for plugins with html/Page.tsx files
 * @param plugins Array of plugin objects
 * @param distDir The main distribution directory
 */
export async function generatePluginHtmlFiles(
  plugins: Plugin[],
  distDir: string
): Promise<void> {
  console.log('\nGenerating HTML files for plugins with Page.tsx...');

  // Get the webview assets directory
  const webviewAssetsDir = path.join(distDir, 'webview', 'assets');

  try {
    // Verify webview assets directory exists
    if (!(await fileSystem.exists(webviewAssetsDir))) {
      throw new Error(
        `Webview assets directory not found: ${webviewAssetsDir}`
      );
    }

    // Get the asset filenames
    const assetFiles = await fileSystem.readdir(webviewAssetsDir);

    // Find the JS and CSS files
    const indexJsFile = assetFiles.find(
      (file: string) => file.startsWith('index-') && file.endsWith('.js')
    );
    const vendorJsFile = assetFiles.find(
      (file: string) => file.startsWith('vendor-') && file.endsWith('.js')
    );
    const indexCssFile = assetFiles.find(
      (file: string) => file.startsWith('index-') && file.endsWith('.css')
    );

    if (!indexJsFile) {
      throw new Error('Could not find index JS file in webview assets');
    }

    if (!indexCssFile) {
      throw new Error('Could not find index CSS file in webview assets');
    }

    // Find plugins with webview pages
    const webviewPlugins = plugins.filter(
      (plugin) => plugin.hasHtml && plugin.fullPath
    );

    console.log(`Found ${webviewPlugins.length} plugins with webview pages`);

    if (webviewPlugins.length === 0) {
      console.log('No webview plugins found, skipping HTML generation');
      return;
    }

    // Generate HTML files for each plugin
    for (const plugin of webviewPlugins) {
      if (!plugin.fullPath) continue;

      // Get the plugin's output directory
      // Check if the path starts with 'plugins/' and strip it if needed
      const normalizedPluginPath = normalizePath(plugin.pathFromPluginsDir);
      const pluginsPathNormalized = normalizePath('plugins');
      const pathContainsPluginsPrefix =
        normalizedPluginPath.startsWith(pluginsPathNormalized) ||
        normalizedPluginPath.startsWith(pluginsPathNormalized + '/');

      let pluginRelativePath;
      if (pathContainsPluginsPrefix) {
        // Strip the 'plugins/' prefix to place resources directly in dist
        pluginRelativePath = normalizePath(
          path.relative(pluginsPathNormalized, normalizedPluginPath)
        );
        console.log(
          `HTML Generator: Stripped 'plugins/' prefix from path: ${normalizedPluginPath} -> ${pluginRelativePath}`
        );
      } else {
        pluginRelativePath = plugin.pathFromPluginsDir;
      }

      const outputDir = path.join(distDir, pluginRelativePath);
      const htmlDir = path.join(outputDir, 'html');

      // Ensure the html directory exists
      await fileSystem.ensureDir(htmlDir);

      // Read the plugin.json to get the plugin name
      const pluginJsonPath = path.join(plugin.fullPath, 'plugin.json');
      let pluginManifest;
      try {
        const pluginJsonContent = await fileSystem.readFile(
          pluginJsonPath,
          'utf8'
        );
        pluginManifest = JSON.parse(pluginJsonContent);
      } catch (error) {
        console.error(`Error reading plugin.json for ${plugin.name}:`, error);
        pluginManifest = { name: plugin.name || 'UI Resource' };
      }

      // Generate the HTML content
      const title = pluginManifest.name || 'UI Resource';
      const html = generateHtmlContent(
        title,
        indexJsFile,
        vendorJsFile,
        indexCssFile
      );

      // Write the HTML file
      const htmlFilePath = path.join(htmlDir, 'index.html');
      await fileSystem.writeFile(htmlFilePath, html);
      console.log(`Generated ${htmlFilePath}`);
    }

    console.log('HTML generation completed successfully!');
  } catch (error) {
    console.error('Error generating HTML files:', error);
    throw error;
  }
}

/**
 * Generate HTML content for a plugin
 * @param title Title for the HTML page
 * @param indexJsFile Name of the index JS file
 * @param vendorJsFile Name of the vendor JS file (optional)
 * @param indexCssFile Name of the index CSS file
 * @returns HTML content as a string
 */
export function generateHtmlContent(
  title: string,
  indexJsFile: string,
  vendorJsFile?: string,
  indexCssFile?: string
): string {
  return `<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap"
      rel="stylesheet"
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${title}</title>
    <script
      type="module"
      crossorigin
      src="https://cfx-nui-webview/assets/${indexJsFile}"
    ></script>
    ${
      vendorJsFile
        ? `<link
      rel="modulepreload"
      crossorigin
      href="https://cfx-nui-webview/assets/${vendorJsFile}"
    />`
        : ''
    }
    ${
      indexCssFile
        ? `<link
      rel="stylesheet"
      crossorigin
      href="https://cfx-nui-webview/assets/${indexCssFile}"
    />`
        : ''
    }
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>`;
}

/**
 * Generate a simple HTML file with a script reference
 * @param title Title for the HTML page
 * @param scriptPath Path to the script file
 * @returns HTML content as a string
 */
export function generateSimpleHtmlContent(
  title: string,
  scriptPath: string
): string {
  return `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${title}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="${scriptPath}"></script>
  </body>
</html>`;
}


================================================================================

# .\utils\fs\LogUtils.ts

/**
 * Logging utility functions for consistent logging across the codebase
 */

/**
 * Log levels
 */
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  NONE = 4,
}

/**
 * Logger configuration
 */
interface LoggerConfig {
  level: LogLevel;
  prefix?: string;
  timestamp?: boolean;
}

/**
 * Default logger configuration
 */
const defaultConfig: LoggerConfig = {
  level: LogLevel.INFO,
  prefix: '',
  timestamp: true,
};

/**
 * Current logger configuration
 */
let currentConfig: LoggerConfig = { ...defaultConfig };

/**
 * Configure the logger
 * @param config Logger configuration
 */
export function configureLogger(config: Partial<LoggerConfig>): void {
  currentConfig = { ...currentConfig, ...config };
}

/**
 * Get the current logger configuration
 * @returns Current logger configuration
 */
export function getLoggerConfig(): LoggerConfig {
  return { ...currentConfig };
}

/**
 * Format a log message
 * @param level Log level
 * @param message Message to log
 * @param args Additional arguments
 * @returns Formatted log message
 */
function formatLogMessage(level: LogLevel, message: string, ...args: any[]): string {
  let formattedMessage = '';
  
  // Add timestamp if enabled
  if (currentConfig.timestamp) {
    formattedMessage += `[${new Date().toISOString()}] `;
  }
  
  // Add prefix if set
  if (currentConfig.prefix) {
    formattedMessage += `[${currentConfig.prefix}] `;
  }
  
  // Add level prefix
  switch (level) {
    case LogLevel.DEBUG:
      formattedMessage += '[DEBUG] ';
      break;
    case LogLevel.INFO:
      formattedMessage += '[INFO] ';
      break;
    case LogLevel.WARN:
      formattedMessage += '[WARN] ';
      break;
    case LogLevel.ERROR:
      formattedMessage += '[ERROR] ';
      break;
  }
  
  // Add message
  formattedMessage += message;
  
  // Add additional arguments if any
  if (args.length > 0) {
    formattedMessage += ' ' + args.map(arg => {
      if (typeof arg === 'object') {
        try {
          return JSON.stringify(arg);
        } catch (e) {
          return arg.toString();
        }
      }
      return arg;
    }).join(' ');
  }
  
  return formattedMessage;
}

/**
 * Log a debug message
 * @param message Message to log
 * @param args Additional arguments
 */
export function debug(message: string, ...args: any[]): void {
  if (currentConfig.level <= LogLevel.DEBUG) {
    console.log(formatLogMessage(LogLevel.DEBUG, message, ...args));
  }
}

/**
 * Log an info message
 * @param message Message to log
 * @param args Additional arguments
 */
export function info(message: string, ...args: any[]): void {
  if (currentConfig.level <= LogLevel.INFO) {
    console.log(formatLogMessage(LogLevel.INFO, message, ...args));
  }
}

/**
 * Log a warning message
 * @param message Message to log
 * @param args Additional arguments
 */
export function warn(message: string, ...args: any[]): void {
  if (currentConfig.level <= LogLevel.WARN) {
    console.warn(formatLogMessage(LogLevel.WARN, message, ...args));
  }
}

/**
 * Log an error message
 * @param message Message to log
 * @param args Additional arguments
 */
export function error(message: string, ...args: any[]): void {
  if (currentConfig.level <= LogLevel.ERROR) {
    console.error(formatLogMessage(LogLevel.ERROR, message, ...args));
  }
}

/**
 * Create a logger with a specific prefix
 * @param prefix Logger prefix
 * @returns Logger object
 */
export function createLogger(prefix: string) {
  return {
    debug: (message: string, ...args: any[]) => {
      const savedPrefix = currentConfig.prefix;
      currentConfig.prefix = prefix;
      debug(message, ...args);
      currentConfig.prefix = savedPrefix;
    },
    info: (message: string, ...args: any[]) => {
      const savedPrefix = currentConfig.prefix;
      currentConfig.prefix = prefix;
      info(message, ...args);
      currentConfig.prefix = savedPrefix;
    },
    warn: (message: string, ...args: any[]) => {
      const savedPrefix = currentConfig.prefix;
      currentConfig.prefix = prefix;
      warn(message, ...args);
      currentConfig.prefix = savedPrefix;
    },
    error: (message: string, ...args: any[]) => {
      const savedPrefix = currentConfig.prefix;
      currentConfig.prefix = prefix;
      error(message, ...args);
      currentConfig.prefix = savedPrefix;
    },
  };
}


================================================================================

# .\utils\fs\PathUtils.ts

/**
 * Path utility functions for consistent path handling across the codebase
 */
import * as path from 'path';
import { fileURLToPath } from 'url';

/**
 * Project paths
 */
export interface ProjectPaths {
  pluginsDir: string;
  coreDir: string;
  distDir: string;
  rootDir: string;
  webviewDir: string;
}

/**
 * Get paths for the project
 */
export function getProjectPaths(): ProjectPaths {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  const rootDir = path.join(__dirname, '../../../../');

  return {
    pluginsDir: path.join(rootDir, 'src', 'plugins'),
    coreDir: path.join(rootDir, 'src', 'core'),
    distDir: path.join(rootDir, 'dist'),
    rootDir,
    webviewDir: path.join(rootDir, 'src', 'webview'),
  };
}

/**
 * Normalize a path for cross-platform consistency
 * @param filePath Path to normalize
 * @returns Normalized path with forward slashes
 */
export function normalizePath(filePath: string): string {
  return path.normalize(filePath).replace(/\\/g, '/');
}

/**
 * Get the relative path from one directory to another
 * @param from Source directory
 * @param to Target directory
 * @returns Normalized relative path with forward slashes
 */
export function getRelativePath(from: string, to: string): string {
  return normalizePath(path.relative(from, to));
}

/**
 * Join path segments and normalize the result
 * @param segments Path segments to join
 * @returns Normalized joined path with forward slashes
 */
export function joinPath(...segments: string[]): string {
  return normalizePath(path.join(...segments));
}

/**
 * Get the directory name of a path
 * @param filePath Path to get directory from
 * @returns Normalized directory path with forward slashes
 */
export function getDirName(filePath: string): string {
  return normalizePath(path.dirname(filePath));
}

/**
 * Get the base name of a path
 * @param filePath Path to get base name from
 * @param ext Optional extension to remove
 * @returns Base name of the path
 */
export function getBaseName(filePath: string, ext?: string): string {
  return path.basename(filePath, ext);
}

/**
 * Get the extension of a path
 * @param filePath Path to get extension from
 * @returns Extension of the path (including the dot)
 */
export function getExtension(filePath: string): string {
  return path.extname(filePath);
}

/**
 * Check if a path starts with a specific prefix
 * @param filePath Path to check
 * @param prefix Prefix to check for
 * @returns Whether the path starts with the prefix
 */
export function pathStartsWith(filePath: string, prefix: string): boolean {
  const normalizedPath = normalizePath(filePath);
  const normalizedPrefix = normalizePath(prefix);
  return normalizedPath.startsWith(normalizedPrefix);
}

/**
 * Calculate the output path for a file
 * @param file File object with pathFromPluginDir and name properties
 * @param outputDir Output directory
 * @returns Output path with correct extension
 */
export function calculateOutputPath(
  file: { pathFromPluginDir: string; name: string },
  outputDir: string
): { outputPath: string; outputPathWithCorrectExt: string } {
  // Calculate the output path
  const outputPath = joinPath(outputDir, file.pathFromPluginDir);
  
  // Replace .ts and .tsx extensions with .js
  const outputPathWithCorrectExt = outputPath.replace(/\.(ts|tsx)$/, '.js');
  
  return { outputPath, outputPathWithCorrectExt };
}

/**
 * Determine the category of a file based on its path
 * @param filePath Path to check
 * @returns Category of the file (client, server, shared, translations, or null)
 */
export function getFileCategory(
  filePath: string
): 'client' | 'server' | 'shared' | 'translations' | null {
  // Normalize the path to ensure consistent separators
  const normalizedPath = normalizePath(filePath);
  
  // Check if the path starts with any of the category prefixes
  if (normalizedPath.startsWith('client/')) {
    return 'client';
  } else if (normalizedPath.startsWith('server/')) {
    return 'server';
  } else if (normalizedPath.startsWith('shared/')) {
    return 'shared';
  } else if (normalizedPath.startsWith('translations/')) {
    return 'translations';
  }
  
  return null;
}


================================================================================

# .\utils\fs\PluginUtils.ts

/**
 * Plugin utility functions for working with plugins and their files
 */
import { FileSystemImpl } from './FileSystemImpl.js';
import { joinPath, normalizePath, getFileCategory } from './PathUtils.js';
import { Plugin, PluginFile } from '../../core/types.js';

// Create a file system instance for use in this module
const fs = new FileSystemImpl();

/**
 * Find all plugin paths within the specified directory
 * @param dirPath The root directory to search for plugins
 * @returns Array of plugin paths
 */
export function findPluginPaths(dirPath: string): string[] {
  return fs.findPathsWithFile(dirPath, 'plugin.json');
}

/**
 * Parse plugin paths into Plugin objects
 * @param pluginPaths Array of plugin directory paths
 * @returns Array of Plugin objects
 */
export function parsePluginPaths(pluginPaths: string[]): Plugin[] {
  const plugins: Plugin[] = [];

  if (pluginPaths.length === 0) {
    console.warn('No plugin paths provided to parsePluginPaths');
    return plugins;
  }

  // We need a consistent base plugins directory to calculate relative paths
  const pluginsDir = normalizePath(
    joinPath(pluginPaths[0], '..', '..')
  );

  for (const pluginPath of pluginPaths) {
    const pluginJsonPath = joinPath(pluginPath, 'plugin.json');

    try {
      // Check if the file exists first
      if (!fs.existsSync(pluginJsonPath)) {
        console.warn(`Plugin.json file not found at path: ${pluginJsonPath}`);
        continue;
      }

      const pluginJson = JSON.parse(fs.readFileSync(pluginJsonPath, 'utf8'));
      const normalizedPluginPath = normalizePath(pluginPath);

      // Calculate the correct path relative to the plugins directory
      const relativePath = normalizePath(
        joinPath(normalizedPluginPath).substring(pluginsDir.length + 1)
      );

      const plugin: Plugin = {
        name: pluginJson.name,
        pathFromPluginsDir: relativePath,
        hasHtml: fs.existsSync(joinPath(pluginPath, 'html', 'Page.tsx')),
        fullPath: normalizedPluginPath,
        files: [], // Initialize empty files array
      };
      plugins.push(plugin);
    } catch (error) {
      console.error(`Error parsing plugin.json at ${pluginJsonPath}:`, error);
    }
  }

  return plugins;
}

/**
 * Parse files within a plugin directory into File objects
 * @param pluginDirPath Plugin directory path
 * @returns Array of File objects
 */
export function parsePluginFiles(pluginDirPath: string): PluginFile[] {
  const files: string[] = fs.getFilePaths(pluginDirPath);
  const pluginDirNormalized = normalizePath(pluginDirPath);
  const result: PluginFile[] = [];

  for (const filePath of files) {
    const normalizedFilePath = normalizePath(filePath);
    const fileName = normalizedFilePath.split('/').pop() || '';
    const isPluginJsonFile = fileName === 'plugin.json';

    // Calculate the path relative to the plugin directory
    let pathFromPluginDir = '';
    if (normalizedFilePath.startsWith(pluginDirNormalized)) {
      pathFromPluginDir = normalizedFilePath.substring(
        pluginDirNormalized.length + 1
      );
    }

    const file: PluginFile = {
      name: fileName,
      pathFromPluginDir: normalizePath(pathFromPluginDir),
      isPluginJsonFile,
      fullPath: normalizedFilePath,
    };

    result.push(file);
  }

  return result;
}

/**
 * Read and parse plugin JSON file
 * @param jsonPath Path to the plugin.json file
 * @returns Parsed plugin JSON data or null if not found
 */
export function readPluginJson(jsonPath: string): any {
  try {
    // Check if the file exists first
    if (!fs.existsSync(jsonPath)) {
      console.warn(`Plugin.json file not found at path: ${jsonPath}`);
      return null;
    }

    const pluginJsonContent = fs.readFileSync(jsonPath, 'utf8');
    return JSON.parse(pluginJsonContent);
  } catch (err) {
    console.error(`Error reading plugin.json at ${jsonPath}:`, err);
    return null;
  }
}

/**
 * Calculate output paths and directories for a plugin
 * @param plugin Plugin object
 * @param distDir Distribution directory
 * @returns Object with output paths
 */
export function getPluginOutputInfo(plugin: Plugin, distDir: string) {
  const normalizedPluginPath = normalizePath(plugin.pathFromPluginsDir);
  const pluginsPathNormalized = normalizePath('plugins');
  const pathContainsPluginsPrefix =
    normalizedPluginPath.startsWith(pluginsPathNormalized) ||
    normalizedPluginPath.startsWith(pluginsPathNormalized + '/');

  // Calculate relative path consistently
  let pluginRelativePath = normalizedPluginPath;
  if (pathContainsPluginsPrefix) {
    // Strip the 'plugins/' prefix to place resources directly in dist
    pluginRelativePath = normalizedPluginPath.substring(
      pluginsPathNormalized.length + 1
    );
  } else if (plugin.name === 'core') {
    // Special case for the core plugin
    pluginRelativePath = 'core';
  }

  // Final output directory
  const outputDir = joinPath(distDir, pluginRelativePath);

  return {
    pluginRelativePath,
    outputDir,
    manifestPath: joinPath(distDir, pluginRelativePath, 'fxmanifest.lua'),
  };
}

/**
 * Categorize processed files by their type (client, server, shared, translations)
 * @param processedFiles Array of processed files
 * @returns Object with categorized files
 */
export function categorizeFiles(processedFiles: any[]) {
  const categorized: {
    client: string[];
    server: string[];
    shared: string[];
    translations: string[];
  } = {
    client: [],
    server: [],
    shared: [],
    translations: [],
  };

  processedFiles
    .filter((file) => file && file.category)
    .forEach((file) => {
      categorized[file.category as keyof typeof categorized].push(
        file.outputPath
      );
    });

  return categorized;
}


================================================================================

# .\utils\fs\ProcessUtils.ts

/**
 * Process utility functions for working with child processes
 */
import { spawn, ChildProcess, SpawnOptions } from 'child_process';
import { createLogger } from './LogUtils.js';

// Create a logger for process utilities
const logger = createLogger('ProcessUtils');

/**
 * Process execution result
 */
export interface ProcessResult {
  code: number | null;
  stdout: string;
  stderr: string;
}

/**
 * Execute a command and return the result
 * @param command Command to execute
 * @param args Command arguments
 * @param options Spawn options
 * @returns Promise that resolves with the process result
 */
export function executeCommand(
  command: string,
  args: string[] = [],
  options: SpawnOptions = {}
): Promise<ProcessResult> {
  return new Promise((resolve, reject) => {
    logger.info(`Executing command: ${command} ${args.join(' ')}`);
    
    const process = spawn(command, args, {
      ...options,
      shell: true,
      stdio: 'pipe',
    });
    
    let stdout = '';
    let stderr = '';
    
    if (process.stdout) {
      process.stdout.on('data', (data) => {
        const chunk = data.toString();
        stdout += chunk;
        logger.debug(`[stdout] ${chunk.trim()}`);
      });
    }
    
    if (process.stderr) {
      process.stderr.on('data', (data) => {
        const chunk = data.toString();
        stderr += chunk;
        logger.debug(`[stderr] ${chunk.trim()}`);
      });
    }
    
    process.on('close', (code) => {
      if (code === 0) {
        logger.info(`Command completed successfully with exit code ${code}`);
        resolve({ code, stdout, stderr });
      } else {
        logger.warn(`Command failed with exit code ${code}`);
        resolve({ code, stdout, stderr });
      }
    });
    
    process.on('error', (error) => {
      logger.error(`Command execution error: ${error.message}`);
      reject(error);
    });
  });
}

/**
 * Execute a command and stream the output
 * @param command Command to execute
 * @param args Command arguments
 * @param options Spawn options
 * @returns Promise that resolves when the process completes
 */
export function executeCommandWithOutput(
  command: string,
  args: string[] = [],
  options: SpawnOptions = {}
): Promise<number | null> {
  return new Promise((resolve, reject) => {
    logger.info(`Executing command with output: ${command} ${args.join(' ')}`);
    
    const process = spawn(command, args, {
      ...options,
      shell: true,
      stdio: 'inherit',
    });
    
    process.on('close', (code) => {
      if (code === 0) {
        logger.info(`Command completed successfully with exit code ${code}`);
        resolve(code);
      } else {
        logger.warn(`Command failed with exit code ${code}`);
        resolve(code);
      }
    });
    
    process.on('error', (error) => {
      logger.error(`Command execution error: ${error.message}`);
      reject(error);
    });
  });
}

/**
 * Start a long-running process
 * @param command Command to execute
 * @param args Command arguments
 * @param options Spawn options
 * @returns Child process
 */
export function startProcess(
  command: string,
  args: string[] = [],
  options: SpawnOptions = {}
): ChildProcess {
  logger.info(`Starting process: ${command} ${args.join(' ')}`);
  
  const process = spawn(command, args, {
    ...options,
    shell: true,
    stdio: 'pipe',
  });
  
  if (process.stdout) {
    process.stdout.on('data', (data) => {
      const chunk = data.toString();
      logger.debug(`[stdout] ${chunk.trim()}`);
    });
  }
  
  if (process.stderr) {
    process.stderr.on('data', (data) => {
      const chunk = data.toString();
      logger.debug(`[stderr] ${chunk.trim()}`);
    });
  }
  
  process.on('close', (code) => {
    logger.info(`Process exited with code ${code}`);
  });
  
  process.on('error', (error) => {
    logger.error(`Process error: ${error.message}`);
  });
  
  return process;
}

/**
 * Kill a process
 * @param process Child process to kill
 * @param signal Signal to send
 */
export function killProcess(process: ChildProcess, signal: NodeJS.Signals = 'SIGTERM'): void {
  if (process && !process.killed) {
    logger.info(`Killing process with signal ${signal}`);
    process.kill(signal);
  }
}


================================================================================

# .\utils\fs\RebuildUtils.ts

/**
 * Rebuild utilities for handling component rebuilds
 */
import * as path from 'path';
import * as fs from 'fs';
import * as fsPromises from 'fs/promises';
import { ConsoleLogger, LogLevel } from '../logger/ConsoleLogger.js';
import { ResourceManager } from './ResourceManager.js';
import {
  findPluginPaths,
  parsePluginPaths,
  getProjectPaths,
  generateManifest,
  fileSystem,
} from './index.js';
import type { Logger, BuildContext } from '../../core/types.js';

/**
 * Notify the reload server about a rebuilt component
 * @param componentType The type of component that was rebuilt
 * @param pluginDir The plugin directory (if applicable)
 * @param resourceManager The resource manager instance
 * @param logger The logger instance
 */
async function notifyReloadServer(
  componentType: 'plugin' | 'core' | 'webview',
  pluginDir: string | undefined,
  resourceManager: ResourceManager,
  logger: Logger
): Promise<void> {
  try {
    // Get the resource name based on the component type and plugin directory
    let resourceName: string | null = null;
    if (componentType === 'plugin' && pluginDir) {
      // Extract the plugin name from the directory path
      resourceName = path.basename(pluginDir);
    } else if (componentType === 'core') {
      resourceName = 'core';
    } else if (componentType === 'webview') {
      resourceName = 'webview';
    }

    // Restart the resource if we have a valid resource name
    if (resourceName) {
      logger.info(
        `Notifying reload server about rebuilt resource: ${resourceName}`
      );
      await resourceManager.restartResource(resourceName);
    }
  } catch (error) {
    logger.error(
      `Error notifying reload server: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
    // Don't rethrow, let the process continue
  }
}

// Global flag to track if a build is in progress
declare global {
  var isBuilding: boolean;
}

/**
 * Context for rebuilding components
 * Extends BuildContext to ensure compatibility with the build pipeline
 */
export type RebuildContext = BuildContext;

/**
 * Check if a plugin has webview content (Page.tsx file)
 * @param pluginDir Plugin directory
 * @returns Whether the plugin has webview content
 */
export async function checkForWebviewContent(
  pluginDir: string
): Promise<boolean> {
  try {
    // Check if the html directory exists
    const htmlDir = path.join(pluginDir, 'html');

    try {
      await fsPromises.access(htmlDir);
    } catch {
      // html directory doesn't exist
      return false;
    }

    // Check if Page.tsx exists
    const pageTsxPath = path.join(htmlDir, 'Page.tsx');

    try {
      await fsPromises.access(pageTsxPath);
      return true;
    } catch {
      // Page.tsx doesn't exist
      return false;
    }
  } catch (error) {
    console.error(`Error checking for webview content in ${pluginDir}:`, error);
    return false;
  }
}

/**
 * Rebuild component wrapper to handle common tasks
 * @param componentType Type of component to rebuild
 * @param pluginDir Optional plugin directory for plugin rebuilds
 * @param context Optional rebuild context for class-based pipeline
 */
export async function rebuildComponent(
  componentType: 'plugin' | 'core' | 'webview',
  pluginDir?: string,
  context?: RebuildContext
): Promise<void> {
  // Use provided logger or create a new one
  const logger =
    context?.logger || new ConsoleLogger({ minLevel: LogLevel.Info });

  logger.info(
    `Rebuilding ${componentType}${pluginDir ? `: ${pluginDir}` : ''}`
  );
  global.isBuilding = true;

  try {
    // If context is provided, use the class-based pipeline
    if (context) {
      await rebuildWithClassPipeline(componentType, pluginDir, context);
    } else {
      // Otherwise use the function-based pipeline
      await rebuildWithFunctionPipeline(componentType, pluginDir, logger);
    }
  } catch (error) {
    logger.error(
      `Error in rebuildComponent for ${componentType}: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
    // Don't rethrow, let the process continue
  } finally {
    global.isBuilding = false;
  }
}

/**
 * Rebuild using the function-based pipeline
 */
async function rebuildWithFunctionPipeline(
  componentType: 'plugin' | 'core' | 'webview',
  pluginDir: string | undefined,
  logger: Logger
): Promise<void> {
  try {
    const { coreDir, distDir } = getProjectPaths();

    // Import the builder functions dynamically to avoid circular dependencies
    const { buildAndGenerateManifests } = await import('../builder.js');

    switch (componentType) {
      case 'plugin': {
        if (!pluginDir) throw new Error('Plugin directory is required');
        const pluginPaths = findPluginPaths(path.dirname(pluginDir));
        const plugins = parsePluginPaths(
          pluginPaths.filter((p: string) => p === pluginDir)
        );
        await buildAndGenerateManifests(plugins, distDir);
        break;
      }
      case 'core': {
        const pluginPaths = findPluginPaths(coreDir);
        const corePlugins = parsePluginPaths(pluginPaths);
        await buildAndGenerateManifests(corePlugins, distDir);
        break;
      }
      case 'webview': {
        // If we need to rebuild webview assets, we would handle that here
        logger.info(
          'Webview rebuild requested, but no specific handler implemented'
        );
        break;
      }
    }

    // Check if we need to generate a webview manifest
    const webviewDir = path.join(distDir, 'webview');
    if (fs.existsSync(webviewDir)) {
      logger.info('Generating webview manifest...');
      generateManifest(
        {
          name: 'webview',
          version: '0.1.0',
          fx_version: 'cerulean',
          author: 'Baloony Gaze',
          games: ['gta5', 'rdr3'],
          description: 'Shared webview assets',
          files: ['index.html', 'assets/**/*'],
        },
        path.join(webviewDir, 'fxmanifest.lua')
      );
    }

    // Deploy built resources
    const resourceManager = new ResourceManager(fileSystem, logger, {
      reloaderEnabled: process.env.RELOADER_ENABLED === 'true',
      reloaderHost: process.env.RELOADER_HOST || 'localhost',
      reloaderPort: parseInt(process.env.RELOADER_PORT || '3414', 10),
      reloaderApiKey: process.env.RELOADER_API_KEY || 'your-secure-api-key',
    });
    await resourceManager.deployResources(distDir);

    // Notify the reload server about the rebuilt component
    await notifyReloadServer(componentType, pluginDir, resourceManager, logger);

    logger.info(
      `Rebuild process for ${componentType}${
        pluginDir ? `: ${pluginDir}` : ''
      } completed`
    );
  } catch (error) {
    logger.error(`Error rebuilding ${componentType}:`, error);
    throw error;
  }
}

/**
 * Rebuild using the class-based pipeline
 */
async function rebuildWithClassPipeline(
  componentType: 'plugin' | 'core' | 'webview',
  pluginDir: string | undefined,
  context: RebuildContext
): Promise<void> {
  const { logger } = context;

  try {
    // Import the BuildPipelineImpl to create a new pipeline
    const { BuildPipelineImpl } = await import(
      '../../core/build/BuildPipelineImpl.js'
    );

    // Create a new pipeline for the rebuild
    const pipeline = new BuildPipelineImpl();

    // Create a new context for the rebuild
    const rebuildContext = { ...context };

    // Import all the stages
    const { buildCorePluginsStage } = await import(
      '../../core/build/stages/BuildCorePluginsStage.js'
    );
    const { buildPluginsStage } = await import(
      '../../core/build/stages/BuildPluginsStage.js'
    );
    const { buildWebviewStage } = await import(
      '../../core/build/stages/BuildWebviewStage.js'
    );
    const { fixNestedPluginsStage } = await import(
      '../../core/build/stages/FixNestedPluginsStage.js'
    );
    const { deployResourcesStage } = await import(
      '../../core/build/stages/DeployResourcesStage.js'
    );

    // Skip the clean stage for incremental builds

    switch (componentType) {
      case 'plugin':
        if (!pluginDir) {
          logger.error('Cannot rebuild plugin: pluginDir is undefined');
          return;
        }

        // Override the plugins directory to only build the changed plugin
        rebuildContext.pluginsDir = path.dirname(pluginDir);

        // Add the buildPlugins stage
        pipeline.addStage('buildPlugins', buildPluginsStage);

        // Check if this plugin has webview content
        const hasWebviewContent = await checkForWebviewContent(pluginDir);
        if (hasWebviewContent) {
          // Add the buildWebview stage if the plugin has webview content
          pipeline.addStage('buildWebview', buildWebviewStage);
        }

        break;

      case 'core':
        // Add the buildCorePlugins stage
        pipeline.addStage('buildCorePlugins', buildCorePluginsStage);
        break;

      case 'webview':
        // For webview changes, we need to rebuild all plugins first to ensure
        // we have the latest plugin information
        pipeline.addStage('buildCorePlugins', buildCorePluginsStage);
        pipeline.addStage('buildPlugins', buildPluginsStage);
        pipeline.addStage('buildWebview', buildWebviewStage);
        break;
    }

    // Always add these final stages
    pipeline.addStage('fixNestedPlugins', fixNestedPluginsStage);
    pipeline.addStage('deployResources', deployResourcesStage);

    // Run the pipeline
    await pipeline.run(rebuildContext);

    // Notify the reload server about the rebuilt component
    const resourceManager = new ResourceManager(fileSystem, logger, {
      reloaderEnabled: process.env.RELOADER_ENABLED === 'true',
      reloaderHost: process.env.RELOADER_HOST || 'localhost',
      reloaderPort: parseInt(process.env.RELOADER_PORT || '3414', 10),
      reloaderApiKey: process.env.RELOADER_API_KEY || 'your-secure-api-key',
    });

    await notifyReloadServer(componentType, pluginDir, resourceManager, logger);

    logger.info(
      `Rebuild process for ${componentType}${
        pluginDir ? `: ${pluginDir}` : ''
      } completed`
    );
  } catch (error) {
    logger.error(
      `Error in rebuildComponent for ${componentType}: ${
        error instanceof Error ? error.message : String(error)
      }`
    );
    throw error;
  }
}


================================================================================

# .\utils\fs\ResourceManager.ts

/**
 * Unified Resource Manager
 * Combines functionality from both ResourceManager implementations
 */
import * as path from 'path';
import * as fs from 'fs';
import * as http from 'http';
import { FileSystem, Logger } from '../../core/types.js';
import { FileSystemImpl } from './FileSystemImpl.js';
import { ConsoleLogger, LogLevel } from '../logger/ConsoleLogger.js';

/**
 * Options for the resource manager
 */
export interface ResourceManagerOptions {
  reloaderEnabled: boolean;
  reloaderHost: string;
  reloaderPort: number;
  reloaderApiKey: string;
  generatedDir?: string;
}

/**
 * Default options for the resource manager
 */
const DEFAULT_OPTIONS: ResourceManagerOptions = {
  reloaderEnabled: process.env.RELOADER_ENABLED === 'true',
  reloaderHost: process.env.RELOADER_HOST || 'localhost',
  reloaderPort: parseInt(process.env.RELOADER_PORT || '3414', 10),
  reloaderApiKey: process.env.RELOADER_API_KEY || 'your-secure-api-key',
};

/**
 * Unified Resource Manager
 * Handles resource deployment, reloading, and tracking
 */
export class ResourceManager {
  private fs: FileSystem;
  private logger: Logger;
  private resourceMap = new Map<string, string>(); // Maps path -> resource name
  private resourceRestartTimestamps = new Map<string, number>();
  private readonly RESTART_COOLDOWN_MS = 2000; // 2 seconds cooldown

  // Options
  private reloaderEnabled: boolean;
  private reloaderHost: string;
  private reloaderPort: number;
  private reloaderApiKey: string;
  private generatedDir?: string;

  /**
   * Create a new resource manager
   * @param fs File system implementation
   * @param logger Logger implementation
   * @param options Resource manager options
   */
  constructor(
    fs: FileSystem = new FileSystemImpl(),
    logger: Logger = new ConsoleLogger({ minLevel: LogLevel.Info }),
    options: Partial<ResourceManagerOptions> = {}
  ) {
    this.fs = fs;
    this.logger = logger;

    // Merge default options with provided options
    const mergedOptions = { ...DEFAULT_OPTIONS, ...options };

    this.reloaderEnabled = mergedOptions.reloaderEnabled;
    this.reloaderHost = mergedOptions.reloaderHost;
    this.reloaderPort = mergedOptions.reloaderPort;
    this.reloaderApiKey = mergedOptions.reloaderApiKey;
    this.generatedDir = mergedOptions.generatedDir;

    if (this.generatedDir) {
      this.logger.debug(
        `ResourceManager initialized with generatedDir: ${this.generatedDir}`
      );
    }
  }

  /**
   * Get the number of mapped resources
   */
  getResourceCount(): number {
    return this.resourceMap.size;
  }

  /**
   * Deploy resources to the server
   * @param distDir Distribution directory
   */
  async deployResources(distDir: string): Promise<void> {
    this.logger.debug(`Deploying resources from ${distDir}`);

    try {
      // Get server name from environment variables
      const serverName = process.env.SERVER_NAME;

      if (!serverName) {
        this.logger.warn(
          'SERVER_NAME environment variable is not set. Skipping resource deployment.'
        );
        return;
      }

      const generatedDirName = `[GENERATED]`;
      const destinationBase = path.join('txData', serverName, 'resources');
      const destinationDir = path.join(destinationBase, generatedDirName);

      // Ensure destination directory exists
      this.logger.debug(
        `Ensuring destination directory exists: ${destinationDir}`
      );
      await this.fs.ensureDir(destinationDir);

      // Copy built resources
      this.logger.debug(
        `Copying built resources from ${distDir} to ${destinationDir}`
      );

      // Use Node.js fs module for recursive copying
      const fsPromises = await import('fs/promises');
      await fsPromises.cp(distDir, destinationDir, { recursive: true });

      this.logger.info('Built resources deployed successfully.');
    } catch (error) {
      this.logger.error('Error deploying resources:', error);
      throw error;
    }
  }

  /**
   * Determine resource name from a path
   */
  getResourceName(filePath: string): string | null {
    // Common subdirectories that aren't resources
    const commonSubdirs = [
      'client',
      'server',
      'shared',
      'html',
      'translations',
      'assets',
    ];

    if (!this.generatedDir) {
      // If no generatedDir is provided, we need to determine the resource name from the path

      // Start from the directory containing the file
      let currentDir = path.dirname(filePath);
      let dirName = path.basename(currentDir);

      // If the current directory is a common subdirectory, move up one level
      if (commonSubdirs.includes(dirName)) {
        currentDir = path.dirname(currentDir);
        dirName = path.basename(currentDir);
      }

      // Check if the directory has a manifest
      const manifestPath = path.join(currentDir, 'fxmanifest.lua');
      if (fs.existsSync(manifestPath)) {
        // First check if the manifest defines a name
        const manifestName = this.getResourceNameFromManifest(manifestPath);
        if (manifestName) {
          return manifestName;
        }
      }

      // If the directory name is in brackets, try to find a non-bracketed parent directory
      if (dirName.startsWith('[') && dirName.endsWith(']')) {
        // Split the path into parts
        const pathParts = currentDir.split(path.sep);

        // Start from the end and work backwards to find a non-bracketed directory
        for (let i = pathParts.length - 2; i >= 0; i--) {
          if (
            !pathParts[i].startsWith('[') &&
            !pathParts[i].endsWith(']') &&
            !commonSubdirs.includes(pathParts[i])
          ) {
            return pathParts[i];
          }
        }
      }

      // Return the resource name (directory name)
      return dirName;
    }

    // Start from the directory containing the file
    let currentDir = path.dirname(filePath);

    // Walk up the directory tree looking for a manifest
    while (currentDir && currentDir !== this.generatedDir) {
      const manifestPath = path.join(currentDir, 'fxmanifest.lua');

      // Check if we've already mapped this directory to a resource
      if (this.resourceMap.has(currentDir)) {
        return this.resourceMap.get(currentDir)!;
      }

      // Check if this directory has a manifest
      if (fs.existsSync(manifestPath)) {
        // First check if the manifest defines a name
        const manifestName = this.getResourceNameFromManifest(manifestPath);
        if (manifestName) {
          this.resourceMap.set(currentDir, manifestName);
          return manifestName;
        }

        // If no name in manifest, use the leaf directory name
        const leafDirName = path.basename(currentDir);

        // If the leaf directory is in brackets, try to find a non-bracketed parent
        if (leafDirName.startsWith('[') && leafDirName.endsWith(']')) {
          // Split the path into parts
          const pathParts = currentDir.split(path.sep);

          // Start from the end and work backwards to find a non-bracketed directory
          for (let i = pathParts.length - 2; i >= 0; i--) {
            if (
              !pathParts[i].startsWith('[') &&
              !pathParts[i].endsWith(']') &&
              !commonSubdirs.includes(pathParts[i])
            ) {
              const resourceName = pathParts[i];
              this.resourceMap.set(currentDir, resourceName);
              return resourceName;
            }
          }
        }

        this.resourceMap.set(currentDir, leafDirName);
        return leafDirName;
      }

      // Move up one directory
      currentDir = path.dirname(currentDir);
    }

    // Fallback: if we couldn't find a manifest, use first directory in relative path
    const relativePath = path.relative(this.generatedDir || '', filePath);
    const pathParts = relativePath.split(path.sep);

    // If the first part is in brackets, try to find a non-bracketed part
    if (
      pathParts.length > 0 &&
      pathParts[0].startsWith('[') &&
      pathParts[0].endsWith(']')
    ) {
      // Look for the first non-bracketed, non-common subdirectory
      for (let i = 1; i < pathParts.length; i++) {
        if (
          !pathParts[i].startsWith('[') &&
          !pathParts[i].endsWith(']') &&
          !commonSubdirs.includes(pathParts[i])
        ) {
          return pathParts[i];
        }
      }
    }

    // Skip common subdirectories that aren't resources
    if (pathParts.length > 1 && commonSubdirs.includes(pathParts[1])) {
      return pathParts[0];
    }

    return pathParts[0] || null;
  }

  /**
   * Extract resource name from manifest file
   */
  getResourceNameFromManifest(manifestPath: string): string | null {
    try {
      if (fs.existsSync(manifestPath)) {
        const content = fs.readFileSync(manifestPath, 'utf8');
        const nameMatch = content.match(/name\s*=\s*["']([^"']+)["']/);
        if (nameMatch && nameMatch[1]) {
          return nameMatch[1];
        }
      }
    } catch (error) {
      this.logger.error('Error reading manifest:', error);
    }
    return null;
  }

  /**
   * Scan directory for resources and build resource map
   */
  scanForResources(dir: string): void {
    try {
      const entries = fs.readdirSync(dir);

      for (const entry of entries) {
        const fullPath = path.join(dir, entry);

        try {
          const stats = fs.statSync(fullPath);

          if (stats.isDirectory()) {
            // Check if this directory has a manifest
            const manifestPath = path.join(fullPath, 'fxmanifest.lua');
            if (fs.existsSync(manifestPath)) {
              // Get resource name from manifest or use directory name
              const manifestName =
                this.getResourceNameFromManifest(manifestPath);
              const resourceName = manifestName || entry;

              this.resourceMap.set(fullPath, resourceName);
              this.logger.debug(
                `Mapped directory ${fullPath} to resource ${resourceName}`
              );
            }

            // Recursively scan subdirectories
            this.scanForResources(fullPath);
          }
        } catch (error) {
          // Skip if can't access
        }
      }
    } catch (error) {
      this.logger.error('Error scanning directory:', error);
    }
  }

  /**
   * Restart a resource with cooldown protection
   */
  async restartResource(resourceName: string): Promise<void> {
    // Skip common subdirectories that aren't resources
    const commonSubdirs = [
      'client',
      'server',
      'shared',
      'html',
      'translations',
      'assets',
    ];

    if (commonSubdirs.includes(resourceName)) {
      this.logger.debug(
        `Skipping restart for '${resourceName}' as it appears to be a subdirectory, not a resource`
      );
      return;
    }

    // Skip if resource name is in brackets (these are directory containers, not actual resources)
    if (resourceName.startsWith('[') && resourceName.endsWith(']')) {
      this.logger.debug(
        `Skipping restart for '${resourceName}' as it appears to be a directory container, not a resource`
      );
      return;
    }

    this.logger.debug(`Restarting resource: ${resourceName}`);

    // Skip if resource name is empty or undefined
    if (!resourceName) {
      this.logger.error(`Invalid resource name: ${resourceName}`);
      return;
    }

    // Check if this resource was recently restarted
    const lastRestartTime =
      this.resourceRestartTimestamps.get(resourceName) || 0;
    const now = Date.now();
    const timeSinceLastRestart = now - lastRestartTime;

    if (timeSinceLastRestart < this.RESTART_COOLDOWN_MS) {
      this.logger.debug(
        `Skipping restart for ${resourceName} - last restart was ${timeSinceLastRestart}ms ago (cooldown: ${this.RESTART_COOLDOWN_MS}ms)`
      );
      return;
    }

    // Update the timestamp for this resource
    this.resourceRestartTimestamps.set(resourceName, now);

    this.logger.info(`Attempting to reload resource: ${resourceName}`);
    this.logger.info(`Reloader enabled: ${this.reloaderEnabled}`);
    this.logger.info(`Reloader host: ${this.reloaderHost}`);
    this.logger.info(`Reloader port: ${this.reloaderPort}`);
    this.logger.info(
      `Reloader API key: ${this.reloaderApiKey ? 'Set' : 'Not set'}`
    );

    if (!this.reloaderEnabled) {
      this.logger.debug(
        `Resource reloader is disabled. Skipping reload of ${resourceName}.`
      );
      return;
    }

    try {
      // Construct the URL for the reload request - use the correct endpoint format
      const url = `http://${this.reloaderHost}:${this.reloaderPort}/restart?resource=${resourceName}`;

      // Send the request
      await this.sendReloadRequest(url, resourceName);

      this.logger.info(`Resource ${resourceName} reloaded successfully.`);
    } catch (error) {
      this.logger.error(`Error reloading resource ${resourceName}:`, error);
    }
  }

  /**
   * Send a reload request
   * @param url URL to send the request to
   * @param resourceName Name of the resource being reloaded (for logging)
   */
  private sendReloadRequest(url: string, resourceName: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.logger.debug(
        `Sending POST request to ${url} to reload resource ${resourceName}`
      );

      // Parse the URL to get host, port, and path
      const urlParts = new URL(url);

      const options = {
        hostname: urlParts.hostname,
        port: urlParts.port,
        path: urlParts.pathname + urlParts.search,
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.reloaderApiKey}`,
          'Content-Type': 'application/json',
        },
      };

      this.logger.debug(`Request options: ${JSON.stringify(options)}`);

      const req = http.request(options, (res) => {
        let data = '';

        res.on('data', (chunk) => {
          data += chunk;
        });

        res.on('end', () => {
          this.logger.debug(`Received response: ${res.statusCode} ${data}`);

          if (res.statusCode === 200) {
            resolve();
          } else {
            reject(
              new Error(
                `Failed to reload resource ${resourceName}: ${res.statusCode} ${data}`
              )
            );
          }
        });
      });

      req.on('error', (error) => {
        this.logger.error(`HTTP request error for ${resourceName}:`, error);
        reject(error);
      });

      // Set a timeout for the request
      req.setTimeout(5000, () => {
        this.logger.error(
          `Request timeout for resource ${resourceName} reload`
        );
        req.destroy();
        reject(new Error(`Request timeout for resource ${resourceName}`));
      });

      req.end();
    });
  }

  /**
   * Check if the reloader is enabled
   * @returns Whether the reloader is enabled
   */
  isReloaderEnabled(): boolean {
    return this.reloaderEnabled;
  }

  /**
   * Get the reloader host
   * @returns The reloader host
   */
  getReloaderHost(): string {
    return this.reloaderHost;
  }

  /**
   * Get the reloader port
   * @returns The reloader port
   */
  getReloaderPort(): number {
    return this.reloaderPort;
  }

  /**
   * Check if the reloader API key is set
   * @returns Whether the reloader API key is set
   */
  hasReloaderApiKey(): boolean {
    return !!this.reloaderApiKey;
  }
}


================================================================================

# .\utils\fs\ScriptUtils.ts

/**
 * Script utility functions for working with script files
 */
import { FileSystemImpl } from './FileSystemImpl.js';
import { joinPath, normalizePath, calculateOutputPath, getFileCategory } from './PathUtils.js';
import { ScriptFiles, ScriptPatterns, PluginFile } from '../../core/types.js';
import { bundleJavaScript, bundleTypeScript, copyLuaFile } from '../bundler.js';

// Create a file system instance for use in this module
const fs = new FileSystemImpl();

/**
 * Get all matching script files from a plugin based on patterns in the plugin.json
 * @param pluginJsonData Plugin JSON configuration
 * @param pluginPath Full path to the plugin directory
 * @returns Object containing arrays of client, server, and shared script files
 */
export function getPluginScripts(
  pluginJsonData: any,
  pluginPath: string
): ScriptFiles {
  // Default result with empty arrays
  const result: ScriptFiles = {
    client: [],
    server: [],
    shared: [],
  };

  // If pluginJsonData is null, return empty result
  if (pluginJsonData === null) {
    console.warn(
      `No plugin JSON data available for ${pluginPath.split('/').pop()}, returning empty script list`
    );
    return result;
  }

  // Helper function to resolve glob patterns relative to the plugin directory
  const resolvePatterns = (
    patterns: string[],
    type: 'client' | 'server' | 'shared'
  ) => {
    if (!patterns || !Array.isArray(patterns)) return;

    patterns.forEach((pattern) => {
      try {
        // Make sure the pattern is properly formed for glob
        const normalizedPattern = normalizePath(pattern);

        // Resolve the glob pattern relative to the plugin directory
        const matches = fs.globSync(normalizedPattern, {
          cwd: pluginPath,
          absolute: false,
          nodir: true,
        });

        // Add all matches to the result array for this type
        result[type].push(...matches);
      } catch (error) {
        console.warn(
          `Error processing pattern "${pattern}" for ${type} scripts:`,
          error
        );
      }
    });
  };

  // Process client scripts
  if (pluginJsonData.client_scripts) {
    resolvePatterns(pluginJsonData.client_scripts, 'client');
  }

  // Process server scripts
  if (pluginJsonData.server_scripts) {
    resolvePatterns(pluginJsonData.server_scripts, 'server');
  }

  // Process shared scripts
  if (pluginJsonData.shared_scripts) {
    resolvePatterns(pluginJsonData.shared_scripts, 'shared');
  }

  return result;
}

/**
 * Process a single file based on its type
 * @param file File object to process
 * @param outputDir Output directory
 * @returns Processed file information or null if skipped
 */
export async function processFile(file: PluginFile, outputDir: string) {
  // Skip plugin.json as it's handled separately
  if (file.isPluginJsonFile) {
    return null;
  }

  const fileExt = file.name.substring(file.name.lastIndexOf('.')).toLowerCase();
  
  // Calculate the output path
  let relativeFilePath = file.pathFromPluginDir;
  
  // Check if the file path starts with 'src/core/' (case-insensitive)
  if (relativeFilePath.toLowerCase().startsWith('src/core/')) {
    relativeFilePath = relativeFilePath.substring('src/core/'.length);
  }
  
  const { outputPath, outputPathWithCorrectExt } = calculateOutputPath(
    { pathFromPluginDir: relativeFilePath, name: file.name },
    outputDir
  );

  // Ensure output directory exists
  await fs.ensureDir(joinPath(outputPath, '..'));

  try {
    switch (fileExt) {
      case '.ts':
        // Skip .d.ts files
        if (file.name.endsWith('.d.ts')) {
          return null;
        }
        // For TSX files (React components)
        if (file.name.endsWith('.tsx')) {
          await bundleTypeScript(
            file.fullPath,
            outputPath.replace('.tsx', '.js'),
            true
          );
        } else {
          await bundleTypeScript(
            file.fullPath,
            outputPath.replace('.ts', '.js')
          );
        }
        break;
      case '.js':
        await bundleJavaScript(file.fullPath, outputPath);
        break;
      case '.lua':
        await copyLuaFile(file.fullPath, outputPath);
        break;
      default:
        // Copy other files directly
        await fs.copyFile(file.fullPath, outputPath);
        break;
    }

    return {
      sourcePath: file.pathFromPluginDir,
      outputPath: normalizePath(outputPathWithCorrectExt.substring(outputDir.length + 1)),
      category: getFileCategory(file.pathFromPluginDir),
    };
  } catch (err) {
    console.error(`Error processing file ${file.fullPath}:`, err);
    return null;
  }
}


================================================================================

# .\utils\fs\WatcherManager.ts

/**
 * Unified Watcher Manager
 * Handles file watching and triggering rebuilds
 */
import * as path from 'path';
import * as fs from 'fs';
import * as chokidar from 'chokidar';
import 'dotenv/config';
import { DebouncedTaskManager } from './DebouncedTaskManager.js';
import { ResourceManager } from './ResourceManager.js';
import { findPluginPaths, rebuildComponent } from './index.js';
import { Logger, Watcher } from '../../core/types.js';
import { ConsoleLogger, LogLevel } from '../logger/ConsoleLogger.js';

/**
 * Watcher options
 */
export interface WatcherOptions {
  /** Whether to ignore initial scan */
  ignoreInitial?: boolean;
  /** Patterns to ignore */
  ignored?: string[];
  /** Whether to keep the process running */
  persistent?: boolean;
  /** Whether to use polling */
  usePolling?: boolean;
  /** Polling interval in milliseconds */
  interval?: number;
  /** Maximum directory depth */
  depth?: number;
  /** Whether to await write finish */
  awaitWriteFinish?:
    | boolean
    | { stabilityThreshold?: number; pollInterval?: number };
}

/**
 * Default watcher options
 */
const DEFAULT_WATCHER_OPTIONS: WatcherOptions = {
  ignoreInitial: true,
  ignored: ['**/node_modules/**', '**/.git/**'],
  persistent: true,
  usePolling: true,
  interval: 1000,
  depth: 99,
};

/**
 * Unified Watcher Manager
 * Implements both the simple and advanced watcher functionality
 */
export class WatcherManager implements Watcher {
  private logger: Logger;
  private debouncedTaskManager: DebouncedTaskManager;
  private resourceManager: ResourceManager;
  private watchers: chokidar.FSWatcher[] = [];
  private watcherOptions: WatcherOptions;

  /**
   * Create a new watcher manager
   * @param debouncedTaskManager Debounced task manager
   * @param resourceManager Resource manager
   * @param logger Logger
   * @param options Watcher options
   */
  constructor(
    debouncedTaskManager: DebouncedTaskManager = new DebouncedTaskManager(),
    resourceManager: ResourceManager = new ResourceManager(),
    logger: Logger = new ConsoleLogger({ minLevel: LogLevel.Info }),
    options: WatcherOptions = {}
  ) {
    this.debouncedTaskManager = debouncedTaskManager;
    this.resourceManager = resourceManager;
    this.logger = logger;
    this.watcherOptions = { ...DEFAULT_WATCHER_OPTIONS, ...options };

    // Initialize the ResourceManager with the generated directory
    const generatedDir = this.getGeneratedDir();
    if (generatedDir) {
      // We're using the same ResourceManager instance, but we want to make sure
      // it has the generatedDir property set correctly
      Object.defineProperty(this.resourceManager, 'generatedDir', {
        value: generatedDir,
        writable: false,
      });
    }
  }

  /**
   * Watch paths for changes
   * @param paths Paths to watch
   * @param onChange Callback to execute when a file changes
   */
  watch(paths: string[], onChange: (path: string) => void): void {
    this.logger.debug(`Setting up watcher for paths: ${paths.join(', ')}`);

    try {
      // Create a watcher with ignored patterns
      const watcher = chokidar.watch(paths, {
        persistent: this.watcherOptions.persistent,
        ignoreInitial: this.watcherOptions.ignoreInitial,
        ignored: this.watcherOptions.ignored,
        usePolling: this.watcherOptions.usePolling,
        interval: this.watcherOptions.interval,
        depth: this.watcherOptions.depth,
        awaitWriteFinish: this.watcherOptions.awaitWriteFinish,
      });

      // Set up event handlers
      watcher
        .on('ready', () => {
          this.logger.info(`Watcher ready for paths: ${paths.join(', ')}`);
        })
        .on('all', (event, filePath) => {
          this.logger.debug(`File event: ${event} ${filePath}`);

          // Only respond to changes in relevant file types
          if (!/\.(ts|json|lua|tsx|jsx|css|html)$/.test(filePath)) {
            this.logger.debug(`Ignoring non-source file: ${filePath}`);
            return;
          }

          // Add more detailed logging
          this.logger.info(`Processing file change: ${event} ${filePath}`);

          // Execute the callback
          this.debouncedTaskManager.execute(filePath, async () => {
            onChange(filePath);
          });
        });

      // Store the watcher
      this.watchers.push(watcher);
    } catch (error) {
      this.logger.error(`Error setting up watcher:`, error);
      throw error;
    }
  }

  /**
   * Stop all watchers
   */
  stop(): void {
    this.logger.debug('Stopping all watchers');

    for (const watcher of this.watchers) {
      watcher.close();
    }

    this.watchers = [];
  }

  /**
   * Set up watcher for a directory with consistent options
   */
  setupDirectoryWatcher(
    dir: string,
    description: string,
    ignoredPaths: string[],
    filePattern: RegExp,
    onChange: (filePath: string) => void
  ): void {
    this.logger.info(`Setting up watcher for ${description}: ${dir}`);

    const options = {
      ...this.watcherOptions,
      ignored: [...(this.watcherOptions.ignored || []), ...ignoredPaths],
    };

    try {
      const watcher = chokidar
        .watch(dir, options)
        .on('ready', () => {
          this.logger.info(`Watcher ready for ${description}: ${dir}`);
        })
        .on('all', (event, filePath) => {
          this.logger.debug(`File event in ${description}:`, event, filePath);

          // Only respond to changes in relevant file types
          if (!filePattern.test(filePath)) {
            this.logger.debug(`Ignoring non-source file: ${filePath}`);
            return;
          }

          if (global.isBuilding) {
            this.logger.debug('Build already in progress, skipping');
            return;
          }

          onChange(filePath);
        });

      // Store the watcher
      this.watchers.push(watcher);
    } catch (error) {
      this.logger.error(`Error setting up watcher for ${description}:`, error);
    }
  }

  /**
   * Set up watchers for plugins
   */
  setupPluginWatchers(
    pluginsDir: string,
    distDir: string,
    rebuildComponent: (
      componentType: 'plugin' | 'core' | 'webview',
      pluginDir?: string
    ) => Promise<void> | void
  ): void {
    this.logger.debug(`Setting up plugin watchers for ${pluginsDir}`);

    try {
      // Watch the entire plugins directory
      this.setupDirectoryWatcher(
        pluginsDir,
        'plugins directory',
        [distDir],
        /\.(ts|json|lua|tsx|jsx|css|html)$/,
        (filePath) => {
          // Get the plugin directory
          const pluginDir = this.getPluginDirFromFilePath(filePath, pluginsDir);

          if (pluginDir) {
            this.logger.debug(
              `File changed in plugin ${path.basename(pluginDir)}: ${filePath}`
            );

            // Rebuild the plugin
            this.debouncedTaskManager.execute(pluginDir, async () => {
              await rebuildComponent('plugin', pluginDir);
            });
          }
        }
      );
    } catch (error) {
      this.logger.error(`Error setting up plugin watchers:`, error);
    }
  }

  /**
   * Set up watcher for core
   */
  setupCoreWatcher(
    coreDir: string,
    distDir: string,
    rebuildComponent: (
      componentType: 'plugin' | 'core' | 'webview',
      pluginDir?: string
    ) => Promise<void> | void
  ): void {
    this.logger.debug(`Setting up core watcher for ${coreDir}`);

    try {
      // Use setupDirectoryWatcher for consistency
      this.setupDirectoryWatcher(
        coreDir,
        'core',
        [distDir],
        /\.(ts|json|lua)$/,
        (filePath) => {
          this.logger.debug(`File changed in core: ${filePath}`);

          // Rebuild the core
          this.debouncedTaskManager.execute('core', async () => {
            await rebuildComponent('core');
          });
        }
      );
    } catch (error) {
      this.logger.error(`Error setting up core watcher:`, error);
    }
  }

  /**
   * Set up watcher for webview files
   */
  setupWebviewWatcher(
    pluginsDir: string,
    distDir: string,
    rebuildComponent: (
      componentType: 'plugin' | 'core' | 'webview',
      pluginDir?: string
    ) => Promise<void> | void
  ): void {
    this.logger.debug(`Setting up webview watcher for ${pluginsDir}`);

    try {
      // Watch for Page.tsx files in the plugins directory
      const pageTsxPattern = path.join(pluginsDir, '**', 'html', 'Page.tsx');

      this.setupDirectoryWatcher(
        pluginsDir,
        'webview files',
        [distDir],
        /html\/Page\.tsx$/,
        (filePath) => {
          this.logger.info(`Page.tsx file changed: ${filePath}`);

          // Get the plugin directory containing this file
          const pluginDir = path.dirname(path.dirname(filePath));

          if (!pluginDir) {
            this.logger.warn(
              `Could not determine plugin directory for ${filePath}`
            );
            return;
          }

          // Use a specific debounce key for this plugin
          const debounceKey = `webview-${pluginDir}`;

          this.debouncedTaskManager.execute(debounceKey, async () => {
            try {
              // First rebuild the plugin to ensure all assets are up to date
              this.logger.info(
                `Rebuilding plugin ${pluginDir} due to Page.tsx change`
              );
              await rebuildComponent('plugin', pluginDir);

              // Then rebuild the webview
              this.logger.info(
                `Rebuilding webview after plugin ${pluginDir} rebuild`
              );
              await rebuildComponent('webview', undefined);
            } catch (error) {
              this.logger.error(
                `Error rebuilding after Page.tsx change in ${pluginDir}:`,
                error
              );
            }
          });
        }
      );
    } catch (error) {
      this.logger.error(`Error setting up webview watcher:`, error);
    }
  }

  /**
   * Set up watcher for dist directory to track changes but not restart resources
   */
  setupDistWatcher(distDir: string): void {
    this.setupDirectoryWatcher(
      distDir,
      'dist',
      [path.join(distDir, 'scripts', '**')],
      /.*/, // Match all files
      (filePath) => {
        // Get the relative path from the dist directory
        const relativePath = path.relative(distDir, filePath);
        const pathParts = relativePath.split(path.sep);

        // Skip if this is in the scripts directory
        if (pathParts[0] === 'scripts') {
          return;
        }

        // Common subdirectories that aren't resources
        const commonSubdirs = [
          'client',
          'server',
          'shared',
          'html',
          'translations',
          'assets',
        ];

        // Try to determine the resource name
        let resourceName = null;
        let manifestFound = false;
        let resourcePath = '';

        // First, try to find a manifest file by walking up the directory tree
        for (let i = 0; i < pathParts.length - 1; i++) {
          // Build the path incrementally
          resourcePath = path.join(resourcePath, pathParts[i]);
          const fullResourcePath = path.join(distDir, resourcePath);
          const manifestPath = path.join(fullResourcePath, 'fxmanifest.lua');

          if (fs.existsSync(manifestPath)) {
            // Found a manifest, this is a resource
            resourceName = path.basename(resourcePath);
            manifestFound = true;
            this.logger.debug(`Found resource with manifest: ${resourceName}`);
            break;
          }
        }

        // If we didn't find a manifest, try to determine the resource name from the path
        if (!manifestFound) {
          // Check if the file is in a common subdirectory
          if (
            pathParts.length >= 2 &&
            commonSubdirs.includes(pathParts[pathParts.length - 2])
          ) {
            // Find the last directory that's not a common subdirectory and not in brackets
            let foundResource = false;

            // Start from the end and work backwards to find the resource name
            for (let i = pathParts.length - 3; i >= 0; i--) {
              // Skip pure container directories (like '[misc]') but allow plugin directories inside them (like '[misc]/example')
              if (!commonSubdirs.includes(pathParts[i])) {
                // If this is a bracketed directory, check if it contains actual plugins
                if (
                  pathParts[i].startsWith('[') &&
                  pathParts[i].endsWith(']')
                ) {
                  // Only skip if this is the last part of the path (pure container)
                  if (i === pathParts.length - 1) {
                    this.logger.debug(
                      `Skipping restart for '${pathParts[i]}' as it appears to be a directory container, not a resource`
                    );
                    continue;
                  }
                }

                resourceName = pathParts[i];
                foundResource = true;
                this.logger.debug(
                  `Found resource from path structure: ${resourceName}`
                );
                break;
              }
            }

            // If we still didn't find a resource name, use the first part of the path
            if (!foundResource && pathParts.length > 0) {
              resourceName = pathParts[0];
              this.logger.debug(
                `Using first path part as resource name: ${resourceName}`
              );
            }
          } else if (pathParts.length > 0) {
            // Use the first part of the path
            resourceName = pathParts[0];
            this.logger.debug(
              `Using first path part as resource name: ${resourceName}`
            );
          }
        }

        // Log the detected resource but don't restart it
        // Resource reloading is handled by the generated folder watcher
        if (resourceName && resourceName !== 'scripts') {
          this.logger.info(
            `Resource change detected in dist: ${resourceName} (not restarting)`
          );
        }
      }
    );
  }

  /**
   * Get the path to the generated resources directory
   */
  private getGeneratedDir(): string | null {
    if (!process.env.SERVER_NAME) {
      this.logger.error(
        'SERVER_NAME environment variable is not set. Cannot determine generated directory.'
      );
      return null;
    }

    const generatedDirName = '[GENERATED]';
    const destinationBase = path.join(
      'txData',
      process.env.SERVER_NAME,
      'resources'
    );
    return path.join(destinationBase, generatedDirName);
  }

  /**
   * Set up watcher for generated resources folder
   * This is the ONLY place that should trigger resource reloads
   */
  setupGeneratedFolderWatcher(): void {
    const generatedDir = this.getGeneratedDir();
    if (!generatedDir) {
      return;
    }

    this.logger.info(
      `Setting up watcher for generated resources: ${generatedDir}`
    );

    this.logger.info(
      `Resource manager reloader enabled: ${this.resourceManager.isReloaderEnabled()}`
    );
    this.logger.info(
      `Resource manager reloader host: ${this.resourceManager.getReloaderHost()}`
    );
    this.logger.info(
      `Resource manager reloader port: ${this.resourceManager.getReloaderPort()}`
    );
    this.logger.info(
      `Resource manager reloader API key set: ${this.resourceManager.hasReloaderApiKey()}`
    );

    this.setupDirectoryWatcher(
      generatedDir,
      'generated resources',
      [],
      /.*/, // Match all files
      async (filePath) => {
        // wait 1 second
        await new Promise((resolve) => setTimeout(resolve, 1000));
        this.logger.debug(`File event in generated folder: ${filePath}`);

        // Skip webview and scripts directories
        if (
          filePath.includes('/webview/') ||
          filePath.includes('\\webview\\') ||
          filePath.includes('/scripts/') ||
          filePath.includes('\\scripts\\')
        ) {
          return;
        }

        try {
          // Find the actual resource by looking for the manifest file
          let currentDir = path.dirname(filePath);
          let resourceName = null;
          let manifestFound = false;

          // Common subdirectories that aren't resources
          const commonSubdirs = [
            'client',
            'server',
            'shared',
            'html',
            'translations',
            'assets',
          ];

          // Check if the current directory is a common subdirectory
          const dirName = path.basename(currentDir);
          if (commonSubdirs.includes(dirName)) {
            // Move up one level if we're in a common subdirectory
            currentDir = path.dirname(currentDir);
          }

          // Check for manifest file
          const manifestPath = path.join(currentDir, 'fxmanifest.lua');
          if (fs.existsSync(manifestPath)) {
            resourceName = path.basename(currentDir);
            manifestFound = true;
          }

          // If we didn't find a manifest, walk up the directory tree
          if (!manifestFound) {
            // Get the relative path from the generated directory
            const relativePath = path.relative(generatedDir, filePath);
            const pathParts = relativePath.split(path.sep);

            // First, try to find a manifest file by walking up the directory tree
            let resourcePath = '';
            for (let i = 0; i < pathParts.length - 1; i++) {
              // Build the path incrementally
              resourcePath = path.join(resourcePath, pathParts[i]);
              const fullResourcePath = path.join(generatedDir, resourcePath);
              const manifestPath = path.join(
                fullResourcePath,
                'fxmanifest.lua'
              );

              if (fs.existsSync(manifestPath)) {
                // Found a manifest, this is a resource
                resourceName = path.basename(resourcePath);
                manifestFound = true;
                break;
              }
            }

            // If we still didn't find a manifest, try to determine the resource name from the path
            if (!manifestFound) {
              // Try to use the resourceManager to get the resource name
              resourceName = this.resourceManager.getResourceName(filePath);
            }
          }

          // Skip bracketed directory names as they're not actual resources
          if (
            resourceName &&
            resourceName !== 'webview' &&
            resourceName !== 'scripts' &&
            !resourceName.startsWith('[') &&
            !resourceName.endsWith(']')
          ) {
            this.logger.info(
              `Resource change detected in generated folder for '${resourceName}' (will restart after debounce)`
            );
            this.logger.info(`File that triggered change: ${filePath}`);

            // Use the resource debounce time for generated resources to prevent rapid restarts
            this.debouncedTaskManager.execute(
              `generated-resource-${resourceName}`,
              async () => {
                this.logger.info(
                  `Debounced restart for generated resource: ${resourceName}`
                );
                this.logger.info(
                  `Calling restartResource for: ${resourceName}`
                );
                try {
                  await this.resourceManager.restartResource(resourceName);
                  this.logger.info(
                    `Successfully called restartResource for: ${resourceName}`
                  );
                } catch (error) {
                  this.logger.error(
                    `Error restarting resource ${resourceName}:`,
                    error
                  );
                }
              }
            );
          }
        } catch (error) {
          this.logger.error('Error processing file change:', error);
        }
      }
    );

    // Initial scan to build resource map
    this.resourceManager.scanForResources(generatedDir);
    this.logger.info(
      `Initially mapped ${this.resourceManager.getResourceCount()} resources`
    );
  }

  /**
   * Set up all watchers
   */
  setupAllWatchers(
    pluginsDir: string,
    coreDir: string,
    distDir: string,
    rebuildComponent: (
      componentType: 'plugin' | 'core' | 'webview',
      pluginDir?: string
    ) => Promise<void> | void
  ): void {
    // Setup different watchers
    this.setupPluginWatchers(pluginsDir, distDir, rebuildComponent);
    this.setupCoreWatcher(coreDir, distDir, rebuildComponent);
    this.setupWebviewWatcher(pluginsDir, distDir, rebuildComponent);
    this.setupDistWatcher(distDir);
    this.setupGeneratedFolderWatcher();
  }

  /**
   * Get plugin directory from file path
   * @param filePath File path
   * @param pluginsDir Plugins directory
   * @returns Plugin directory
   */
  private getPluginDirFromFilePath(
    filePath: string,
    pluginsDir: string
  ): string | null {
    // Normalize paths
    const normalizedFilePath = path.normalize(filePath);
    const normalizedPluginsDir = path.normalize(pluginsDir);

    // Check if the file is in the plugins directory
    if (!normalizedFilePath.startsWith(normalizedPluginsDir)) {
      return null;
    }

    // Get the relative path from the plugins directory
    const relativePath = path.relative(
      normalizedPluginsDir,
      normalizedFilePath
    );

    // Split the relative path into parts
    const pathParts = relativePath.split(path.sep);

    // Skip if this is in a pure container directory (like '[misc]')
    if (
      pathParts.length > 0 &&
      pathParts[0].startsWith('[') &&
      pathParts[0].endsWith(']') &&
      pathParts.length === 1
    ) {
      this.logger.debug(
        `Skipping restart for '${pathParts[0]}' as it appears to be a directory container, not a resource`
      );
      return null;
    }

    // Find the actual plugin directory (first non-container directory)
    let pluginDir = normalizedPluginsDir;
    for (const part of pathParts) {
      pluginDir = path.join(pluginDir, part);

      // Stop at the first directory that contains actual plugin files
      if (!part.startsWith('[') || !part.endsWith(']')) {
        break;
      }
    }

    return pluginDir;

    // Get the first directory in the relative path
    const parts = relativePath.split(path.sep);

    if (parts.length === 0) {
      return null;
    }

    // Return the plugin directory
    return path.join(normalizedPluginsDir, parts[0]);
  }
}


================================================================================

# .\utils\fs\index.ts

/**
 * File system utilities index
 * Exports all file system utilities from a single entry point
 */

// Export the FileSystemImpl implementation
export { FileSystemImpl } from './FileSystemImpl.js';

// Export path utilities
export * from './PathUtils.js';

// Export plugin utilities
export * from './PluginUtils.js';

// Export script utilities
export * from './ScriptUtils.js';

// Export configuration utilities
export * from './ConfigUtils.js';

// Export logging utilities
export * from './LogUtils.js';

// Export process utilities
export * from './ProcessUtils.js';

// Export HTML utilities
export * from './HtmlUtils.js';

// Export Resource Manager
export * from './ResourceManager.js';

// Export Watcher Manager
export * from './WatcherManager.js';

// Export Debounced Task Manager
export * from './DebouncedTaskManager.js';

// Export Rebuild Utilities
export * from './RebuildUtils.js';

// Create and export a singleton instance of FileSystemImpl for convenience
import { FileSystemImpl } from './FileSystemImpl.js';
export const fileSystem = new FileSystemImpl();


================================================================================

# .\utils\logger\ConsoleLogger.ts

/**
 * Console logger implementation
 */
import { Logger } from '../../core/types.js';

/**
 * Log levels
 */
export enum LogLevel {
  Debug = 0,
  Info = 1,
  Warn = 2,
  Error = 3,
}

/**
 * Console logger options
 */
export interface ConsoleLoggerOptions {
  /** Minimum log level to display */
  minLevel?: LogLevel;
  /** Whether to include timestamps */
  timestamps?: boolean;
  /** Whether to use colors */
  colors?: boolean;
}

/**
 * Console logger implementation
 */
export class ConsoleLogger implements Logger {
  private minLevel: LogLevel;
  private timestamps: boolean;
  private colors: boolean;

  /**
   * Create a new console logger
   * @param options Logger options
   */
  constructor(options: ConsoleLoggerOptions = {}) {
    this.minLevel = options.minLevel ?? LogLevel.Debug;
    this.timestamps = options.timestamps ?? true;
    this.colors = options.colors ?? true;
  }

  /**
   * Format a log message
   * @param level Log level
   * @param message Message to log
   * @param args Additional arguments
   * @returns Formatted message
   */
  private format(level: LogLevel, message: string, args: any[]): string {
    const timestamp = this.timestamps ? `[${new Date().toISOString()}] ` : '';
    const levelStr = LogLevel[level].toUpperCase();
    const levelFormatted = this.formatLevel(level, levelStr);
    
    // Format the message
    let formattedMessage = `${timestamp}${levelFormatted}: ${message}`;
    
    // Add additional arguments if any
    if (args.length > 0) {
      formattedMessage += ' ' + args.map(arg => {
        if (typeof arg === 'object') {
          return JSON.stringify(arg, null, 2);
        }
        return String(arg);
      }).join(' ');
    }
    
    return formattedMessage;
  }

  /**
   * Format a log level
   * @param level Log level
   * @param levelStr String representation of the log level
   * @returns Formatted log level
   */
  private formatLevel(level: LogLevel, levelStr: string): string {
    if (!this.colors) {
      return levelStr;
    }

    // ANSI color codes
    const reset = '\x1b[0m';
    let color = '';

    switch (level) {
      case LogLevel.Debug:
        color = '\x1b[36m'; // Cyan
        break;
      case LogLevel.Info:
        color = '\x1b[32m'; // Green
        break;
      case LogLevel.Warn:
        color = '\x1b[33m'; // Yellow
        break;
      case LogLevel.Error:
        color = '\x1b[31m'; // Red
        break;
    }

    return `${color}${levelStr}${reset}`;
  }

  /**
   * Log a debug message
   * @param message Message to log
   * @param args Additional arguments
   */
  debug(message: string, ...args: any[]): void {
    if (this.minLevel <= LogLevel.Debug) {
      console.debug(this.format(LogLevel.Debug, message, args));
    }
  }

  /**
   * Log an info message
   * @param message Message to log
   * @param args Additional arguments
   */
  info(message: string, ...args: any[]): void {
    if (this.minLevel <= LogLevel.Info) {
      console.info(this.format(LogLevel.Info, message, args));
    }
  }

  /**
   * Log a warning message
   * @param message Message to log
   * @param args Additional arguments
   */
  warn(message: string, ...args: any[]): void {
    if (this.minLevel <= LogLevel.Warn) {
      console.warn(this.format(LogLevel.Warn, message, args));
    }
  }

  /**
   * Log an error message
   * @param message Message to log
   * @param args Additional arguments
   */
  error(message: string, ...args: any[]): void {
    if (this.minLevel <= LogLevel.Error) {
      console.error(this.format(LogLevel.Error, message, args));
    }
  }
}


================================================================================

# .\utils\webview.ts

import * as path from 'path';
import { Plugin } from '../core/types.js';
import { fileSystem, generateSimpleHtmlContent } from './fs/index.js';
import { spawn } from 'child_process';

/**
 * Builds the webview UI by generating App.tsx and running the Vite build.
 * @param plugins Array of plugin objects
 * @param distDir The main distribution directory
 * @returns Promise<string> Path to the built webview directory
 */
export async function buildWebview(
  plugins: Plugin[],
  distDir: string
): Promise<string> {
  console.log('\nBuilding webview UI...');

  // Validate inputs
  if (!Array.isArray(plugins)) {
    throw new Error('Plugins must be an array');
  }

  if (!distDir) {
    throw new Error('Distribution directory must be provided');
  }

  // Path to the webview directory
  const webviewDir = path.join(process.cwd(), 'src/webview');
  const webviewDistDir = path.join(distDir, 'webview');

  try {
    // Verify webview source directory exists
    if (!(await fileSystem.exists(webviewDir))) {
      throw new Error(`Webview directory not found: ${webviewDir}`);
    }

    // Make sure the output directory exists (Vite will clean it)
    await fileSystem.ensureDir(webviewDistDir);

    // Find plugins with webview pages - we'll use Promise.all below instead of this filter
    // since async filters don't work as expected

    // Resolve the promises in the filter
    const resolvedWebviewPlugins = await Promise.all(
      plugins
        .filter((plugin) => plugin.hasHtml && plugin.fullPath)
        .map(async (plugin) => {
          const pageFile = path.join(plugin.fullPath!, 'html', 'Page.tsx');
          if (await fileSystem.exists(pageFile)) {
            return plugin;
          }
          return null;
        })
    );

    // Filter out null values
    const validWebviewPlugins = resolvedWebviewPlugins.filter(
      Boolean
    ) as Plugin[];

    console.log(
      `Found ${validWebviewPlugins.length} plugins with webview pages`
    );

    if (validWebviewPlugins.length === 0) {
      console.log('No webview plugins found, skipping App.tsx generation');
      return webviewDistDir;
    }

    // Set up directories - src directory is where the App.tsx and other files will be generated
    const srcDir = path.join(webviewDir, 'src');
    await fileSystem.ensureDir(srcDir);

    // Generate App.tsx content
    let appContent = `// Auto-generated by cli: webview:build
// Generated on: ${new Date().toISOString()}\n\n`;

    const imports: string[] = [];
    const components: string[] = [];

    // Track used import names to avoid duplicates
    const usedImportNames = new Set<string>();

    for (const plugin of validWebviewPlugins) {
      if (!plugin.fullPath) continue;

      const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

      // Calculate relative path from src directory (Vite root) to the Page.tsx file
      // We need to make the import path relative to the src/webview/src directory
      const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');
      // Make sure the path is properly formatted for import
      // If the path doesn't start with '.', it's not a relative path, so make it one
      const formattedImportPath = importPath.startsWith('.')
        ? importPath
        : `../../${importPath}`;

      // Get the plugin's path relative to plugins directory
      const relPlugin = plugin.pathFromPluginsDir;
      const parts = relPlugin.split('/');
      const namespace = parts.length > 1 ? parts[0] : '';
      const pluginName = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

      // Clean up namespace and plugin name
      const nsClean = namespace.replace(/[\[\]\(\)\s-]/g, '');
      const pluginNameClean = pluginName
        .replace(/[\[\]\(\)\s]/g, '')
        .replace(/-/g, '_');

      // Create unique import name
      let importName = namespace
        ? `Page_${nsClean}_${pluginNameClean}`
        : `Page_${pluginNameClean}`;

      // Ensure import name is unique
      let counter = 1;
      let baseImportName = importName;
      while (usedImportNames.has(importName)) {
        importName = `${baseImportName}_${counter++}`;
      }
      usedImportNames.add(importName);

      // Create a key for React component - ensure it's unique and valid
      const key = namespace ? `${nsClean}/${pluginName}` : pluginName;

      imports.push(`import ${importName} from '${formattedImportPath}';`);
      components.push(`      <${importName} key="${key}" />`);
    }

    // Add imports
    appContent += imports.join('\n') + '\n\n';

    // Create App component
    appContent += `const App = () => {
  return (
    <>
${components.join('\n')}
    </>
  );
};

export default App;\n`;

    // Write generated content to App.tsx
    const appFilePath = path.join(srcDir, 'App.tsx');
    await fileSystem.writeFile(appFilePath, appContent);
    console.log(`Generated ${appFilePath}`);

    // Create main.tsx file
    const mainTsxContent = `
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const mainTsxPath = path.join(srcDir, 'main.tsx');
    await fileSystem.writeFile(mainTsxPath, mainTsxContent);
    console.log(`Generated ${mainTsxPath}`);

    // Create or verify index.html
    const indexHtmlPath = path.join(srcDir, 'index.html');
    const indexHtmlExists = await fileSystem.exists(indexHtmlPath);

    if (!indexHtmlExists) {
      const indexHtmlContent = generateSimpleHtmlContent(
        'Webview',
        './main.tsx'
      );
      await fileSystem.writeFile(indexHtmlPath, indexHtmlContent);
      console.log(`Generated ${indexHtmlPath}`);
    } else {
      // File exists, check if it has the correct main.tsx reference
      const indexHtmlContent = await fileSystem.readFile(indexHtmlPath, 'utf8');
      if (
        !indexHtmlContent.includes('./main.tsx') &&
        (indexHtmlContent.includes('/webview/main.tsx') ||
          indexHtmlContent.includes('"/main.tsx"'))
      ) {
        // Fix the path
        const updatedContent = indexHtmlContent
          .replace(/["']\/webview\/main\.tsx["']/g, '"./main.tsx"')
          .replace(/["']\/main\.tsx["']/g, '"./main.tsx"');

        await fileSystem.writeFile(indexHtmlPath, updatedContent);
        console.log(`Updated ${indexHtmlPath} with correct main.tsx path`);
      }
    }

    // Create index.css if it doesn't exist
    const indexCssPath = path.join(srcDir, 'index.css');
    const indexCssExists = await fileSystem.exists(indexCssPath);

    if (!indexCssExists) {
      // Create a basic CSS file
      const indexCssContent = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.h-dvh {
  height: 100dvh;
}
`;
      await fileSystem.writeFile(indexCssPath, indexCssContent);
      console.log(`Generated ${indexCssPath}`);
    }

    // Run Vite build - it will output directly to distDir/webview per vite.config.ts
    console.log('Running Vite build...');
    try {
      // Always run Vite build directly to avoid recursion
      const buildCommand = 'npx vite build';
      console.log(`Executing: ${buildCommand}`);

      // use spawn to stream logs without buffering large output
      const child = spawn(buildCommand, {
        cwd: process.cwd(),
        shell: true,
        stdio: 'inherit',
      });
      await new Promise<void>((resolve, reject) => {
        child.on('close', (code) =>
          code === 0
            ? resolve()
            : reject(new Error(`Build command failed with exit code ${code}`))
        );
      });
    } catch (error: any) {
      console.error('Vite build failed:', error);

      // Add more helpful error information
      let errorMessage = `Vite build failed: ${error?.message || error}`;

      // Check if index.html exists and has correct format
      const indexHtmlPath = path.join(srcDir, 'index.html');
      if (await fileSystem.exists(indexHtmlPath)) {
        try {
          const indexHtmlContent = await fileSystem.readFile(
            indexHtmlPath,
            'utf8'
          );

          if (
            !indexHtmlContent.includes('./main.tsx') &&
            !indexHtmlContent.includes('main.tsx')
          ) {
            errorMessage +=
              '\nPossible cause: index.html does not reference main.tsx correctly.';
          }
        } catch (err) {
          errorMessage +=
            '\nPossible cause: index.html exists but cannot be read.';
        }
      } else {
        errorMessage += '\nPossible cause: index.html does not exist.';
      }

      throw new Error(errorMessage);
    }

    console.log('Webview build completed successfully!');
    return webviewDistDir;
  } catch (error) {
    console.error('Webview build failed:', error);
    throw error;
  }
}

/**
 * Builds a webview UI for a single plugin by generating App.tsx and running the Vite build.
 * @param plugin The plugin object to build the webview for
 * @param distDir The main distribution directory
 * @returns Promise<{ htmlDir: string; hasIndexHtml: boolean; hasAssets: boolean; success: boolean }>
 * Object containing the html directory path and verification results
 */
export async function buildPluginWebview(
  plugin: Plugin,
  distDir: string
): Promise<{
  htmlDir: string;
  hasIndexHtml: boolean;
  hasAssets: boolean;
  success: boolean;
}> {
  console.log(
    `\nBuilding webview UI for plugin: ${
      plugin.name || plugin.pathFromPluginsDir || 'unknown'
    }...`
  );

  // Validate inputs
  if (!plugin) {
    throw new Error('Plugin must be provided');
  }

  if (!distDir) {
    throw new Error('Distribution directory must be provided');
  }

  // Path to the webview directory
  const webviewDir = path.join(process.cwd(), 'src/webview');

  // Determine the plugin's resource path in the dist directory
  let resourcePath;
  let pluginRelativePath;

  if (plugin.pathFromPluginsDir) {
    // Check if the path starts with 'plugins/' and strip it if needed
    const normalizedPluginPath = path.normalize(plugin.pathFromPluginsDir);
    const pluginsPathNormalized = path.normalize('plugins');
    const pathContainsPluginsPrefix =
      normalizedPluginPath.startsWith(pluginsPathNormalized) ||
      normalizedPluginPath.startsWith(pluginsPathNormalized + path.sep);

    if (pathContainsPluginsPrefix) {
      // Strip the 'plugins/' prefix to place resources directly in dist
      pluginRelativePath = path.relative(
        pluginsPathNormalized,
        normalizedPluginPath
      );
      console.log(
        `Webview: Stripped 'plugins/' prefix from path: ${normalizedPluginPath} -> ${pluginRelativePath}`
      );
    } else {
      pluginRelativePath = normalizedPluginPath;
    }

    // Convert the plugin path to a resource path in dist
    // For example: "[misc]/example" -> "dist/[misc]/example"
    resourcePath = path.join(distDir, pluginRelativePath);
  } else if (plugin.fullPath) {
    // Extract resource name from fullPath if possible
    const pluginDir = path.basename(plugin.fullPath);
    resourcePath = path.join(distDir, pluginDir);
    pluginRelativePath = pluginDir;
  } else {
    // Fallback to name if nothing else is available
    resourcePath = path.join(distDir, plugin.name);
    pluginRelativePath = plugin.name;
  }

  // Create the html directory within the resource where webview files will be placed
  const htmlOutputDir = path.join(resourcePath, 'html');

  // Extract plugin path parts for the build output directory
  const pluginDistPathParts = pluginRelativePath
    ? pluginRelativePath.split('/')
    : [plugin.name];

  console.log('Plugin path parts for webview build:', pluginDistPathParts);

  // This is where Vite will directly output the build
  const webviewPluginDistDir = path.join(distDir, ...pluginDistPathParts);
  console.log('Webview plugin dist directory:', webviewPluginDistDir);

  try {
    // Verify webview source directory exists
    if (!(await fileSystem.exists(webviewDir))) {
      throw new Error(`Webview directory not found: ${webviewDir}`);
    }

    // Make sure the output directory exists
    await fileSystem.ensureDir(webviewPluginDistDir);

    // Check if plugin has a webview page
    if (!plugin.hasHtml || !plugin.fullPath) {
      console.log('Plugin does not have webview pages, skipping build');
      return {
        htmlDir: webviewPluginDistDir,
        hasIndexHtml: false,
        hasAssets: false,
        success: false,
      };
    }

    const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

    if (!(await fileSystem.exists(pageFile))) {
      console.log('Plugin does not have a Page.tsx file, skipping build');
      return {
        htmlDir: webviewPluginDistDir,
        hasIndexHtml: false,
        hasAssets: false,
        success: false,
      };
    }

    console.log(`Found webview page for plugin: ${pageFile}`);

    // Set up directories - src directory is where the App.tsx and other files will be generated
    const srcDir = path.join(webviewDir, 'src');
    await fileSystem.ensureDir(srcDir);

    // Generate App.tsx content for this single plugin
    let appContent = `// Auto-generated by cli: webview:buildPlugin
// Generated on: ${new Date().toISOString()}\n\n`;

    // Calculate relative path from src directory to the Page.tsx file
    const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');
    const formattedImportPath = importPath.startsWith('.')
      ? importPath
      : `../../${importPath}`;

    // Get unique import name for this plugin
    let relPlugin = '';

    // Use pathFromPluginsDir if available, otherwise use name
    if (plugin.pathFromPluginsDir) {
      relPlugin = plugin.pathFromPluginsDir;
    } else if (plugin.name) {
      relPlugin = plugin.name.replace(/[^a-zA-Z0-9_-]/g, '_');
    }

    const parts = relPlugin.split('/');
    const namespace = parts.length > 1 ? parts[0] : '';
    const pluginName = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

    // Clean up namespace and plugin name
    const nsClean = namespace.replace(/[\[\]\(\)\s-]/g, '');
    const pluginNameClean = pluginName
      .replace(/[\[\]\(\)\s]/g, '')
      .replace(/-/g, '_');

    // Create import name
    const importName = namespace
      ? `Page_${nsClean}_${pluginNameClean}`
      : `Page_${pluginNameClean}`;

    // Create a key for React component
    const key = namespace ? `${nsClean}/${pluginName}` : pluginName;

    // Add the import
    appContent += `import ${importName} from '${formattedImportPath}';\n\n`;

    // Create App component that only includes this plugin
    appContent += `const App = () => {
  return (
    <>
      <${importName} key="${key}" />
    </>
  );
};

export default App;\n`;

    // Write generated content to App.tsx
    const appFilePath = path.join(srcDir, 'App.tsx');
    await fileSystem.writeFile(appFilePath, appContent);
    console.log(`Generated ${appFilePath}`);

    // Create main.tsx file (same as in buildWebview)
    const mainTsxContent = `
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const mainTsxPath = path.join(srcDir, 'main.tsx');
    await fileSystem.writeFile(mainTsxPath, mainTsxContent);
    console.log(`Generated ${mainTsxPath}`);

    // Create or verify index.html
    const indexHtmlPath = path.join(srcDir, 'index.html');
    const indexHtmlExists = await fileSystem.exists(indexHtmlPath);

    if (!indexHtmlExists) {
      const indexHtmlContent = generateSimpleHtmlContent(
        `Plugin Webview - ${plugin.name || relPlugin}`,
        './main.tsx'
      );
      await fileSystem.writeFile(indexHtmlPath, indexHtmlContent);
      console.log(`Generated ${indexHtmlPath}`);
    } else {
      // File exists, check if it has the correct main.tsx reference
      const indexHtmlContent = await fileSystem.readFile(indexHtmlPath, 'utf8');
      if (
        !indexHtmlContent.includes('./main.tsx') &&
        (indexHtmlContent.includes('/webview/main.tsx') ||
          indexHtmlContent.includes('"/main.tsx"'))
      ) {
        // Fix the path
        const updatedContent = indexHtmlContent
          .replace(/["']\/webview\/main\.tsx["']/g, '"./main.tsx"')
          .replace(/["']\/main\.tsx["']/g, '"./main.tsx"');

        await fileSystem.writeFile(indexHtmlPath, updatedContent);
        console.log(`Updated ${indexHtmlPath} with correct main.tsx path`);
      }
    }

    // Create index.css if it doesn't exist
    const indexCssPath = path.join(srcDir, 'index.css');
    const indexCssExists = await fileSystem.exists(indexCssPath);

    if (!indexCssExists) {
      // Create a basic CSS file
      const indexCssContent = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.h-dvh {
  height: 100dvh;
}
`;
      await fileSystem.writeFile(indexCssPath, indexCssContent);
      console.log(`Generated ${indexCssPath}`);
    }

    // Run Vite build directly to the plugin's directory
    console.log(`Running Vite build for plugin: ${relPlugin}...`);
    try {
      // Build directly to the plugin's html directory
      const buildCommand = `npx vite build --outDir=${htmlOutputDir}`;
      console.log(`Executing: ${buildCommand}`);

      // Use spawn to stream logs without buffering large output
      const child = spawn(buildCommand, {
        cwd: process.cwd(),
        shell: true,
        stdio: 'inherit',
        env: {
          ...process.env,
          PLUGIN_WEBVIEW_ID: relPlugin, // Can be used in vite.config.ts to customize the build
        },
      });
      await new Promise<void>((resolve, reject) => {
        child.on('close', (code) =>
          code === 0
            ? resolve()
            : reject(new Error(`Build command failed with exit code ${code}`))
        );
      });

      console.log(`Webview built successfully at: ${htmlOutputDir}`);

      // List files in the output directory
      const filePaths = fileSystem.getFilePaths(htmlOutputDir);

      // Log the contents for verification
      for (const filePath of filePaths) {
        const relativePath = path.relative(htmlOutputDir, filePath);
        console.log(`  [FILE] ${relativePath}`);
      }

      // Verify that the html directory contains the expected files
      const hasIndexHtml = filePaths.some(
        (file) => path.basename(file) === 'index.html'
      );
      const hasAssets = filePaths.some((file) => file.includes('assets/'));

      if (!hasIndexHtml) {
        console.warn(`Warning: No index.html found in ${htmlOutputDir}`);
      }

      if (!hasAssets) {
        console.warn(`Warning: No assets directory found in ${htmlOutputDir}`);
      }

      console.log(`--- End verification of ${webviewPluginDistDir} ---`);

      // Return an object with the html directory path and verification results
      return {
        htmlDir: htmlOutputDir,
        hasIndexHtml,
        hasAssets,
        success: hasIndexHtml, // Consider the build successful if at least index.html exists
      };
    } catch (error: any) {
      console.error(`Vite build for plugin ${relPlugin} failed:`, error);

      // Add more helpful error information
      let errorMessage = `Vite build for plugin ${relPlugin} failed: ${
        error?.message || error
      }`;

      // Check if index.html exists and has correct format
      if (await fileSystem.exists(indexHtmlPath)) {
        try {
          const indexHtmlContent = await fileSystem.readFile(
            indexHtmlPath,
            'utf8'
          );
          if (
            !indexHtmlContent.includes('./main.tsx') &&
            !indexHtmlContent.includes('main.tsx')
          ) {
            errorMessage +=
              '\nPossible cause: index.html does not reference main.tsx correctly.';
          }
        } catch (err) {
          errorMessage +=
            '\nPossible cause: index.html exists but cannot be read.';
        }
      } else {
        errorMessage += '\nPossible cause: index.html does not exist.';
      }

      // Return failure result
      return {
        htmlDir: htmlOutputDir,
        hasIndexHtml: false,
        hasAssets: false,
        success: false,
      };
    }
  } catch (error) {
    console.error(
      `Plugin webview build for ${
        plugin.pathFromPluginsDir || plugin.name || 'unknown'
      } failed:`,
      error
    );
    // Return failure result instead of throwing
    return {
      htmlDir:
        webviewPluginDistDir ||
        path.join(distDir, plugin.name || 'unknown', 'html'),
      hasIndexHtml: false,
      hasAssets: false,
      success: false,
    };
  }
}
/**
 * Copy built webview files to the resource's html directory
 * @param sourceBuildDir Source directory containing the Vite build output
 * @param targetHtmlDir Target html directory within the resource
 * @returns Promise that resolves when the copy operation is complete
 */
export async function copyBuildToResourceHtml(
  sourceBuildDir: string,
  targetHtmlDir: string
): Promise<void> {
  // Make sure target directory exists
  await fileSystem.ensureDir(targetHtmlDir);

  // Read all files from the source build directory
  const copyDir = async (src: string, dest: string) => {
    // Get all files in the source directory
    const filePaths = fileSystem.getFilePaths(src);

    for (const filePath of filePaths) {
      // Calculate the relative path from the source directory
      const relativePath = path.relative(src, filePath);
      // Calculate the destination path
      const destPath = path.join(dest, relativePath);

      // Ensure the destination directory exists
      await fileSystem.ensureDir(path.dirname(destPath));

      // Copy the file
      await fileSystem.copyFile(filePath, destPath);
    }
  };

  try {
    await copyDir(sourceBuildDir, targetHtmlDir);
    console.log(
      `Successfully copied webview files from ${sourceBuildDir} to ${targetHtmlDir}`
    );
  } catch (error) {
    console.error(`Error copying webview files:`, error);
    throw error;
  }
}


--------------------------------------------------------------------------------
Total TypeScript files found: 42
