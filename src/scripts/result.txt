# .\index.ts

import { FileManager } from './managers/FileManager.js';
import { ManifestManager } from './managers/ManifestManager.js';
import { PluginManager } from './managers/PluginManager.js';
import { BuildManager } from './managers/BuildManager.js';
import { Plugin } from './types/Plugin.js';
import { File } from './types/File.js';
import { PluginManifest } from './types/Manifest.js';

/**
 * Plugin Explorer Demo
 *
 * Demonstrates how to:
 * 1. Get all plugins
 * 2. Get all files from all plugins
 * 3. Load and display plugin manifests with formatted output
 * 4. Build plugins to distribution directory
 */
async function main() {
  try {
    // Create a horizontal divider with title
    const createDivider = (title: string) => {
      const divider = '='.repeat(80);
      const paddedTitle = ` ${title} `;
      // Center the title in the divider
      const startPos = Math.floor((divider.length - paddedTitle.length) / 2);
      const titleDivider =
        divider.substring(0, startPos) +
        paddedTitle +
        divider.substring(startPos + paddedTitle.length);
      console.log('\n' + titleDivider + '\n');
    };

    createDivider('PLUGIN EXPLORER DEMO');

    // Initialize the managers
    console.log('Initializing managers...');

    const pluginsPath = 'src/plugins';
    const fileManager = new FileManager(pluginsPath);
    await fileManager.initialize();

    const manifestManager = new ManifestManager(fileManager);
    await manifestManager.initialize();

    const pluginManager = new PluginManager(fileManager);
    await pluginManager.initialize();

    const buildManager = new BuildManager(fileManager);
    await buildManager.initialize();

    console.log('‚úì All managers initialized successfully\n');

    // 1. Get all plugins with formatted output
    createDivider('ALL PLUGINS');

    const allPlugins = pluginManager.getAllPlugins();

    if (allPlugins.length === 0) {
      console.log('No plugins found in the system.');
    } else {
      console.log(`Found ${allPlugins.length} plugins in the system:\n`);

      // Convert to table-friendly format
      const pluginTableData = allPlugins.map((plugin, index) => {
        return {
          '#': index + 1,
          'Name': plugin.pluginName,
          'Path': plugin.displayPath,
          'Parent Folders': plugin.parents.join(', ') || 'None',
          'Files Count': plugin.files.length,
        };
      });

      console.table(pluginTableData);
    }

    // 2. Get all files of all plugins with formatted output
    createDivider('ALL FILES FROM ALL PLUGINS');

    let totalFiles = 0;
    let filesByType = new Map<string, number>();

    // Display files for each plugin
    for (const plugin of allPlugins) {
      console.log(`\nüìÅ Plugin: ${plugin.pluginName} (${plugin.displayPath})`);

      if (plugin.files.length === 0) {
        console.log('  No files found in this plugin.');
        continue;
      }

      // Group files by directory (relative to plugin root)
      const filesByDirectory = new Map<string, File[]>();

      plugin.files.forEach((file) => {
        // Get the relative path within the plugin
        const relativePath = file.displayPath.replace(
          `${plugin.displayPath}/`,
          ''
        );
        // Get directory name
        const dirName = relativePath.includes('/')
          ? relativePath.substring(0, relativePath.lastIndexOf('/'))
          : '(root)';

        if (!filesByDirectory.has(dirName)) {
          filesByDirectory.set(dirName, []);
        }
        filesByDirectory.get(dirName)?.push(file);

        // Count files by extension
        const extension = file.fileName.includes('.')
          ? file.fileName.substring(file.fileName.lastIndexOf('.') + 1)
          : 'unknown';
        filesByType.set(extension, (filesByType.get(extension) || 0) + 1);
      });

      // Print files grouped by directory
      for (const [dirName, files] of filesByDirectory.entries()) {
        console.log(`  üìÇ ${dirName} (${files.length} files):`);
        files.forEach((file) => {
          console.log(`    üìÑ ${file.fileName}`);
        });
      }

      totalFiles += plugin.files.length;
    }

    // Print summary
    console.log(`\nTotal files across all plugins: ${totalFiles}`);
    console.log('Files by type:');
    for (const [extension, count] of filesByType.entries()) {
      console.log(`  .${extension}: ${count} files`);
    }

    // 3. Display manifests for all plugins
    createDivider('PLUGIN MANIFESTS');

    for (const plugin of allPlugins) {
      console.log(`\nüì¶ Plugin: ${plugin.pluginName} (${plugin.displayPath})`);

      // Get the manifest
      const manifest = await manifestManager.getManifest(plugin.fullPath);

      if (!manifest) {
        console.log('  ‚ö†Ô∏è No manifest found for this plugin.');
        continue;
      }

      console.log('  üìã Manifest Contents:');
      console.log('  --------------------------------------------------');

      // Display core metadata with proper formatting
      const displayManifestField = (label: string, value: any) => {
        if (value !== undefined && value !== null) {
          if (Array.isArray(value)) {
            console.log(`  üìå ${label}: `);
            value.forEach((item: any) => console.log(`    - ${item}`));
          } else if (typeof value === 'object') {
            console.log(`  üìå ${label}: `);
            Object.entries(value).forEach(([k, v]) =>
              console.log(`    - ${k}: ${v}`)
            );
          } else {
            console.log(`  üìå ${label}: ${value}`);
          }
        }
      };

      // Core metadata
      displayManifestField('Name', manifest.name);
      displayManifestField('Version', manifest.version);
      displayManifestField('Description', manifest.description);
      displayManifestField('Author', manifest.author);
      displayManifestField('FX Version', manifest.fx_version);

      // Scripts
      displayManifestField('Client Scripts', manifest.client_scripts);
      displayManifestField('Server Scripts', manifest.server_scripts);
      displayManifestField('Shared Scripts', manifest.shared_scripts);

      // Dependencies and games
      displayManifestField('Games', manifest.games);
      displayManifestField('Dependencies', manifest.dependencies);

      // Additional metadata (excluding already displayed fields)
      const displayedFields = [
        'name',
        'version',
        'description',
        'author',
        'fx_version',
        'client_scripts',
        'server_scripts',
        'shared_scripts',
        'games',
        'dependencies',
      ];

      const otherFields = Object.entries(manifest).filter(
        ([key]) => !displayedFields.includes(key)
      );

      if (otherFields.length > 0) {
        console.log('\n  üìå Additional Properties:');
        otherFields.forEach(([key, value]) => {
          if (typeof value === 'object' && value !== null) {
            console.log(`    - ${key}: ${JSON.stringify(value)}`);
          } else {
            console.log(`    - ${key}: ${value}`);
          }
        });
      }

      console.log('  --------------------------------------------------');
    }

    // 4. Demonstrate the plugin build process
    createDivider('PLUGIN BUILD DEMONSTRATION');

    // First, clean the dist directory
    console.log('Cleaning distribution directory...');
    await buildManager.clean();
    console.log('‚úì Distribution directory cleaned\n');

    // Build a specific plugin if any exists
    if (allPlugins.length > 0) {
      const firstPlugin = allPlugins[0];
      console.log(`\nüõ†Ô∏è Preparing to build plugin: ${firstPlugin.pluginName}`);

      // Reload the plugin to ensure its info is up to date
      try {
        console.log(`Reloading plugin: ${firstPlugin.pluginName}`);
        await pluginManager.reloadPlugin(firstPlugin.pluginName);
        console.log(`‚úì Plugin ${firstPlugin.pluginName} reloaded successfully`);
      } catch (reloadError) {
        const errorMessage =
          reloadError instanceof Error
            ? reloadError.message
            : String(reloadError);
        console.error(
          `Failed to reload plugin ${firstPlugin.pluginName}: ${errorMessage}`
        );
        throw reloadError; // Re-throw to halt execution if reloading fails
      }

      // Show build process for specific file types
      console.log('\nBuilding by file type:');
      console.log('----------------------');

      await buildManager.buildPluginJson(firstPlugin);
      await buildManager.buildPluginLua(firstPlugin);
      await buildManager.buildPluginTs(firstPlugin);
      await buildManager.buildPluginJs(firstPlugin);
      await buildManager.buildPluginPageTsx(firstPlugin);

      console.log('\n‚úì Individual file type builds completed');

      // Build first plugin completely in one go
      console.log(`\nüî® Building complete plugin: ${firstPlugin.pluginName}`);
      await buildManager.buildPlugin(firstPlugin.pluginName);
      console.log(`‚úì Complete build of ${firstPlugin.pluginName} finished`);
    }

    // Build all plugins
    console.log('\nüèóÔ∏è Building all plugins...');
    await buildManager.buildAllPlugins();
    console.log('‚úì All plugins built successfully');

    // Count files in dist directory
    const builtPluginsCount = allPlugins.length;
    const filesByExtension = new Map<string, number>();
    allPlugins.forEach((plugin) => {
      plugin.files.forEach((file) => {
        const extension = file.fileName.includes('.')
          ? file.fileName.substring(file.fileName.lastIndexOf('.') + 1)
          : 'unknown';
        filesByExtension.set(
          extension,
          (filesByExtension.get(extension) || 0) + 1
        );
      });
    });

    // Output build statistics
    console.log('\nüìä Build Statistics:');
    console.log(`  Total plugins built: ${builtPluginsCount}`);
    console.log('  Files by extension:');
    for (const [extension, count] of filesByExtension.entries()) {
      console.log(`    .${extension}: ${count} files`);
    }

    createDivider('DEMO COMPLETE');
    console.log('Plugin Explorer demo finished successfully. Summary:');
    console.log(`‚úì Scanned ${allPlugins.length} plugins`);
    console.log(`‚úì Found ${totalFiles} total files`);
    console.log(`‚úì Displayed ${allPlugins.length} manifests`);
    console.log(
      `‚úì Built ${builtPluginsCount} plugins to distribution directory`
    );
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('\n‚ùå ERROR: ' + errorMessage);

    if (error instanceof Error && error.stack) {
      console.error('\nStack trace:');
      console.error(error.stack);
    }
  }
}

// Execute the main function
main().catch((error) => {
  console.error('‚ùå FATAL ERROR:', error);
  process.exit(1);
});


================================================================================

# .\managers\BuildManager.ts

import * as fs from 'fs/promises';
import * as fsSync from 'fs';
import * as path from 'path';
import { glob } from 'glob';
import * as esbuild from 'esbuild';
import { spawn } from 'child_process';
import { FileManager } from './FileManager.js';
import { Plugin } from '../types/Plugin.js';
import { File } from '../types/File.js';

/**
 * Build manager
 * This class provides functionality to build plugins by copying files to a dist directory
 */
class BuildManager {
  private fileManager: FileManager;
  private distPath: string;
  private initialized: boolean = false;

  /**
   * Creates a new BuildManager instance
   * @param fileManager The FileManager instance to use for file operations
   * @param distPath Optional path to the distribution directory
   */
  constructor(fileManager: FileManager, distPath: string = 'dist') {
    this.fileManager = fileManager;
    this.distPath = path.resolve(distPath);
  }

  /**
   * Initializes the build manager
   * Must be called before using other methods
   */
  async initialize(): Promise<void> {
    try {
      // Create the dist directory if it doesn't exist
      if (!fsSync.existsSync(this.distPath)) {
        await fs.mkdir(this.distPath, { recursive: true });
      }

      this.initialized = true;
      console.log('BuildManager initialized successfully');
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error('Error initializing BuildManager:', error);
      throw new Error(`Failed to initialize BuildManager: ${errorMessage}`);
    }
  }

  /**
   * Builds a plugin by copying all files to the dist directory
   * @param pluginNameOrPath The name or path of the plugin to build
   */
  async buildPlugin(pluginNameOrPath: string): Promise<void> {
    this.ensureInitialized();

    try {
      // Get the plugin
      const plugin = this.getPluginFromNameOrPath(pluginNameOrPath);

      if (!plugin) {
        throw new Error(`Plugin not found: ${pluginNameOrPath}`);
      }

      console.log(`Building plugin: ${plugin.pluginName}`);

      // Create the destination directory
      const destDir = this.getPluginDestDir(plugin);
      await fs.mkdir(destDir, { recursive: true });

      // Build all file types
      await Promise.all([
        this.buildPluginLua(plugin),
        this.buildPluginJson(plugin),
        this.buildPluginTs(plugin),
        this.buildPluginJs(plugin),
        this.buildPluginPageTsx(plugin),
      ]);

      console.log(
        `‚úì Plugin ${
          plugin.pluginName
        } built successfully to ${this.pathToDisplay(destDir)}`
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(`Error building plugin ${pluginNameOrPath}:`, error);
      throw new Error(
        `Failed to build plugin ${pluginNameOrPath}: ${errorMessage}`
      );
    }
  }

  /**
   * Builds Lua files for a plugin
   * @param pluginNameOrPath The name or path of the plugin, or the Plugin object
   */
  async buildPluginLua(pluginNameOrPath: string | Plugin): Promise<void> {
    this.ensureInitialized();

    try {
      const plugin =
        typeof pluginNameOrPath === 'string'
          ? this.getPluginFromNameOrPath(pluginNameOrPath)
          : pluginNameOrPath;

      if (!plugin) {
        throw new Error(`Plugin not found: ${pluginNameOrPath}`);
      }

      // Get all Lua files
      const luaFiles = plugin.files.filter((file) =>
        file.fileName.endsWith('.lua')
      );

      if (luaFiles.length === 0) {
        console.log(`No Lua files found in plugin ${plugin.pluginName}`);
        return;
      }

      await this.copyFilesToDist(plugin, luaFiles);
      console.log(
        `‚úì Built ${luaFiles.length} Lua file(s) for plugin ${plugin.pluginName}`
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      if (typeof pluginNameOrPath === 'string') {
        console.error(
          `Error building Lua files for plugin ${pluginNameOrPath}:`,
          error
        );
        throw new Error(
          `Failed to build Lua files for plugin ${pluginNameOrPath}: ${errorMessage}`
        );
      } else {
        console.error(
          `Error building Lua files for plugin ${pluginNameOrPath.pluginName}:`,
          error
        );
        throw new Error(
          `Failed to build Lua files for plugin ${pluginNameOrPath.pluginName}: ${errorMessage}`
        );
      }
    }
  }

  /**
   * Builds JSON files for a plugin
   * @param pluginNameOrPath The name or path of the plugin, or the Plugin object
   */
  async buildPluginJson(pluginNameOrPath: string | Plugin): Promise<void> {
    this.ensureInitialized();

    try {
      const plugin =
        typeof pluginNameOrPath === 'string'
          ? this.getPluginFromNameOrPath(pluginNameOrPath)
          : pluginNameOrPath;

      if (!plugin) {
        throw new Error(`Plugin not found: ${pluginNameOrPath}`);
      }

      // Get all JSON files
      const jsonFiles = plugin.files.filter((file) =>
        file.fileName.endsWith('.json')
      );

      if (jsonFiles.length === 0) {
        console.log(`No JSON files found in plugin ${plugin.pluginName}`);
        return;
      }

      await this.copyFilesToDist(plugin, jsonFiles);
      console.log(
        `‚úì Built ${jsonFiles.length} JSON file(s) for plugin ${plugin.pluginName}`
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      if (typeof pluginNameOrPath === 'string') {
        console.error(
          `Error building JSON files for plugin ${pluginNameOrPath}:`,
          error
        );
        throw new Error(
          `Failed to build JSON files for plugin ${pluginNameOrPath}: ${errorMessage}`
        );
      } else {
        console.error(
          `Error building JSON files for plugin ${pluginNameOrPath.pluginName}:`,
          error
        );
        throw new Error(
          `Failed to build JSON files for plugin ${pluginNameOrPath.pluginName}: ${errorMessage}`
        );
      }
    }
  }

  /**
   * Builds TypeScript files for a plugin
   * @param pluginNameOrPath The name or path of the plugin, or the Plugin object
   */
  async buildPluginTs(pluginNameOrPath: string | Plugin): Promise<void> {
    this.ensureInitialized();

    try {
      const plugin =
        typeof pluginNameOrPath === 'string'
          ? this.getPluginFromNameOrPath(pluginNameOrPath)
          : pluginNameOrPath;

      if (!plugin) {
        throw new Error(`Plugin not found: ${pluginNameOrPath}`);
      }

      // Get all TypeScript files (excluding .tsx files which are handled separately)
      const tsFiles = plugin.files.filter(
        (file) =>
          file.fileName.endsWith('.ts') && !file.fileName.endsWith('.tsx')
      );

      if (tsFiles.length === 0) {
        console.log(`No TypeScript files found in plugin ${plugin.pluginName}`);
        return;
      }

      const destDir = this.getPluginDestDir(plugin);

      // Process each TypeScript file
      for (const file of tsFiles) {
        // Get the relative path within the plugin
        const relativePath = path.relative(plugin.fullPath, file.fullPath);

        // Change the extension from .ts to .js for the output file
        const outputRelativePath = relativePath.replace(/\.ts$/, '.js');
        const outputPath = path.join(destDir, outputRelativePath);

        // Create the destination directory if it doesn't exist
        const outputDir = path.dirname(outputPath);
        await fs.mkdir(outputDir, { recursive: true });

        // Determine if this is a server-side script
        const isServerScript = this.isServerScript(file.fullPath);
        const externalPackages = this.getExternalPackages(isServerScript);

        // Configure loader based on file type
        const loader: Record<string, esbuild.Loader> = {
          '.ts': 'ts',
          '.js': 'js',
        };

        console.log(`Bundling TypeScript file: ${relativePath}`);

        try {
          // Bundle the file
          const result = await esbuild.build({
            entryPoints: [file.fullPath],
            bundle: true,
            outfile: outputPath,
            format: 'iife', // Use IIFE format for FiveM compatibility
            target: 'es2017',
            minify: false,
            sourcemap: 'external',
            loader,
            logLevel: 'info',
            external: externalPackages,
            // Use node platform for server scripts, browser platform for client scripts
            platform: isServerScript ? 'node' : 'browser',
          });

          // Check for errors
          if (result.errors.length > 0) {
            console.error(`Errors bundling ${file.fullPath}:`, result.errors);
            throw new Error(
              `Failed to bundle ${file.fullPath}: ${result.errors.join(', ')}`
            );
          }

          // Verify the file was created
          if (!fsSync.existsSync(outputPath)) {
            throw new Error(
              `Failed to verify file exists after bundling: ${outputPath}`
            );
          }
        } catch (bundleError) {
          console.error(
            `Error bundling TypeScript file ${file.fullPath}:`,
            bundleError
          );
          throw bundleError;
        }
      }

      console.log(
        `‚úì Built ${tsFiles.length} TypeScript file(s) for plugin ${plugin.pluginName}`
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      if (typeof pluginNameOrPath === 'string') {
        console.error(
          `Error building TypeScript files for plugin ${pluginNameOrPath}:`,
          error
        );
        throw new Error(
          `Failed to build TypeScript files for plugin ${pluginNameOrPath}: ${errorMessage}`
        );
      } else {
        console.error(
          `Error building TypeScript files for plugin ${pluginNameOrPath.pluginName}:`,
          error
        );
        throw new Error(
          `Failed to build TypeScript files for plugin ${pluginNameOrPath.pluginName}: ${errorMessage}`
        );
      }
    }
  }

  /**
   * Builds JavaScript files for a plugin
   * @param pluginNameOrPath The name or path of the plugin, or the Plugin object
   */
  async buildPluginJs(pluginNameOrPath: string | Plugin): Promise<void> {
    this.ensureInitialized();

    try {
      const plugin =
        typeof pluginNameOrPath === 'string'
          ? this.getPluginFromNameOrPath(pluginNameOrPath)
          : pluginNameOrPath;

      if (!plugin) {
        throw new Error(`Plugin not found: ${pluginNameOrPath}`);
      }

      // Get all JavaScript files (excluding .jsx files)
      const jsFiles = plugin.files.filter(
        (file) =>
          file.fileName.endsWith('.js') && !file.fileName.endsWith('.jsx')
      );

      if (jsFiles.length === 0) {
        console.log(`No JavaScript files found in plugin ${plugin.pluginName}`);
        return;
      }

      const destDir = this.getPluginDestDir(plugin);

      // Process each JavaScript file
      for (const file of jsFiles) {
        // Get the relative path within the plugin
        const relativePath = path.relative(plugin.fullPath, file.fullPath);
        const outputPath = path.join(destDir, relativePath);

        // Create the destination directory if it doesn't exist
        const outputDir = path.dirname(outputPath);
        await fs.mkdir(outputDir, { recursive: true });

        // Determine if this is a server-side script
        const isServerScript = this.isServerScript(file.fullPath);
        const externalPackages = this.getExternalPackages(isServerScript);

        console.log(`Bundling JavaScript file: ${relativePath}`);

        try {
          // Bundle the file
          const result = await esbuild.build({
            entryPoints: [file.fullPath],
            bundle: true,
            outfile: outputPath,
            format: 'iife', // Use IIFE format for FiveM compatibility
            target: 'es2017',
            minify: false,
            sourcemap: 'external',
            external: externalPackages,
            // Use node platform for server scripts, browser platform for client scripts
            platform: isServerScript ? 'node' : 'browser',
          });

          // Check for errors
          if (result.errors.length > 0) {
            console.error(`Errors bundling ${file.fullPath}:`, result.errors);
            throw new Error(
              `Failed to bundle ${file.fullPath}: ${result.errors.join(', ')}`
            );
          }

          // Verify the file was created
          if (!fsSync.existsSync(outputPath)) {
            throw new Error(
              `Failed to verify file exists after bundling: ${outputPath}`
            );
          }
        } catch (bundleError) {
          console.error(
            `Error bundling JavaScript file ${file.fullPath}:`,
            bundleError
          );
          throw bundleError;
        }
      }

      console.log(
        `‚úì Built ${jsFiles.length} JavaScript file(s) for plugin ${plugin.pluginName}`
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      if (typeof pluginNameOrPath === 'string') {
        console.error(
          `Error building JavaScript files for plugin ${pluginNameOrPath}:`,
          error
        );
        throw new Error(
          `Failed to build JavaScript files for plugin ${pluginNameOrPath}: ${errorMessage}`
        );
      } else {
        console.error(
          `Error building JavaScript files for plugin ${pluginNameOrPath.pluginName}:`,
          error
        );
        throw new Error(
          `Failed to build JavaScript files for plugin ${pluginNameOrPath.pluginName}: ${errorMessage}`
        );
      }
    }
  }

  /**
   * Builds TSX (TypeScript JSX) page files for a plugin
   * @param pluginNameOrPath The name or path of the plugin, or the Plugin object
   */
  async buildPluginPageTsx(pluginNameOrPath: string | Plugin): Promise<void> {
    this.ensureInitialized();

    try {
      // Get the plugin object
      const plugin =
        typeof pluginNameOrPath === 'string'
          ? this.getPluginFromNameOrPath(pluginNameOrPath)
          : pluginNameOrPath;

      if (!plugin) {
        throw new Error(`Plugin not found: ${pluginNameOrPath}`);
      }

      // Find the Page.tsx file in the html directory
      const pageTsxFile = plugin.files.find(
        (file) =>
          file.fileName === 'Page.tsx' &&
          (file.fullPath.includes('/html/') ||
            file.fullPath.includes('\\html\\'))
      );

      if (!pageTsxFile) {
        console.log(`No Page.tsx file found in plugin ${plugin.pluginName}`);
        return;
      }

      console.log(
        `Building webview for plugin ${plugin.pluginName} from ${pageTsxFile.displayPath}`
      );

      // Set up paths
      const webviewDir = path.resolve('src/webview');
      const srcDir = path.join(webviewDir, 'src');
      const pluginDistDir = this.getPluginDestDir(plugin);
      const htmlOutputDir = path.join(pluginDistDir, 'html');

      // Ensure directories exist
      await fs.mkdir(srcDir, { recursive: true });
      await fs.mkdir(htmlOutputDir, { recursive: true });

      // Backup original App.tsx if it exists
      const appFilePath = path.join(srcDir, 'App.tsx');
      let originalAppContent = '';
      if (fsSync.existsSync(appFilePath)) {
        originalAppContent = await fs.readFile(appFilePath, 'utf-8');
      }

      try {
        // Generate and write temporary App.tsx
        const appContent = this.generateAppTsxContent(srcDir, pageTsxFile);
        await fs.writeFile(appFilePath, appContent, 'utf-8');
        console.log(
          `Generated temporary App.tsx for plugin ${plugin.pluginName}`
        );

        // Ensure other necessary files exist
        await this.ensureWebviewFiles(srcDir);

        // Run Vite build
        console.log(`Running Vite build for plugin ${plugin.pluginName}...`);
        await this.runViteBuild(htmlOutputDir);

        // Verify the build output
        const indexHtmlPath = path.join(htmlOutputDir, 'index.html');
        if (!fsSync.existsSync(indexHtmlPath)) {
          throw new Error(
            `Failed to generate index.html for plugin ${plugin.pluginName}`
          );
        }

        console.log(
          `‚úì Built webview for plugin ${
            plugin.pluginName
          } to ${this.pathToDisplay(htmlOutputDir)}`
        );
      } finally {
        // Restore the original App.tsx
        if (originalAppContent) {
          await fs.writeFile(appFilePath, originalAppContent, 'utf-8');
          console.log(`Restored original App.tsx`);
        }
      }
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      const pluginName =
        typeof pluginNameOrPath === 'string'
          ? pluginNameOrPath
          : pluginNameOrPath.pluginName;

      console.error(`Error building webview for plugin ${pluginName}:`, error);
      throw new Error(
        `Failed to build webview for plugin ${pluginName}: ${errorMessage}`
      );
    }
  }

  /**
   * Runs the Vite build process
   * @param outputDir The directory to output the build to
   * @private
   */
  private async runViteBuild(outputDir: string): Promise<void> {
    const buildCommand = `npx vite build --outDir=${outputDir}`;
    console.log(`Executing: ${buildCommand}`);

    // Use spawn to run the build command
    const child = spawn(buildCommand, {
      cwd: process.cwd(),
      shell: true,
      stdio: 'inherit',
    });

    // Wait for the build to complete
    await new Promise<void>((resolve, reject) => {
      child.on('close', (code) => {
        if (code === 0) {
          resolve();
        } else {
          reject(new Error(`Vite build failed with exit code ${code}`));
        }
      });
    });
  }

  /**
   * Generates App.tsx content for a plugin's Page.tsx
   * @param srcDir Source directory where App.tsx will be created
   * @param pageTsxFile The Page.tsx file
   * @returns Generated App.tsx content
   * @private
   */
  private generateAppTsxContent(srcDir: string, pageTsxFile: File): string {
    // Calculate relative path from src directory to the Page.tsx file
    const importPath = path
      .relative(srcDir, pageTsxFile.fullPath)
      .replace(/\\/g, '/');
    const formattedImportPath = importPath.startsWith('.')
      ? importPath
      : `../../${importPath}`;

    // Create the App.tsx content
    return `// Auto-generated by BuildManager
// Generated on: ${new Date().toISOString()}

import Page from '${formattedImportPath}';

function App() {
  return <Page />;
}

export default App;
`;
  }

  /**
   * Ensures all necessary files exist for the webview build
   * @param srcDir Source directory
   * @private
   */
  private async ensureWebviewFiles(srcDir: string): Promise<void> {
    const webviewSrcDir = path.resolve('src/webview/src');

    // Check if the webview src directory exists
    if (!fsSync.existsSync(webviewSrcDir)) {
      throw new Error(`Webview src directory not found: ${webviewSrcDir}`);
    }

    // Copy main.tsx if it doesn't exist in the target directory
    const mainTsxPath = path.join(srcDir, 'main.tsx');
    if (!fsSync.existsSync(mainTsxPath)) {
      const sourcePath = path.join(webviewSrcDir, 'main.tsx');
      if (fsSync.existsSync(sourcePath)) {
        await fs.copyFile(sourcePath, mainTsxPath);
        console.log(`Copied main.tsx from ${sourcePath}`);
      }
    }

    // Copy index.html if it doesn't exist in the target directory
    const indexHtmlPath = path.join(srcDir, 'index.html');
    if (!fsSync.existsSync(indexHtmlPath)) {
      const sourcePath = path.join(webviewSrcDir, 'index.html');
      if (fsSync.existsSync(sourcePath)) {
        await fs.copyFile(sourcePath, indexHtmlPath);
        console.log(`Copied index.html from ${sourcePath}`);
      }
    }

    // Copy index.css if it doesn't exist in the target directory
    const indexCssPath = path.join(srcDir, 'index.css');
    if (!fsSync.existsSync(indexCssPath)) {
      const sourcePath = path.join(webviewSrcDir, 'index.css');
      if (fsSync.existsSync(sourcePath)) {
        await fs.copyFile(sourcePath, indexCssPath);
        console.log(`Copied index.css from ${sourcePath}`);
      }
    }
  }

  /**
   * Copies files to the dist directory
   * @param plugin The plugin object
   * @param files The files to copy
   * @private
   */
  private async copyFilesToDist(plugin: Plugin, files: File[]): Promise<void> {
    const destDir = this.getPluginDestDir(plugin);

    // Ensure the destination directory exists
    await fs.mkdir(destDir, { recursive: true });

    // Copy each file, preserving directory structure within the plugin
    for (const file of files) {
      // Get the relative path within the plugin
      const relativePath = path.relative(plugin.fullPath, file.fullPath);
      const destPath = path.join(destDir, relativePath);

      // Create the destination directory if it doesn't exist
      const destFileDir = path.dirname(destPath);
      await fs.mkdir(destFileDir, { recursive: true });

      // Copy the file
      await fs.copyFile(file.fullPath, destPath);
    }
  }

  /**
   * Gets the destination directory for a plugin
   * @param plugin The plugin object
   * @private
   */
  private getPluginDestDir(plugin: Plugin): string {
    // Use the plugin's parent folders to build the destination path
    let destPath = this.distPath;

    // If the plugin has parent folders, include them in the path
    if (plugin.parents.length > 0) {
      // We only need the last parent entry which contains the full parent path
      // For example, if parents are ['[misc2]', '[misc2]/[sub-sub-folder]'],
      // we only need the last one which already has the full path structure
      const parentPath = plugin.parents[plugin.parents.length - 1];

      // Combine the parent path with the plugin name
      destPath = path.join(this.distPath, parentPath, plugin.pluginName);
    } else {
      // No parent folders, just place directly under dist
      destPath = path.join(this.distPath, plugin.pluginName);
    }

    return destPath;
  }

  /**
   * Gets a Plugin object from a name or path
   * @param pluginNameOrPath The name or path of the plugin
   * @private
   */
  private getPluginFromNameOrPath(
    pluginNameOrPath: string
  ): Plugin | undefined {
    if (pluginNameOrPath.includes(path.sep)) {
      // It's a path
      return this.fileManager.getPluginByPath(pluginNameOrPath);
    } else {
      // It's a name
      return this.fileManager.getPlugin(pluginNameOrPath);
    }
  }

  /**
   * Converts a path to display format (with forward slashes)
   * @param filePath The path to convert
   * @private
   */
  private pathToDisplay(filePath: string): string {
    return filePath.replace(/\\/g, '/');
  }

  /**
   * Builds all plugins
   */
  async buildAllPlugins(): Promise<void> {
    this.ensureInitialized();

    try {
      const plugins = this.fileManager.getAllPlugins();

      if (plugins.length === 0) {
        console.log('No plugins found to build');
        return;
      }

      console.log(`Building all ${plugins.length} plugins...`);

      for (const plugin of plugins) {
        await this.buildPlugin(plugin.fullPath);
      }

      console.log(`‚úì All ${plugins.length} plugins built successfully`);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error('Error building all plugins:', error);
      throw new Error(`Failed to build all plugins: ${errorMessage}`);
    }
  }

  /**
   * Cleans the dist directory
   */
  async clean(): Promise<void> {
    this.ensureInitialized();

    try {
      console.log(
        `Cleaning dist directory: ${this.pathToDisplay(this.distPath)}`
      );

      // Check if the directory exists
      if (fsSync.existsSync(this.distPath)) {
        // Remove all files and subdirectories
        await fs.rm(this.distPath, { recursive: true, force: true });

        // Recreate the empty directory
        await fs.mkdir(this.distPath, { recursive: true });
      }

      console.log('‚úì Dist directory cleaned successfully');
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error('Error cleaning dist directory:', error);
      throw new Error(`Failed to clean dist directory: ${errorMessage}`);
    }
  }

  /**
   * Helper method to ensure the manager is initialized
   * @private
   */
  private ensureInitialized(): void {
    if (!this.initialized) {
      throw new Error(
        'BuildManager must be initialized before use. Call initialize() first.'
      );
    }
  }

  /**
   * Determines if a file is a server-side script based on its path
   * @param filePath Path to check
   * @returns Whether the file is a server-side script
   * @private
   */
  private isServerScript(filePath: string): boolean {
    return filePath.includes('/server/') || filePath.includes('\\server\\');
  }

  /**
   * Gets the list of packages to not inline
   * @param isServerScript Whether the file is a server-side script
   * @returns List of external packages
   * @private
   */
  private getExternalPackages(isServerScript: boolean): string[] {
    // For server scripts, make Node.js modules external
    return isServerScript
      ? [
          'http',
          'https',
          'url',
          'fs',
          'path',
          'os',
          'crypto',
          'buffer',
          'stream',
          'util',
          'events',
          'zlib',
          'net',
          'tls',
          'dns',
          'child_process',
        ]
      : [];
  }
}

export { BuildManager };


================================================================================

# .\managers\FileManager.ts

import * as fs from 'fs/promises';
import * as fsSync from 'fs';
import * as path from 'path';
import { glob } from 'glob'; // For pattern matching in file paths
import { Plugin } from '../types/Plugin.js';
import { File } from '../types/File.js';
import { PluginManifest, BasicPluginManifest } from '../types/Manifest.js';

/**
 * File manager
 * This class will provide the functionality needed to retrieve and act upon files
 */
class FileManager {
  private rootPath: string;
  private plugins: Map<string, Plugin> = new Map();
  private files: Map<string, File> = new Map();

  // Map of full path to plugin for efficient lookups
  private pathToPlugin: Map<string, Plugin> = new Map();

  /**
   * Creates a new FileManager instance
   * @param rootPath Path to the plugins directory
   */
  constructor(rootPath: string = 'src/plugins') {
    this.rootPath = path.resolve(rootPath);
  }

  /**
   * Initializes the file manager by scanning the plugins directory
   * Must be called before using other methods
   */
  async initialize(): Promise<void> {
    try {
      await this.scanPlugins();
      console.log(
        `FileManager initialized with ${this.plugins.size} plugins and ${this.files.size} files`
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error('Error initializing FileManager:', error);
      throw new Error(`Failed to initialize FileManager: ${errorMessage}`);
    }
  }

  /**
   * Safely escapes special characters in paths for glob patterns
   * @param pathStr The path to escape for glob pattern
   * @returns Safely escaped path for glob pattern
   */
  private escapeGlobPattern(pathStr: string): string {
    // First, normalize using forward slashes for glob patterns
    let normalized = pathStr.replace(/\\/g, '/');

    // Use a more thorough escaping approach - replace each square bracket individually
    // to handle cases with nested square brackets
    let result = '';
    for (let i = 0; i < normalized.length; i++) {
      if (normalized[i] === '[') {
        result += '[[]';
      } else if (normalized[i] === ']') {
        result += '[]]';
      } else {
        result += normalized[i];
      }
    }

    console.log(`Original path: ${pathStr}`);
    console.log(`Escaped path: ${result}`);

    return result;
  }

  /**
   * Scans the plugins directory to discover all plugins
   */
  private async scanPlugins(): Promise<void> {
    try {
      // Use glob to find all plugin.json files
      const pluginJsonRawPattern = path.join(
        this.rootPath,
        '**',
        'plugin.json'
      );
      const pluginJsonPattern = this.escapeGlobPattern(pluginJsonRawPattern);

      const options = {
        windowsPathsNoEscape: true, // Important for paths with square brackets
        nodir: true,
      };

      const pluginJsonPaths = await glob(pluginJsonPattern, options);

      if (pluginJsonPaths.length === 0) {
        console.warn(
          `No plugins found in ${this.pathToDisplay(this.rootPath)}`
        );
      }

      for (const pluginJsonPath of pluginJsonPaths) {
        try {
          const pluginDir = path.dirname(pluginJsonPath);
          const plugin = await this.registerPlugin(pluginDir);

          // Try to load the manifest for this plugin
          try {
            const manifest = await this.loadPluginManifest(pluginJsonPath);
            plugin.manifest = manifest;
          } catch (error) {
            const errorMessage =
              error instanceof Error ? error.message : String(error);
            console.warn(
              `Warning: Failed to load manifest for plugin ${plugin.pluginName}: ${errorMessage}`
            );
          }

          await this.scanPluginFiles(plugin);
        } catch (error) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          console.error(
            `Error registering plugin at ${this.pathToDisplay(
              pluginJsonPath
            )}:`,
            errorMessage
          );
          // Continue with other plugins even if one fails
        }
      }
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error('Error scanning plugins:', error);
      throw new Error(`Failed to scan plugins: ${errorMessage}`);
    }
  }

  /**
   * Loads and parses a plugin manifest file
   * @param manifestPath Path to the plugin.json file
   */
  private async loadPluginManifest(
    manifestPath: string
  ): Promise<PluginManifest> {
    try {
      const manifestContent = await fs.readFile(manifestPath, 'utf-8');
      try {
        return JSON.parse(manifestContent) as PluginManifest;
      } catch (parseError) {
        console.warn(
          `Warning: Invalid JSON in plugin manifest at ${this.pathToDisplay(
            manifestPath
          )}`
        );
        // Return a basic manifest with just the plugin name derived from the directory
        const pluginDir = path.dirname(manifestPath);
        const pluginName = path.basename(pluginDir);
        return { name: pluginName } as BasicPluginManifest;
      }
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to read plugin manifest: ${errorMessage}`);
    }
  }

  /**
   * Registers a plugin based on its directory
   */
  private async registerPlugin(pluginDir: string): Promise<Plugin> {
    // Generate a unique plugin ID that includes its path hierarchy
    const relativePath = path.relative(this.rootPath, pluginDir);
    const pluginPathParts = relativePath.split(path.sep);
    const pluginName = pluginPathParts[pluginPathParts.length - 1];

    // Extract and build parent paths using forward slashes
    const parents: string[] = [];
    if (pluginPathParts.length > 1) {
      // Create an array of all parent paths
      for (let i = 0; i < pluginPathParts.length - 1; i++) {
        // Build path up to this parent level with forward slashes
        const parentPath = pluginPathParts.slice(0, i + 1).join('/');
        parents.push(parentPath);
      }
    }

    // Create a path-based identifier for the plugin
    const pluginPathIdentifier =
      this.generatePluginPathIdentifier(relativePath);

    // Check for duplicate plugin paths
    if (this.plugins.has(pluginPathIdentifier)) {
      throw new Error(
        `Duplicate plugin detected at path: ${this.pathToDisplay(relativePath)}`
      );
    }

    const plugin: Plugin = {
      pluginName,
      fullPath: pluginDir,
      displayPath: this.pathToDisplay(pluginDir),
      files: [],
      parents,
    };

    this.plugins.set(pluginPathIdentifier, plugin);
    this.pathToPlugin.set(pluginDir, plugin);

    return plugin;
  }

  /**
   * Generates a unique path identifier for a plugin based on its relative path
   */
  private generatePluginPathIdentifier(relativePath: string): string {
    // Replace backslashes with forward slashes for consistent handling
    const normalizedPath = relativePath.replace(/\\/g, '/');
    return normalizedPath;
  }

  /**
   * Scans all files in a plugin
   */
  private async scanPluginFiles(
    plugin: Plugin,
    currentDir = plugin.fullPath
  ): Promise<void> {
    try {
      const entries = await fs.readdir(currentDir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name);

        if (entry.isDirectory()) {
          // Recursively scan subdirectories
          await this.scanPluginFiles(plugin, fullPath);
        } else if (entry.isFile()) {
          // Register the file, including plugin.json which we now track as a file
          const file: File = {
            fileName: entry.name,
            fullPath: fullPath,
            displayPath: this.pathToDisplay(fullPath),
            plugin,
          };

          this.files.set(fullPath, file);
          plugin.files.push(file);
        }
      }
    } catch (error) {
      console.error(`Error scanning directory ${currentDir}:`, error);
    }
  }

  /**
   * Converts a path to use forward slashes for display
   * @param filePath The path to convert
   */
  pathToDisplay(filePath: string): string {
    return filePath.replace(/\\/g, '/');
  }

  /**
   * Gets a plugin by name and optional parent path
   * @param pluginName The name of the plugin
   * @param parentPath Optional parent path to distinguish between plugins with the same name
   */
  getPlugin(pluginName: string, parentPath?: string): Plugin | undefined {
    if (parentPath) {
      // Get by full path
      const fullPath = path.join(this.rootPath, parentPath, pluginName);
      return this.pathToPlugin.get(this.normalizePath(fullPath));
    } else {
      // Try to find by name only - this might return the first match if there are duplicates
      for (const plugin of this.plugins.values()) {
        if (plugin.pluginName === pluginName) {
          return plugin;
        }
      }
      return undefined;
    }
  }

  /**
   * Gets a plugin by full path
   * @param pluginPath The full path to the plugin
   */
  getPluginByPath(pluginPath: string): Plugin | undefined {
    const normalizedPath = this.normalizePath(pluginPath);
    return this.pathToPlugin.get(normalizedPath);
  }

  /**
   * Gets all plugins
   */
  getAllPlugins(): Plugin[] {
    return Array.from(this.plugins.values());
  }

  /**
   * Gets plugins with a specific name (potentially multiple in different parent folders)
   * @param pluginName The name of the plugin
   */
  getPluginsByName(pluginName: string): Plugin[] {
    return Array.from(this.plugins.values()).filter(
      (plugin) => plugin.pluginName === pluginName
    );
  }

  /**
   * Gets plugins in a specific parent folder
   * @param parentFolder The parent folder path relative to the root
   */
  getPluginsInFolder(parentFolder: string): Plugin[] {
    const fullParentPath = path.join(this.rootPath, parentFolder);
    const normalizedParentPath = this.normalizePath(fullParentPath);

    return Array.from(this.plugins.values()).filter((plugin) =>
      this.normalizePath(plugin.fullPath).startsWith(normalizedParentPath)
    );
  }

  /**
   * Gets a file by path
   * @param filePath The path to the file
   */
  getFile(filePath: string): File | undefined {
    return this.files.get(this.normalizePath(filePath));
  }

  /**
   * Gets all files for a plugin
   * @param pluginNameOrPath The name or path of the plugin
   */
  getFilesForPlugin(pluginNameOrPath: string): File[] {
    // Check if it's a full path
    if (pluginNameOrPath.includes(path.sep)) {
      const plugin = this.getPluginByPath(pluginNameOrPath);
      return plugin?.files || [];
    } else {
      // It's just a name, might return multiple plugins
      const plugins = this.getPluginsByName(pluginNameOrPath);
      if (plugins.length === 0) return [];
      if (plugins.length === 1) return plugins[0].files || [];

      // Multiple plugins with the same name, return all files
      return plugins.flatMap((plugin) => plugin.files || []);
    }
  }

  /**
   * Gets all files matching a pattern (glob) for a plugin
   * @param pluginNameOrPath The name or path of the plugin
   * @param pattern The glob pattern to match against files
   */
  async getFilesMatchingPattern(
    pluginNameOrPath: string,
    pattern: string
  ): Promise<File[]> {
    const plugins = pluginNameOrPath.includes(path.sep)
      ? ([this.getPluginByPath(pluginNameOrPath)].filter(Boolean) as Plugin[])
      : this.getPluginsByName(pluginNameOrPath);

    if (plugins.length === 0) return [];

    const results: File[] = [];

    for (const plugin of plugins) {
      // Make sure we escape square brackets in both the plugin path and pattern
      const fileRawPattern = path.join(plugin.fullPath, pattern);
      const filePattern = this.escapeGlobPattern(fileRawPattern);

      const options = { windowsPathsNoEscape: true };

      const matchingPaths = await glob(filePattern, options);

      for (const filePath of matchingPaths) {
        const file = this.files.get(filePath);
        if (file) results.push(file);
      }
    }

    return results;
  }

  /**
   * Gets all files matching an extension for a plugin
   * @param pluginNameOrPath The name or path of the plugin
   * @param extension The file extension to match (with or without leading dot)
   */
  getFilesByExtension(pluginNameOrPath: string, extension: string): File[] {
    // Ensure extension starts with a dot
    if (!extension.startsWith('.')) {
      extension = `.${extension}`;
    }

    const files = this.getFilesForPlugin(pluginNameOrPath);
    return files.filter((file) => path.extname(file.fileName) === extension);
  }

  /**
   * Gets the manifest file for a plugin
   * @param pluginNameOrPath The name or path of the plugin
   */
  async getPluginManifest(
    pluginNameOrPath: string
  ): Promise<PluginManifest | undefined> {
    let plugin: Plugin | undefined;

    // Check if it's a full path
    if (pluginNameOrPath.includes(path.sep)) {
      plugin = this.getPluginByPath(pluginNameOrPath);
    } else {
      // It's just a name
      plugin = this.getPlugin(pluginNameOrPath);
    }

    if (!plugin) return undefined;

    // Check if we already have the manifest in the plugin object
    if (plugin.manifest) return plugin.manifest;

    // Otherwise, try to load it
    try {
      const manifestPath = path.join(plugin.fullPath, 'plugin.json');
      const manifest = await this.loadPluginManifest(manifestPath);
      plugin.manifest = manifest; // Cache for future use
      return manifest;
    } catch (error) {
      console.warn(
        `Warning: Could not load manifest for plugin ${plugin.pluginName}`
      );
      return undefined;
    }
  }

  /**
   * Reads the content of a file
   * @param filePath The path to the file
   */
  async readFile(filePath: string): Promise<string> {
    try {
      const normalizedPath = this.normalizePath(filePath);
      const file = this.files.get(normalizedPath);

      if (!file) {
        throw new Error(`File not found: ${this.pathToDisplay(filePath)}`);
      }

      return await fs.readFile(normalizedPath, 'utf-8');
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(
        `Error reading file ${this.pathToDisplay(filePath)}:`,
        error
      );
      throw new Error(
        `Failed to read file ${this.pathToDisplay(filePath)}: ${errorMessage}`
      );
    }
  }

  /**
   * Writes content to a file
   * @param filePath The path to the file
   * @param content The content to write
   */
  async writeFile(filePath: string, content: string): Promise<File> {
    try {
      const normalizedPath = this.normalizePath(filePath);
      let file = this.files.get(normalizedPath);

      if (!file) {
        // If the file doesn't exist, we need to determine which plugin it belongs to
        const plugin = this.findPluginForPath(normalizedPath);
        if (!plugin) {
          throw new Error(
            `Cannot determine plugin for path: ${this.pathToDisplay(filePath)}`
          );
        }

        // Create the directory if it doesn't exist
        const dir = path.dirname(normalizedPath);
        await fs.mkdir(dir, { recursive: true });

        // Create the file
        await fs.writeFile(normalizedPath, content, 'utf-8');

        // Register the new file
        file = {
          fileName: path.basename(normalizedPath),
          fullPath: normalizedPath,
          displayPath: this.pathToDisplay(normalizedPath),
          plugin,
        };

        this.files.set(normalizedPath, file);
        plugin.files.push(file);

        // If this is a plugin.json file, update the manifest in the plugin
        if (path.basename(normalizedPath) === 'plugin.json') {
          try {
            plugin.manifest = JSON.parse(content) as PluginManifest;
          } catch (error) {
            console.warn(
              `Warning: Invalid JSON in new plugin.json for plugin ${plugin.pluginName}`
            );
          }
        }
      } else {
        // If the file exists, just update its content
        await fs.writeFile(normalizedPath, content, 'utf-8');

        // If this is a plugin.json file, update the manifest in the plugin
        if (path.basename(normalizedPath) === 'plugin.json') {
          try {
            file.plugin.manifest = JSON.parse(content) as PluginManifest;
          } catch (error) {
            console.warn(
              `Warning: Invalid JSON in updated plugin.json for plugin ${file.plugin.pluginName}`
            );
          }
        }
      }

      return file;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(
        `Error writing file ${this.pathToDisplay(filePath)}:`,
        error
      );
      throw new Error(
        `Failed to write file ${this.pathToDisplay(filePath)}: ${errorMessage}`
      );
    }
  }

  /**
   * Deletes a file
   * @param filePath The path to the file
   */
  async deleteFile(filePath: string): Promise<boolean> {
    try {
      const normalizedPath = this.normalizePath(filePath);
      const file = this.files.get(normalizedPath);

      if (!file) {
        return false; // File not found
      }

      // Check if this is a plugin.json file - don't allow deletion if it is
      if (path.basename(normalizedPath) === 'plugin.json') {
        throw new Error(
          `Cannot delete plugin.json file. To remove a plugin, use removePlugin() instead.`
        );
      }

      // Remove the file from the file system
      await fs.unlink(normalizedPath);

      // Remove the file from the plugin
      const plugin = file.plugin;
      const pluginFiles = plugin.files || [];
      plugin.files = pluginFiles.filter((f) => f.fullPath !== normalizedPath);

      // Remove the file from the registry
      this.files.delete(normalizedPath);

      return true;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(
        `Error deleting file ${this.pathToDisplay(filePath)}:`,
        error
      );
      throw new Error(
        `Failed to delete file ${this.pathToDisplay(filePath)}: ${errorMessage}`
      );
    }
  }

  /**
   * Copies a file to a new location
   * @param sourceFilePath The path to the source file
   * @param destinationFilePath The path to the destination file
   */
  async copyFile(
    sourceFilePath: string,
    destinationFilePath: string
  ): Promise<File> {
    try {
      const sourceNormalizedPath = this.normalizePath(sourceFilePath);
      const destNormalizedPath = this.normalizePath(destinationFilePath);

      const sourceFile = this.files.get(sourceNormalizedPath);
      if (!sourceFile) {
        throw new Error(
          `Source file not found: ${this.pathToDisplay(sourceFilePath)}`
        );
      }

      // Check if this is a plugin.json file - don't allow copying if it is
      if (path.basename(sourceNormalizedPath) === 'plugin.json') {
        throw new Error(
          `Cannot copy plugin.json file directly. Use createPlugin() instead.`
        );
      }

      // Determine the destination plugin
      const destPlugin = this.findPluginForPath(destNormalizedPath);
      if (!destPlugin) {
        throw new Error(
          `Cannot determine plugin for destination path: ${this.pathToDisplay(
            destinationFilePath
          )}`
        );
      }

      // Create the directory if it doesn't exist
      const destDir = path.dirname(destNormalizedPath);
      await fs.mkdir(destDir, { recursive: true });

      // Copy the file
      await fs.copyFile(sourceNormalizedPath, destNormalizedPath);

      // Register the new file
      const destFile: File = {
        fileName: path.basename(destNormalizedPath),
        fullPath: destNormalizedPath,
        displayPath: this.pathToDisplay(destNormalizedPath),
        plugin: destPlugin,
      };

      this.files.set(destNormalizedPath, destFile);
      destPlugin.files.push(destFile);

      return destFile;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(
        `Error copying file ${this.pathToDisplay(
          sourceFilePath
        )} to ${this.pathToDisplay(destinationFilePath)}:`,
        error
      );
      throw new Error(`Failed to copy file: ${errorMessage}`);
    }
  }

  /**
   * Creates a new plugin
   * @param pluginName The name of the plugin
   * @param parentFolder Optional parent folder path (relative to root)
   * @param manifest Optional manifest data for the plugin
   */
  async createPlugin(
    pluginName: string,
    parentFolder?: string,
    manifest?: PluginManifest
  ): Promise<Plugin> {
    try {
      // Determine the full path to the new plugin
      let pluginPath: string;
      if (parentFolder) {
        // Make sure parent folder exists
        const parentPath = path.join(this.rootPath, parentFolder);

        if (!fsSync.existsSync(parentPath)) {
          await fs.mkdir(parentPath, { recursive: true });
        }

        pluginPath = path.join(parentPath, pluginName);
      } else {
        pluginPath = path.join(this.rootPath, pluginName);
      }

      // Check if the plugin already exists at this path
      if (fsSync.existsSync(path.join(pluginPath, 'plugin.json'))) {
        throw new Error(
          `Plugin already exists at path: ${this.pathToDisplay(pluginPath)}`
        );
      }

      // Create the plugin directory
      await fs.mkdir(pluginPath, { recursive: true });

      // Create standard directories
      await Promise.all([
        fs.mkdir(path.join(pluginPath, 'client'), { recursive: true }),
        fs.mkdir(path.join(pluginPath, 'server'), { recursive: true }),
        fs.mkdir(path.join(pluginPath, 'html'), { recursive: true }),
        fs.mkdir(path.join(pluginPath, 'translations'), { recursive: true }),
      ]);

      // Create the plugin.json file with provided manifest or a default one
      const pluginManifest: PluginManifest = manifest || {
        name: pluginName,
        version: '1.0.0',
        description: `${pluginName} plugin`,
      };

      await fs.writeFile(
        path.join(pluginPath, 'plugin.json'),
        JSON.stringify(pluginManifest, null, 2),
        'utf-8'
      );

      // Register the new plugin
      const plugin = await this.registerPlugin(pluginPath);
      plugin.manifest = pluginManifest; // Set the manifest
      await this.scanPluginFiles(plugin);

      return plugin;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(`Error creating plugin ${pluginName}:`, error);
      throw new Error(`Failed to create plugin ${pluginName}: ${errorMessage}`);
    }
  }

  /**
   * Removes a plugin
   * @param pluginNameOrPath The name or path of the plugin
   */
  async removePlugin(pluginNameOrPath: string): Promise<void> {
    try {
      let plugin: Plugin | undefined;

      // Check if it's a path or a name
      if (pluginNameOrPath.includes(path.sep)) {
        plugin = this.getPluginByPath(pluginNameOrPath);
      } else {
        const plugins = this.getPluginsByName(pluginNameOrPath);

        if (plugins.length === 0) {
          throw new Error(`Plugin not found: ${pluginNameOrPath}`);
        }

        if (plugins.length > 1) {
          throw new Error(
            `Multiple plugins found with name: ${pluginNameOrPath}. Please specify the full path.`
          );
        }

        plugin = plugins[0];
      }

      if (!plugin) {
        throw new Error(`Plugin not found: ${pluginNameOrPath}`);
      }

      // Remove all files from the registry
      const pluginFiles = plugin.files || [];
      for (const file of pluginFiles) {
        this.files.delete(file.fullPath);
      }

      // Remove the plugin from the registries
      const pathIdentifier = this.generatePluginPathIdentifier(
        path.relative(this.rootPath, plugin.fullPath)
      );

      this.plugins.delete(pathIdentifier);
      this.pathToPlugin.delete(plugin.fullPath);

      // Remove the plugin directory
      await fs.rm(plugin.fullPath, { recursive: true, force: true });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(`Error removing plugin ${pluginNameOrPath}:`, error);
      throw new Error(
        `Failed to remove plugin ${pluginNameOrPath}: ${errorMessage}`
      );
    }
  }

  /**
   * Normalizes a path for consistent handling
   * @param filePath The path to normalize
   */
  private normalizePath(filePath: string): string {
    // Resolve to absolute path if it's relative
    if (!path.isAbsolute(filePath)) {
      filePath = path.resolve(this.rootPath, filePath);
    }

    // Normalize path separators
    return path.normalize(filePath);
  }

  /**
   * Finds the plugin for a given path
   * @param filePath The path to find the plugin for
   */
  private findPluginForPath(filePath: string): Plugin | undefined {
    // Convert to absolute path if it's not already
    const absolutePath = path.isAbsolute(filePath)
      ? filePath
      : path.resolve(this.rootPath, filePath);

    // Find the plugin with the longest matching path prefix
    let bestMatch: Plugin | undefined;
    let bestMatchLength = 0;

    for (const plugin of this.plugins.values()) {
      if (
        absolutePath.startsWith(plugin.fullPath) &&
        plugin.fullPath.length > bestMatchLength
      ) {
        bestMatch = plugin;
        bestMatchLength = plugin.fullPath.length;
      }
    }

    return bestMatch;
  }

  /**
   * Gets all the unique parent folders of plugins
   */
  getParentFolders(): string[] {
    const parentFolders = new Set<string>();

    for (const plugin of this.plugins.values()) {
      const relativePath = path.relative(this.rootPath, plugin.fullPath);
      const parts = relativePath.split(path.sep);

      if (parts.length > 1) {
        // If there are parent folders
        const parentFolder = parts.slice(0, -1).join('/'); // Use forward slash here
        parentFolders.add(parentFolder);
      }
    }

    return Array.from(parentFolders);
  }

  /**
   * Refreshes the file system scan
   */
  async refresh(): Promise<void> {
    // Clear existing data
    this.plugins.clear();
    this.files.clear();
    this.pathToPlugin.clear();

    // Scan again
    await this.scanPlugins();
  }

  /**
   * Reloads a specific plugin by re-reading its files from the file system.
   * @param pluginPath The full path to the plugin directory.
   * @throws {Error} If the plugin is not found or if there is an error during reloading.
   */
  async reloadPlugin(pluginPath: string): Promise<void> {
    try {
      const normalizedPath = this.normalizePath(pluginPath);
      const plugin = this.pathToPlugin.get(normalizedPath);
      if (!plugin) {
        throw new Error(
          `Plugin not found at path: ${this.pathToDisplay(pluginPath)}`
        );
      }

      // Remove existing files associated with the plugin
      for (const file of plugin.files) {
        this.files.delete(file.fullPath);
      }

      // Remove the plugin from registries
      const pathIdentifier = this.generatePluginPathIdentifier(
        path.relative(this.rootPath, plugin.fullPath)
      );
      this.plugins.delete(pathIdentifier);
      this.pathToPlugin.delete(normalizedPath);

      // Re-register the plugin
      const reloadedPlugin = await this.registerPlugin(normalizedPath);

      // Reload the manifest
      const manifestPath = path.join(normalizedPath, 'plugin.json');
      try {
        reloadedPlugin.manifest = await this.loadPluginManifest(manifestPath);
      } catch (error) {
        console.warn(
          `Warning: Failed to load manifest for plugin at ${this.pathToDisplay(
            manifestPath
          )}: ${error}`
        );
      }

      // Re-scan the plugin files
      await this.scanPluginFiles(reloadedPlugin);

      console.log(`Plugin reloaded successfully: ${reloadedPlugin.pluginName}`);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(
        `Error reloading plugin at ${this.pathToDisplay(pluginPath)}:`,
        error
      );
      throw new Error(`Failed to reload plugin: ${errorMessage}`);
    }
  }
}

export { FileManager };


================================================================================

# .\managers\ManifestManager.ts

import { FileManager } from './FileManager.js';
import { PluginManifest, BasicPluginManifest } from '../types/Manifest.js';
import { Plugin } from '../types/Plugin.js';
import * as path from 'path';

/**
 * Manifest manager
 * This class provides functionality to load, parse, and manage plugin manifests
 */
class ManifestManager {
  private fileManager: FileManager;
  private manifests: Map<string, PluginManifest> = new Map();
  private initialized: boolean = false;

  /**
   * Creates a new ManifestManager instance
   * @param fileManager The FileManager instance to use for file operations
   */
  constructor(fileManager: FileManager) {
    this.fileManager = fileManager;
  }

  /**
   * Initializes the manifest manager
   * Must be called before using other methods
   */
  async initialize(): Promise<void> {
    try {
      // Load all plugins from file manager
      const plugins = this.fileManager.getAllPlugins();

      // Load manifests for all plugins
      await Promise.all(
        plugins.map((plugin) => this.loadManifestForPlugin(plugin))
      );

      this.initialized = true;
      console.log(
        `ManifestManager initialized with ${this.manifests.size} manifests`
      );
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error('Error initializing ManifestManager:', error);
      throw new Error(`Failed to initialize ManifestManager: ${errorMessage}`);
    }
  }

  /**
   * Loads the manifest for a specific plugin
   * @param plugin The plugin to load the manifest for
   */
  async loadManifestForPlugin(
    plugin: Plugin
  ): Promise<PluginManifest | undefined> {
    try {
      const manifestPath = path.join(plugin.fullPath, 'plugin.json');

      // Attempt to read and parse the manifest file
      const manifestContent = await this.fileManager.readFile(manifestPath);
      const manifest = JSON.parse(manifestContent) as PluginManifest;

      // Validate the manifest
      if (!manifest.name) {
        console.warn(
          `Warning: Invalid manifest for plugin ${plugin.pluginName} - missing name field`
        );
        manifest.name = plugin.pluginName; // Set a default name if missing
      }

      // Store the manifest both in our map and in the plugin object
      this.manifests.set(plugin.fullPath, manifest);
      plugin.manifest = manifest;

      return manifest;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.warn(
        `Warning: Failed to load manifest for plugin ${plugin.pluginName}: ${errorMessage}`
      );

      // Create and return a basic default manifest
      const defaultManifest: BasicPluginManifest = {
        name: plugin.pluginName,
      };

      // Store the default manifest
      this.manifests.set(plugin.fullPath, defaultManifest);
      plugin.manifest = defaultManifest;

      return defaultManifest;
    }
  }

  /**
   * Gets the manifest for a plugin
   * @param pluginNameOrPath The name or path of the plugin
   */
  getManifest(pluginNameOrPath: string): PluginManifest | undefined {
    this.ensureInitialized();

    // Check if it's a path or a name
    if (pluginNameOrPath.includes(path.sep)) {
      // It's a path
      return this.manifests.get(this.normalizePath(pluginNameOrPath));
    } else {
      // It's a name, try to find the plugin first
      const plugin = this.fileManager.getPlugin(pluginNameOrPath);
      if (plugin) {
        return this.manifests.get(plugin.fullPath);
      }
      return undefined;
    }
  }

  /**
   * Updates the manifest for a plugin
   * @param pluginNameOrPath The name or path of the plugin
   * @param manifest The updated manifest data
   */
  async updateManifest(
    pluginNameOrPath: string,
    manifest: PluginManifest
  ): Promise<boolean> {
    this.ensureInitialized();

    let plugin: Plugin | undefined;

    // Check if it's a path or a name
    if (pluginNameOrPath.includes(path.sep)) {
      plugin = this.fileManager.getPluginByPath(pluginNameOrPath);
    } else {
      plugin = this.fileManager.getPlugin(pluginNameOrPath);
    }

    if (!plugin) {
      throw new Error(`Plugin not found: ${pluginNameOrPath}`);
    }

    try {
      // Write the updated manifest to the plugin.json file
      const manifestPath = path.join(plugin.fullPath, 'plugin.json');
      await this.fileManager.writeFile(
        manifestPath,
        JSON.stringify(manifest, null, 2)
      );

      // Update the manifest in our map and in the plugin object
      this.manifests.set(plugin.fullPath, manifest);
      plugin.manifest = manifest;

      return true;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(
        `Error updating manifest for plugin ${plugin.pluginName}:`,
        error
      );
      throw new Error(`Failed to update manifest: ${errorMessage}`);
    }
  }

  /**
   * Creates a new manifest for a plugin
   * @param plugin The plugin to create the manifest for
   * @param manifest The manifest data
   */
  async createManifest(
    plugin: Plugin,
    manifest: PluginManifest
  ): Promise<boolean> {
    try {
      // Ensure the plugin doesn't already have a manifest
      const manifestPath = path.join(plugin.fullPath, 'plugin.json');

      // Write the manifest to the plugin.json file
      await this.fileManager.writeFile(
        manifestPath,
        JSON.stringify(manifest, null, 2)
      );

      // Store the manifest in our map and in the plugin object
      this.manifests.set(plugin.fullPath, manifest);
      plugin.manifest = manifest;

      return true;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      console.error(
        `Error creating manifest for plugin ${plugin.pluginName}:`,
        error
      );
      throw new Error(`Failed to create manifest: ${errorMessage}`);
    }
  }

  /**
   * Gets all manifests
   */
  getAllManifests(): Map<string, PluginManifest> {
    this.ensureInitialized();
    return new Map(this.manifests);
  }

  /**
   * Refreshes a specific manifest
   * @param pluginNameOrPath The name or path of the plugin
   */
  async refreshManifest(
    pluginNameOrPath: string
  ): Promise<PluginManifest | undefined> {
    this.ensureInitialized();

    let plugin: Plugin | undefined;

    // Check if it's a path or a name
    if (pluginNameOrPath.includes(path.sep)) {
      plugin = this.fileManager.getPluginByPath(pluginNameOrPath);
    } else {
      plugin = this.fileManager.getPlugin(pluginNameOrPath);
    }

    if (!plugin) {
      throw new Error(`Plugin not found: ${pluginNameOrPath}`);
    }

    // Reload the manifest for this plugin
    return await this.loadManifestForPlugin(plugin);
  }

  /**
   * Refreshes all manifests
   */
  async refreshAllManifests(): Promise<void> {
    // Clear existing data
    this.manifests.clear();

    // Reload all manifests
    const plugins = this.fileManager.getAllPlugins();
    await Promise.all(
      plugins.map((plugin) => this.loadManifestForPlugin(plugin))
    );

    console.log(`Refreshed ${this.manifests.size} manifests`);
  }

  /**
   * Validates a manifest against the expected schema
   * @param manifest The manifest to validate
   */
  validateManifest(manifest: PluginManifest): string[] {
    const errors: string[] = [];

    // Check required fields
    if (!manifest.name) {
      errors.push('Missing required field: name');
    }

    // Check data types
    if (manifest.version && typeof manifest.version !== 'string') {
      errors.push('Invalid type for field: version (expected string)');
    }

    if (manifest.description && typeof manifest.description !== 'string') {
      errors.push('Invalid type for field: description (expected string)');
    }

    if (manifest.author && typeof manifest.author !== 'string') {
      errors.push('Invalid type for field: author (expected string)');
    }

    // Check array fields
    if (manifest.games && !Array.isArray(manifest.games)) {
      errors.push('Invalid type for field: games (expected array)');
    }

    if (manifest.dependencies && !Array.isArray(manifest.dependencies)) {
      errors.push('Invalid type for field: dependencies (expected array)');
    }

    // Check complex fields
    if (manifest.client_scripts) {
      if (
        typeof manifest.client_scripts !== 'string' &&
        !Array.isArray(manifest.client_scripts)
      ) {
        errors.push(
          'Invalid type for field: client_scripts (expected string or array)'
        );
      }
    }

    if (manifest.server_scripts) {
      if (
        typeof manifest.server_scripts !== 'string' &&
        !Array.isArray(manifest.server_scripts)
      ) {
        errors.push(
          'Invalid type for field: server_scripts (expected string or array)'
        );
      }
    }

    if (manifest.shared_scripts) {
      if (
        typeof manifest.shared_scripts !== 'string' &&
        !Array.isArray(manifest.shared_scripts)
      ) {
        errors.push(
          'Invalid type for field: shared_scripts (expected string or array)'
        );
      }
    }

    return errors;
  }

  /**
   * Helper method to ensure the manager is initialized
   * @private
   */
  private ensureInitialized(): void {
    if (!this.initialized) {
      throw new Error(
        'ManifestManager must be initialized before use. Call initialize() first.'
      );
    }
  }

  /**
   * Normalizes a path for consistent handling
   * @param filePath The path to normalize
   * @private
   */
  private normalizePath(filePath: string): string {
    return path.normalize(filePath);
  }
}

export { ManifestManager };


================================================================================

# .\managers\PluginManager.ts

import { FileManager } from './FileManager.js';
import { Plugin } from '../types/Plugin.js';
import { File } from '../types/File.js';

/**
 * Plugin manager
 * This class provides functionality to load and retrieve plugins
 */
class PluginManager {
  private fileManager: FileManager;
  private initialized: boolean = false;

  /**
   * Creates a new PluginManager instance
   * @param fileManager Optional FileManager instance. If not provided, a new one will be created.
   * @param pluginsPath Optional path to the plugins directory. Used only if fileManager is not provided.
   */
  constructor(fileManager?: FileManager, pluginsPath: string = 'src/plugins') {
    this.fileManager = fileManager || new FileManager(pluginsPath);
  }

  /**
   * Initializes the plugin manager by loading all plugins
   * Must be called before using other methods
   */
  async initialize(): Promise<void> {
    if (!this.initialized) {
      await this.fileManager.initialize();
      this.initialized = true;
      console.log(
        `PluginManager initialized with ${this.getAllPlugins().length} plugins`
      );
    }
  }

  /**
   * Gets all loaded plugins
   */
  getAllPlugins(): Plugin[] {
    this.ensureInitialized();
    return this.fileManager.getAllPlugins();
  }

  /**
   * Gets a plugin by name and optional parent path
   * @param pluginName The name of the plugin
   * @param parentPath Optional parent path to distinguish between plugins with the same name
   */
  getPlugin(pluginName: string, parentPath?: string): Plugin | undefined {
    this.ensureInitialized();
    return this.fileManager.getPlugin(pluginName, parentPath);
  }

  /**
   * Gets a plugin by full path
   * @param pluginPath The full path to the plugin
   */
  getPluginByPath(pluginPath: string): Plugin | undefined {
    this.ensureInitialized();
    return this.fileManager.getPluginByPath(pluginPath);
  }

  /**
   * Gets plugins with a specific name (potentially multiple in different parent folders)
   * @param pluginName The name of the plugin
   */
  getPluginsByName(pluginName: string): Plugin[] {
    this.ensureInitialized();
    return this.fileManager.getPluginsByName(pluginName);
  }

  /**
   * Gets plugins in a specific parent folder
   * @param parentFolder The parent folder path relative to the root
   */
  getPluginsInFolder(parentFolder: string): Plugin[] {
    this.ensureInitialized();
    return this.fileManager.getPluginsInFolder(parentFolder);
  }

  /**
   * Gets all the unique parent folders of plugins
   */
  getParentFolders(): string[] {
    this.ensureInitialized();
    return this.fileManager.getParentFolders();
  }

  /**
   * Gets files of a plugin by file extension
   * @param pluginNameOrPath The name or path of the plugin
   * @param extension The file extension to filter by (with or without leading dot)
   */
  getPluginFilesByExtension(
    pluginNameOrPath: string,
    extension: string
  ): File[] {
    this.ensureInitialized();
    return this.fileManager.getFilesByExtension(pluginNameOrPath, extension);
  }

  /**
   * Gets files of a plugin matching a pattern
   * @param pluginNameOrPath The name or path of the plugin
   * @param pattern The glob pattern to match files against
   */
  async getPluginFilesByPattern(
    pluginNameOrPath: string,
    pattern: string
  ): Promise<File[]> {
    this.ensureInitialized();
    return this.fileManager.getFilesMatchingPattern(pluginNameOrPath, pattern);
  }

  /**
   * Gets the FileManager instance
   */
  getFileManager(): FileManager {
    return this.fileManager;
  }

  /**
   * Helper method to ensure the manager is initialized
   * @private
   */
  private ensureInitialized(): void {
    if (!this.initialized) {
      throw new Error(
        'PluginManager must be initialized before use. Call initialize() first.'
      );
    }
  }

  /**
   * Reloads a specific plugin by re-reading its files from the file system.
   * @param pluginNameOrPath The name or path of the plugin to reload.
   * @throws {Error} If the plugin is not found or if multiple plugins with the same name are found.
   */
  async reloadPlugin(pluginNameOrPath: string): Promise<void> {
    this.ensureInitialized();
    // Try to get the plugin by path first
    let plugin = this.getPluginByPath(pluginNameOrPath);
    if (!plugin) {
      // If not found by path, try by name
      const plugins = this.getPluginsByName(pluginNameOrPath);
      if (plugins.length === 1) {
        plugin = plugins[0];
      } else if (plugins.length > 1) {
        throw new Error(
          `Multiple plugins found with name '${pluginNameOrPath}'. Please specify the full path.`
        );
      } else {
        throw new Error(`Plugin not found: ${pluginNameOrPath}`);
      }
    }
    // Delegate reloading to FileManager using the plugin's path
    await this.fileManager.reloadPlugin(plugin.fullPath);
  }
}

export { PluginManager };


================================================================================

# .\types\File.ts

import { Plugin } from './Plugin.js';

export interface File {
  fileName: string;
  fullPath: string;
  displayPath: string;
  plugin: Plugin;
}


================================================================================

# .\types\Manifest.ts

// .\types\PluginManifest.ts

/**
 * Represents a plugin manifest file (plugin.json)
 * Based on the fxmanifest.lua schema
 */
export interface PluginManifest {
  // Core metadata
  name: string;
  description?: string;
  author?: string;
  version?: string;

  // Framework version identifiers
  fx_version?: string;

  // Supported games/platforms
  games?: string[];

  // Scripts
  client_scripts?: string | string[];
  server_scripts?: string | string[];
  shared_scripts?: string | string[];

  // UI related properties
  ui_page?: string;

  // Dependencies
  dependencies?: string[];
  provide?: string | string[];

  // Runtime constraints (similar to dependencies in fxmanifest)
  constraints?: {
    server?: string;
    policy?: string[];
    onesync?: boolean;
    gameBuild?: string;
    natives?: string[];
  };

  // File definitions
  files?: string[];
  data_files?: Array<{
    type: string;
    files: string | string[];
  }>;

  // Map related
  is_map?: boolean;

  // Server related
  server_only?: boolean;

  // Loading screen related
  loadscreen?: string;
  loadscreen_manual_shutdown?: boolean;

  // Exports
  exports?: string[];
  server_exports?: string[];

  // Additional configuration options
  config?: Record<string, any>;

  // Any other custom metadata (allows for plugin-specific extensions)
  [key: string]: any;
}

/**
 * Type representing a simplified plugin.json for initial loading
 * Contains only the essential fields needed for plugin identification/registration
 */
export interface BasicPluginManifest {
  name: string;
  version?: string;
  description?: string;
  author?: string;
}


================================================================================

# .\types\Plugin.ts

import { PluginManifest } from './Manifest.js';
import { File } from '../types/File.js';

export interface Plugin {
  pluginName: string;
  fullPath: string;
  displayPath: string; // New property for display with forward slashes
  parents: string[]; // Array of parent directories with forward slashes
  files: File[];
  manifest?: PluginManifest;
}


--------------------------------------------------------------------------------
Total TypeScript files found: 8
