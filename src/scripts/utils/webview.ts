import * as path from 'path';
import { Plugin } from '../core/types.js';
import { fileSystem } from './fs/index.js';
import { spawn } from 'child_process';

/**
 * Builds the webview UI by generating App.tsx and running the Vite build.
 * @param plugins Array of plugin objects
 * @param distDir The main distribution directory
 * @returns Promise<string> Path to the built webview directory
 */
export async function buildWebview(
  plugins: Plugin[],
  distDir: string
): Promise<string> {
  console.log('\nBuilding webview UI...');

  // Validate inputs
  if (!Array.isArray(plugins)) {
    throw new Error('Plugins must be an array');
  }

  if (!distDir) {
    throw new Error('Distribution directory must be provided');
  }

  // Path to the webview directory
  const webviewDir = path.join(process.cwd(), 'src/webview');
  const webviewDistDir = path.join(distDir, 'webview');

  try {
    // Verify webview source directory exists
    if (!(await fileSystem.exists(webviewDir))) {
      throw new Error(`Webview directory not found: ${webviewDir}`);
    }

    // Make sure the output directory exists (Vite will clean it)
    await fileSystem.ensureDir(webviewDistDir);

    // Find plugins with webview pages - we'll use Promise.all below instead of this filter
    // since async filters don't work as expected

    // Resolve the promises in the filter
    const resolvedWebviewPlugins = await Promise.all(
      plugins
        .filter((plugin) => plugin.hasHtml && plugin.fullPath)
        .map(async (plugin) => {
          const pageFile = path.join(plugin.fullPath!, 'html', 'Page.tsx');
          if (await fileSystem.exists(pageFile)) {
            return plugin;
          }
          return null;
        })
    );

    // Filter out null values
    const validWebviewPlugins = resolvedWebviewPlugins.filter(
      Boolean
    ) as Plugin[];

    console.log(
      `Found ${validWebviewPlugins.length} plugins with webview pages`
    );

    if (validWebviewPlugins.length === 0) {
      console.log('No webview plugins found, skipping App.tsx generation');
      return webviewDistDir;
    }

    // Set up directories - src directory is where the App.tsx and other files will be generated
    const srcDir = path.join(webviewDir, 'src');
    await fileSystem.ensureDir(srcDir);

    // Generate App.tsx content
    let appContent = `// Auto-generated by cli: webview:build
// Generated on: ${new Date().toISOString()}\n\n`;

    const imports: string[] = [];
    const components: string[] = [];

    // Track used import names to avoid duplicates
    const usedImportNames = new Set<string>();

    for (const plugin of validWebviewPlugins) {
      if (!plugin.fullPath) continue;

      const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

      // Calculate relative path from src directory (Vite root) to the Page.tsx file
      // We need to make the import path relative to the src/webview/src directory
      const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');
      // Make sure the path is properly formatted for import
      // If the path doesn't start with '.', it's not a relative path, so make it one
      const formattedImportPath = importPath.startsWith('.')
        ? importPath
        : `../../${importPath}`;

      // Get the plugin's path relative to plugins directory
      const relPlugin = plugin.pathFromPluginsDir;
      const parts = relPlugin.split('/');
      const namespace = parts.length > 1 ? parts[0] : '';
      const pluginName = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

      // Clean up namespace and plugin name
      const nsClean = namespace.replace(/[\[\]\(\)\s-]/g, '');
      const pluginNameClean = pluginName
        .replace(/[\[\]\(\)\s]/g, '')
        .replace(/-/g, '_');

      // Create unique import name
      let importName = namespace
        ? `Page_${nsClean}_${pluginNameClean}`
        : `Page_${pluginNameClean}`;

      // Ensure import name is unique
      let counter = 1;
      let baseImportName = importName;
      while (usedImportNames.has(importName)) {
        importName = `${baseImportName}_${counter++}`;
      }
      usedImportNames.add(importName);

      // Create a key for React component - ensure it's unique and valid
      const key = namespace ? `${nsClean}/${pluginName}` : pluginName;

      imports.push(`import ${importName} from '${formattedImportPath}';`);
      components.push(`      <${importName} key="${key}" />`);
    }

    // Add imports
    appContent += imports.join('\n') + '\n\n';

    // Create App component
    appContent += `const App = () => {
  return (
    <>
${components.join('\n')}
    </>
  );
};

export default App;\n`;

    // Write generated content to App.tsx
    const appFilePath = path.join(srcDir, 'App.tsx');
    await fileSystem.writeFile(appFilePath, appContent);
    console.log(`Generated ${appFilePath}`);

    // Create main.tsx file
    const mainTsxContent = `
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const mainTsxPath = path.join(srcDir, 'main.tsx');
    await fileSystem.writeFile(mainTsxPath, mainTsxContent);
    console.log(`Generated ${mainTsxPath}`);

    // Create or verify index.html
    const indexHtmlPath = path.join(srcDir, 'index.html');
    const indexHtmlExists = await fileSystem.exists(indexHtmlPath);

    if (!indexHtmlExists) {
      const indexHtmlContent = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webview</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>
`;
      await fileSystem.writeFile(indexHtmlPath, indexHtmlContent);
      console.log(`Generated ${indexHtmlPath}`);
    } else {
      // File exists, check if it has the correct main.tsx reference
      const indexHtmlContent = await fileSystem.readFile(indexHtmlPath, 'utf8');
      if (
        !indexHtmlContent.includes('./main.tsx') &&
        (indexHtmlContent.includes('/webview/main.tsx') ||
          indexHtmlContent.includes('"/main.tsx"'))
      ) {
        // Fix the path
        const updatedContent = indexHtmlContent
          .replace(/["']\/webview\/main\.tsx["']/g, '"./main.tsx"')
          .replace(/["']\/main\.tsx["']/g, '"./main.tsx"');

        await fileSystem.writeFile(indexHtmlPath, updatedContent);
        console.log(`Updated ${indexHtmlPath} with correct main.tsx path`);
      }
    }

    // Create index.css if it doesn't exist
    const indexCssPath = path.join(srcDir, 'index.css');
    const indexCssExists = await fileSystem.exists(indexCssPath);

    if (!indexCssExists) {
      // Create a basic CSS file
      const indexCssContent = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.h-dvh {
  height: 100dvh;
}
`;
      await fileSystem.writeFile(indexCssPath, indexCssContent);
      console.log(`Generated ${indexCssPath}`);
    }

    // Run Vite build - it will output directly to distDir/webview per vite.config.ts
    console.log('Running Vite build...');
    try {
      // First check if package.json exists and has a build script
      const packageJsonPath = path.join(process.cwd(), 'package.json');

      // We'll always use npx vite build directly to avoid recursion
      // No need to check package.json

      // Always run Vite build directly to avoid recursion
      const buildCommand = 'npx vite build';
      console.log(`Executing: ${buildCommand}`);

      // use spawn to stream logs without buffering large output
      const child = spawn(buildCommand, {
        cwd: process.cwd(),
        shell: true,
        stdio: 'inherit',
      });
      await new Promise<void>((resolve, reject) => {
        child.on('close', (code) =>
          code === 0
            ? resolve()
            : reject(new Error(`Build command failed with exit code ${code}`))
        );
      });
    } catch (error: any) {
      console.error('Vite build failed:', error);

      // Add more helpful error information
      let errorMessage = `Vite build failed: ${error?.message || error}`;

      // Check if index.html exists and has correct format
      const indexHtmlPath = path.join(srcDir, 'index.html');
      if (await fileSystem.exists(indexHtmlPath)) {
        try {
          const indexHtmlContent = await fileSystem.readFile(
            indexHtmlPath,
            'utf8'
          );

          if (
            !indexHtmlContent.includes('./main.tsx') &&
            !indexHtmlContent.includes('main.tsx')
          ) {
            errorMessage +=
              '\nPossible cause: index.html does not reference main.tsx correctly.';
          }
        } catch (err) {
          errorMessage +=
            '\nPossible cause: index.html exists but cannot be read.';
        }
      } else {
        errorMessage += '\nPossible cause: index.html does not exist.';
      }

      throw new Error(errorMessage);
    }

    console.log('Webview build completed successfully!');
    return webviewDistDir;
  } catch (error) {
    console.error('Webview build failed:', error);
    throw error;
  }
}

/**
 * Builds a webview UI for a single plugin by generating App.tsx and running the Vite build.
 * @param plugin The plugin object to build the webview for
 * @param distDir The main distribution directory
 * @returns Promise<{ htmlDir: string; hasIndexHtml: boolean; hasAssets: boolean; success: boolean }>
 * Object containing the html directory path and verification results
 */
export async function buildPluginWebview(
  plugin: Plugin,
  distDir: string
): Promise<{
  htmlDir: string;
  hasIndexHtml: boolean;
  hasAssets: boolean;
  success: boolean;
}> {
  console.log(
    `\nBuilding webview UI for plugin: ${
      plugin.name || plugin.pathFromPluginsDir || 'unknown'
    }...`
  );

  // Validate inputs
  if (!plugin) {
    throw new Error('Plugin must be provided');
  }

  if (!distDir) {
    throw new Error('Distribution directory must be provided');
  }

  // Path to the webview directory
  const webviewDir = path.join(process.cwd(), 'src/webview');

  // Determine the plugin's resource path in the dist directory
  let resourcePath;
  let pluginRelativePath;

  if (plugin.pathFromPluginsDir) {
    // Check if the path starts with 'plugins/' and strip it if needed
    const normalizedPluginPath = path.normalize(plugin.pathFromPluginsDir);
    const pluginsPathNormalized = path.normalize('plugins');
    const pathContainsPluginsPrefix =
      normalizedPluginPath.startsWith(pluginsPathNormalized) ||
      normalizedPluginPath.startsWith(pluginsPathNormalized + path.sep);

    if (pathContainsPluginsPrefix) {
      // Strip the 'plugins/' prefix to place resources directly in dist
      pluginRelativePath = path.relative(
        pluginsPathNormalized,
        normalizedPluginPath
      );
      console.log(
        `Webview: Stripped 'plugins/' prefix from path: ${normalizedPluginPath} -> ${pluginRelativePath}`
      );
    } else {
      pluginRelativePath = normalizedPluginPath;
    }

    // Convert the plugin path to a resource path in dist
    // For example: "[misc]/example" -> "dist/[misc]/example"
    resourcePath = path.join(distDir, pluginRelativePath);
  } else if (plugin.fullPath) {
    // Extract resource name from fullPath if possible
    const pluginDir = path.basename(plugin.fullPath);
    resourcePath = path.join(distDir, pluginDir);
    pluginRelativePath = pluginDir;
  } else {
    // Fallback to name if nothing else is available
    resourcePath = path.join(distDir, plugin.name);
    pluginRelativePath = plugin.name;
  }

  // Create the html directory within the resource where webview files will be placed
  const htmlOutputDir = path.join(resourcePath, 'html');

  // Extract plugin path parts for the build output directory
  const pluginDistPathParts = pluginRelativePath
    ? pluginRelativePath.split('/')
    : [plugin.name];

  console.log('Plugin path parts for webview build:', pluginDistPathParts);

  // This is where Vite will directly output the build
  const webviewPluginDistDir = path.join(distDir, ...pluginDistPathParts);
  console.log('Webview plugin dist directory:', webviewPluginDistDir);

  try {
    // Verify webview source directory exists
    if (!(await fileSystem.exists(webviewDir))) {
      throw new Error(`Webview directory not found: ${webviewDir}`);
    }

    // Make sure the output directory exists
    await fileSystem.ensureDir(webviewPluginDistDir);

    // Check if plugin has a webview page
    if (!plugin.hasHtml || !plugin.fullPath) {
      console.log('Plugin does not have webview pages, skipping build');
      return {
        htmlDir: webviewPluginDistDir,
        hasIndexHtml: false,
        hasAssets: false,
        success: false,
      };
    }

    const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

    if (!(await fileSystem.exists(pageFile))) {
      console.log('Plugin does not have a Page.tsx file, skipping build');
      return {
        htmlDir: webviewPluginDistDir,
        hasIndexHtml: false,
        hasAssets: false,
        success: false,
      };
    }

    console.log(`Found webview page for plugin: ${pageFile}`);

    // Set up directories - src directory is where the App.tsx and other files will be generated
    const srcDir = path.join(webviewDir, 'src');
    await fileSystem.ensureDir(srcDir);

    // Generate App.tsx content for this single plugin
    let appContent = `// Auto-generated by cli: webview:buildPlugin
// Generated on: ${new Date().toISOString()}\n\n`;

    // Calculate relative path from src directory to the Page.tsx file
    const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');
    const formattedImportPath = importPath.startsWith('.')
      ? importPath
      : `../../${importPath}`;

    // Get unique import name for this plugin
    let relPlugin = '';

    // Use pathFromPluginsDir if available, otherwise use name
    if (plugin.pathFromPluginsDir) {
      relPlugin = plugin.pathFromPluginsDir;
    } else if (plugin.name) {
      relPlugin = plugin.name.replace(/[^a-zA-Z0-9_-]/g, '_');
    }

    const parts = relPlugin.split('/');
    const namespace = parts.length > 1 ? parts[0] : '';
    const pluginName = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

    // Clean up namespace and plugin name
    const nsClean = namespace.replace(/[\[\]\(\)\s-]/g, '');
    const pluginNameClean = pluginName
      .replace(/[\[\]\(\)\s]/g, '')
      .replace(/-/g, '_');

    // Create import name
    const importName = namespace
      ? `Page_${nsClean}_${pluginNameClean}`
      : `Page_${pluginNameClean}`;

    // Create a key for React component
    const key = namespace ? `${nsClean}/${pluginName}` : pluginName;

    // Add the import
    appContent += `import ${importName} from '${formattedImportPath}';\n\n`;

    // Create App component that only includes this plugin
    appContent += `const App = () => {
  return (
    <>
      <${importName} key="${key}" />
    </>
  );
};

export default App;\n`;

    // Write generated content to App.tsx
    const appFilePath = path.join(srcDir, 'App.tsx');
    await fileSystem.writeFile(appFilePath, appContent);
    console.log(`Generated ${appFilePath}`);

    // Create main.tsx file (same as in buildWebview)
    const mainTsxContent = `
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const mainTsxPath = path.join(srcDir, 'main.tsx');
    await fileSystem.writeFile(mainTsxPath, mainTsxContent);
    console.log(`Generated ${mainTsxPath}`);

    // Create or verify index.html
    const indexHtmlPath = path.join(srcDir, 'index.html');
    const indexHtmlExists = await fileSystem.exists(indexHtmlPath);

    if (!indexHtmlExists) {
      const indexHtmlContent = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plugin Webview - ${plugin.name || relPlugin}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>
`;
      await fileSystem.writeFile(indexHtmlPath, indexHtmlContent);
      console.log(`Generated ${indexHtmlPath}`);
    } else {
      // File exists, check if it has the correct main.tsx reference
      const indexHtmlContent = await fileSystem.readFile(indexHtmlPath, 'utf8');
      if (
        !indexHtmlContent.includes('./main.tsx') &&
        (indexHtmlContent.includes('/webview/main.tsx') ||
          indexHtmlContent.includes('"/main.tsx"'))
      ) {
        // Fix the path
        const updatedContent = indexHtmlContent
          .replace(/["']\/webview\/main\.tsx["']/g, '"./main.tsx"')
          .replace(/["']\/main\.tsx["']/g, '"./main.tsx"');

        await fileSystem.writeFile(indexHtmlPath, updatedContent);
        console.log(`Updated ${indexHtmlPath} with correct main.tsx path`);
      }
    }

    // Create index.css if it doesn't exist
    const indexCssPath = path.join(srcDir, 'index.css');
    const indexCssExists = await fileSystem.exists(indexCssPath);

    if (!indexCssExists) {
      // Create a basic CSS file
      const indexCssContent = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.h-dvh {
  height: 100dvh;
}
`;
      await fileSystem.writeFile(indexCssPath, indexCssContent);
      console.log(`Generated ${indexCssPath}`);
    }

    // Run Vite build directly to the plugin's directory
    console.log(`Running Vite build for plugin: ${relPlugin}...`);
    try {
      // Build directly to the plugin's html directory
      const buildCommand = `npx vite build --outDir=${htmlOutputDir}`;
      console.log(`Executing: ${buildCommand}`);

      // Use spawn to stream logs without buffering large output
      const child = spawn(buildCommand, {
        cwd: process.cwd(),
        shell: true,
        stdio: 'inherit',
        env: {
          ...process.env,
          PLUGIN_WEBVIEW_ID: relPlugin, // Can be used in vite.config.ts to customize the build
        },
      });
      await new Promise<void>((resolve, reject) => {
        child.on('close', (code) =>
          code === 0
            ? resolve()
            : reject(new Error(`Build command failed with exit code ${code}`))
        );
      });

      console.log(`Webview built successfully at: ${htmlOutputDir}`);

      // List files in the output directory
      const filePaths = fileSystem.getFilePaths(htmlOutputDir);

      // Log the contents for verification
      for (const filePath of filePaths) {
        const relativePath = path.relative(htmlOutputDir, filePath);
        console.log(`  [FILE] ${relativePath}`);
      }

      // Verify that the html directory contains the expected files
      const hasIndexHtml = filePaths.some(
        (file) => path.basename(file) === 'index.html'
      );
      const hasAssets = filePaths.some((file) => file.includes('assets/'));

      if (!hasIndexHtml) {
        console.warn(`Warning: No index.html found in ${htmlOutputDir}`);
      }

      if (!hasAssets) {
        console.warn(`Warning: No assets directory found in ${htmlOutputDir}`);
      }

      console.log(`--- End verification of ${webviewPluginDistDir} ---`);

      // Return an object with the html directory path and verification results
      return {
        htmlDir: htmlOutputDir,
        hasIndexHtml,
        hasAssets,
        success: hasIndexHtml, // Consider the build successful if at least index.html exists
      };
    } catch (error: any) {
      console.error(`Vite build for plugin ${relPlugin} failed:`, error);

      // Add more helpful error information
      let errorMessage = `Vite build for plugin ${relPlugin} failed: ${
        error?.message || error
      }`;

      // Check if index.html exists and has correct format
      if (await fileSystem.exists(indexHtmlPath)) {
        try {
          const indexHtmlContent = await fileSystem.readFile(
            indexHtmlPath,
            'utf8'
          );
          if (
            !indexHtmlContent.includes('./main.tsx') &&
            !indexHtmlContent.includes('main.tsx')
          ) {
            errorMessage +=
              '\nPossible cause: index.html does not reference main.tsx correctly.';
          }
        } catch (err) {
          errorMessage +=
            '\nPossible cause: index.html exists but cannot be read.';
        }
      } else {
        errorMessage += '\nPossible cause: index.html does not exist.';
      }

      // Return failure result
      return {
        htmlDir: htmlOutputDir,
        hasIndexHtml: false,
        hasAssets: false,
        success: false,
      };
    }
  } catch (error) {
    console.error(
      `Plugin webview build for ${
        plugin.pathFromPluginsDir || plugin.name || 'unknown'
      } failed:`,
      error
    );
    // Return failure result instead of throwing
    return {
      htmlDir:
        webviewPluginDistDir ||
        path.join(distDir, plugin.name || 'unknown', 'html'),
      hasIndexHtml: false,
      hasAssets: false,
      success: false,
    };
  }
}
/**
 * Copy built webview files to the resource's html directory
 * @param sourceBuildDir Source directory containing the Vite build output
 * @param targetHtmlDir Target html directory within the resource
 * @returns Promise that resolves when the copy operation is complete
 */
export async function copyBuildToResourceHtml(
  sourceBuildDir: string,
  targetHtmlDir: string
): Promise<void> {
  // Make sure target directory exists
  await fileSystem.ensureDir(targetHtmlDir);

  // Read all files from the source build directory
  const copyDir = async (src: string, dest: string) => {
    // Get all files in the source directory
    const filePaths = fileSystem.getFilePaths(src);

    for (const filePath of filePaths) {
      // Calculate the relative path from the source directory
      const relativePath = path.relative(src, filePath);
      // Calculate the destination path
      const destPath = path.join(dest, relativePath);

      // Ensure the destination directory exists
      await fileSystem.ensureDir(path.dirname(destPath));

      // Copy the file
      await fileSystem.copyFile(filePath, destPath);
    }
  };

  try {
    await copyDir(sourceBuildDir, targetHtmlDir);
    console.log(
      `Successfully copied webview files from ${sourceBuildDir} to ${targetHtmlDir}`
    );
  } catch (error) {
    console.error(`Error copying webview files:`, error);
    throw error;
  }
}
