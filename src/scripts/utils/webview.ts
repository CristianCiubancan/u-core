import * as path from 'path';
import * as fsPromises from 'fs/promises';
import { Plugin, ensureDirectoryExists } from './file.js';
import { exec, spawn } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Builds the webview UI by generating App.tsx and running the Vite build.
 * @param plugins Array of plugin objects
 * @param distDir The main distribution directory
 * @returns Promise<string> Path to the built webview directory
 */
export async function buildWebview(
  plugins: Plugin[],
  distDir: string
): Promise<string> {
  console.log('\nBuilding webview UI...');

  // Validate inputs
  if (!Array.isArray(plugins)) {
    throw new Error('Plugins must be an array');
  }

  if (!distDir) {
    throw new Error('Distribution directory must be provided');
  }

  // Path to the webview directory
  const webviewDir = path.join(process.cwd(), 'src/webview');
  const webviewDistDir = path.join(distDir, 'webview');

  try {
    // Verify webview source directory exists
    try {
      await fsPromises.access(webviewDir);
    } catch (error) {
      throw new Error(`Webview directory not found: ${webviewDir}`);
    }

    // Make sure the output directory exists (Vite will clean it)
    await ensureDirectoryExists(webviewDistDir);

    // Find plugins with webview pages - we'll use Promise.all below instead of this filter
    // since async filters don't work as expected

    // Resolve the promises in the filter
    const resolvedWebviewPlugins = await Promise.all(
      plugins
        .filter((plugin) => plugin.hasHtml && plugin.fullPath)
        .map(async (plugin) => {
          const pageFile = path.join(plugin.fullPath!, 'html', 'Page.tsx');
          try {
            await fsPromises.access(pageFile);
            return plugin;
          } catch {
            return null;
          }
        })
    );

    // Filter out null values
    const validWebviewPlugins = resolvedWebviewPlugins.filter(
      Boolean
    ) as Plugin[];

    console.log(
      `Found ${validWebviewPlugins.length} plugins with webview pages`
    );

    if (validWebviewPlugins.length === 0) {
      console.log('No webview plugins found, skipping App.tsx generation');
      return webviewDistDir;
    }

    // Set up directories - src directory is where the App.tsx and other files will be generated
    const srcDir = path.join(webviewDir, 'src');
    await ensureDirectoryExists(srcDir);

    // Generate App.tsx content
    let appContent = `// Auto-generated by cli: webview:build
// Generated on: ${new Date().toISOString()}\n\n`;

    const imports: string[] = [];
    const components: string[] = [];

    // Track used import names to avoid duplicates
    const usedImportNames = new Set<string>();

    for (const plugin of validWebviewPlugins) {
      if (!plugin.fullPath) continue;

      const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

      // Calculate relative path from src directory (Vite root) to the Page.tsx file
      // We need to make the import path relative to the src/webview/src directory
      const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');
      // Make sure the path is properly formatted for import
      // If the path doesn't start with '.', it's not a relative path, so make it one
      const formattedImportPath = importPath.startsWith('.')
        ? importPath
        : `../../${importPath}`;

      // Get the plugin's path relative to plugins directory
      const relPlugin = plugin.pathFromPluginsDir;
      const parts = relPlugin.split('/');
      const namespace = parts.length > 1 ? parts[0] : '';
      const pluginName = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

      // Clean up namespace and plugin name
      const nsClean = namespace.replace(/[\[\]\(\)\s-]/g, '');
      const pluginNameClean = pluginName
        .replace(/[\[\]\(\)\s]/g, '')
        .replace(/-/g, '_');

      // Create unique import name
      let importName = namespace
        ? `Page_${nsClean}_${pluginNameClean}`
        : `Page_${pluginNameClean}`;

      // Ensure import name is unique
      let counter = 1;
      let baseImportName = importName;
      while (usedImportNames.has(importName)) {
        importName = `${baseImportName}_${counter++}`;
      }
      usedImportNames.add(importName);

      // Create a key for React component - ensure it's unique and valid
      const key = namespace ? `${nsClean}/${pluginName}` : pluginName;

      imports.push(`import ${importName} from '${formattedImportPath}';`);
      components.push(`      <${importName} key="${key}" />`);
    }

    // Add imports
    appContent += imports.join('\n') + '\n\n';

    // Create App component
    appContent += `const App = () => {
  return (
    <>
${components.join('\n')}
    </>
  );
};

export default App;\n`;

    // Write generated content to App.tsx
    const appFilePath = path.join(srcDir, 'App.tsx');
    await fsPromises.writeFile(appFilePath, appContent);
    console.log(`Generated ${appFilePath}`);

    // Create main.tsx file
    const mainTsxContent = `import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const mainTsxPath = path.join(srcDir, 'main.tsx');
    await fsPromises.writeFile(mainTsxPath, mainTsxContent);
    console.log(`Generated ${mainTsxPath}`);

    // Create or verify index.html
    const indexHtmlPath = path.join(srcDir, 'index.html');
    let indexHtmlExists = false;

    try {
      await fsPromises.access(indexHtmlPath);
      indexHtmlExists = true;
    } catch {
      // File doesn't exist
    }

    if (!indexHtmlExists) {
      const indexHtmlContent = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webview</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>
`;
      await fsPromises.writeFile(indexHtmlPath, indexHtmlContent);
      console.log(`Generated ${indexHtmlPath}`);
    } else {
      // File exists, check if it has the correct main.tsx reference
      const indexHtmlContent = await fsPromises.readFile(indexHtmlPath, 'utf8');
      if (
        !indexHtmlContent.includes('./main.tsx') &&
        (indexHtmlContent.includes('/webview/main.tsx') ||
          indexHtmlContent.includes('"/main.tsx"'))
      ) {
        // Fix the path
        const updatedContent = indexHtmlContent
          .replace(/["']\/webview\/main\.tsx["']/g, '"./main.tsx"')
          .replace(/["']\/main\.tsx["']/g, '"./main.tsx"');

        await fsPromises.writeFile(indexHtmlPath, updatedContent);
        console.log(`Updated ${indexHtmlPath} with correct main.tsx path`);
      }
    }

    // Create index.css if it doesn't exist
    const indexCssPath = path.join(srcDir, 'index.css');
    try {
      await fsPromises.access(indexCssPath);
    } catch {
      // Create a basic CSS file
      const indexCssContent = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.h-dvh {
  height: 100dvh;
}
`;
      await fsPromises.writeFile(indexCssPath, indexCssContent);
      console.log(`Generated ${indexCssPath}`);
    }

    // Run Vite build - it will output directly to distDir/webview per vite.config.ts
    console.log('Running Vite build...');
    try {
      // First check if package.json exists and has a build script
      const packageJsonPath = path.join(process.cwd(), 'package.json');
      let useNpmRun = false;

      try {
        const packageJson = JSON.parse(
          await fsPromises.readFile(packageJsonPath, 'utf8')
        );
        if (packageJson.scripts && packageJson.scripts.build) {
          useNpmRun = true;
        }
      } catch {
        // No package.json or can't parse it - use npx vite build directly
      }

      // Always run Vite build directly to avoid recursion
      const buildCommand = 'npx vite build';
      console.log(`Executing: ${buildCommand}`);

      // use spawn to stream logs without buffering large output
      const child = spawn(buildCommand, {
        cwd: process.cwd(),
        shell: true,
        stdio: 'inherit',
      });
      await new Promise<void>((resolve, reject) => {
        child.on('close', (code) =>
          code === 0
            ? resolve()
            : reject(new Error(`Build command failed with exit code ${code}`))
        );
      });
    } catch (error: any) {
      console.error('Vite build failed:', error);

      // Add more helpful error information
      let errorMessage = `Vite build failed: ${error?.message || error}`;

      // Check if index.html exists and has correct format
      try {
        const indexHtmlPath = path.join(srcDir, 'index.html');
        const indexHtmlContent = await fsPromises.readFile(
          indexHtmlPath,
          'utf8'
        );

        if (
          !indexHtmlContent.includes('./main.tsx') &&
          !indexHtmlContent.includes('main.tsx')
        ) {
          errorMessage +=
            '\nPossible cause: index.html does not reference main.tsx correctly.';
        }
      } catch {
        errorMessage +=
          '\nPossible cause: index.html does not exist or cannot be read.';
      }

      throw new Error(errorMessage);
    }

    console.log('Webview build completed successfully!');
    return webviewDistDir;
  } catch (error) {
    console.error('Webview build failed:', error);
    throw error;
  }
}
