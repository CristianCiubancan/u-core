import * as path from 'path';
import * as fsPromises from 'fs/promises';
import { Plugin, ensureDirectoryExists } from './file';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Builds the webview UI by generating App.tsx and running the Vite build.
 * @param plugins Array of plugin objects
 * @param distDir The main distribution directory
 * @returns Promise<string> Path to the built webview directory
 */
export async function buildWebview(
  plugins: Plugin[],
  distDir: string
): Promise<string> {
  console.log('\nBuilding webview UI...');

  // Validate inputs
  if (!Array.isArray(plugins)) {
    throw new Error('Plugins must be an array');
  }

  if (!distDir) {
    throw new Error('Distribution directory must be provided');
  }

  const webviewDir = path.join(__dirname, '../../webview');
  const webviewDistDir = path.join(distDir, 'webview');

  try {
    // Verify webview source directory exists
    try {
      await fsPromises.access(webviewDir);
    } catch (error) {
      throw new Error(`Webview directory not found: ${webviewDir}`);
    }

    // Make sure the output directory exists (Vite will clean it)
    await ensureDirectoryExists(webviewDistDir);

    // Find plugins with webview pages
    const webviewPlugins = plugins.filter(async (plugin) => {
      if (!plugin.hasHtml || !plugin.fullPath) {
        return false;
      }

      // Verify the Page.tsx file exists
      const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');
      try {
        await fsPromises.access(pageFile);
        return true;
      } catch {
        return false;
      }
    });

    // Resolve the promises in the filter
    const resolvedWebviewPlugins = await Promise.all(
      plugins
        .filter((plugin) => plugin.hasHtml && plugin.fullPath)
        .map(async (plugin) => {
          const pageFile = path.join(plugin.fullPath!, 'html', 'Page.tsx');
          try {
            await fsPromises.access(pageFile);
            return plugin;
          } catch {
            return null;
          }
        })
    );

    // Filter out null values
    const validWebviewPlugins = resolvedWebviewPlugins.filter(
      Boolean
    ) as Plugin[];

    console.log(
      `Found ${validWebviewPlugins.length} plugins with webview pages`
    );

    if (validWebviewPlugins.length === 0) {
      console.log('No webview plugins found, skipping App.tsx generation');
      return webviewDistDir;
    }

    // Set up directories
    const srcDir = path.join(webviewDir, 'src');
    await ensureDirectoryExists(srcDir);

    // Generate App.tsx content
    let appContent = `// Auto-generated by cli: webview:build
// Generated on: ${new Date().toISOString()}

import React from 'react';\n\n`;

    const imports: string[] = [];
    const components: string[] = [];

    // Track used import names to avoid duplicates
    const usedImportNames = new Set<string>();

    for (const plugin of validWebviewPlugins) {
      if (!plugin.fullPath) continue;

      const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

      // Calculate relative path from src directory (Vite root) to the Page.tsx file
      const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');

      // Get the plugin's path relative to plugins directory
      const relPlugin = plugin.pathFromPluginsDir;
      const parts = relPlugin.split('/');
      const namespace = parts.length > 1 ? parts[0] : '';
      const pluginName = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

      // Clean up namespace and plugin name
      const nsClean = namespace.replace(/[\[\]\(\)\s-]/g, '');
      const pluginNameClean = pluginName
        .replace(/[\[\]\(\)\s]/g, '')
        .replace(/-/g, '_');

      // Create unique import name
      let importName = namespace
        ? `Page_${nsClean}_${pluginNameClean}`
        : `Page_${pluginNameClean}`;

      // Ensure import name is unique
      let counter = 1;
      let baseImportName = importName;
      while (usedImportNames.has(importName)) {
        importName = `${baseImportName}_${counter++}`;
      }
      usedImportNames.add(importName);

      const key = namespace ? `${nsClean}/${pluginName}` : pluginName;

      imports.push(`import ${importName} from '${importPath}';`);
      components.push(`      <${importName} key="${key}" />`);
    }

    // Add imports
    appContent += imports.join('\n') + '\n\n';

    // Create App component
    appContent += `const App = () => {
  return (
    <div className="h-dvh">
${components.join('\n')}
    </div>
  );
};

export default App;\n`;

    // Write generated content to App.tsx
    const appFilePath = path.join(srcDir, 'App.tsx');
    await fsPromises.writeFile(appFilePath, appContent);
    console.log(`Generated ${appFilePath}`);

    // Create main.tsx file
    const mainTsxContent = `import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const mainTsxPath = path.join(srcDir, 'main.tsx');
    await fsPromises.writeFile(mainTsxPath, mainTsxContent);
    console.log(`Generated ${mainTsxPath}`);

    // Create or verify index.html
    const indexHtmlPath = path.join(srcDir, 'index.html');
    let indexHtmlExists = false;

    try {
      await fsPromises.access(indexHtmlPath);
      indexHtmlExists = true;
    } catch {
      // File doesn't exist
    }

    if (!indexHtmlExists) {
      const indexHtmlContent = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webview</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>
`;
      await fsPromises.writeFile(indexHtmlPath, indexHtmlContent);
      console.log(`Generated ${indexHtmlPath}`);
    } else {
      // File exists, check if it has the correct main.tsx reference
      const indexHtmlContent = await fsPromises.readFile(indexHtmlPath, 'utf8');
      if (
        !indexHtmlContent.includes('./main.tsx') &&
        (indexHtmlContent.includes('/webview/main.tsx') ||
          indexHtmlContent.includes('"/main.tsx"'))
      ) {
        // Fix the path
        const updatedContent = indexHtmlContent
          .replace(/["']\/webview\/main\.tsx["']/g, '"./main.tsx"')
          .replace(/["']\/main\.tsx["']/g, '"./main.tsx"');

        await fsPromises.writeFile(indexHtmlPath, updatedContent);
        console.log(`Updated ${indexHtmlPath} with correct main.tsx path`);
      }
    }

    // Create index.css if it doesn't exist
    const indexCssPath = path.join(srcDir, 'index.css');
    try {
      await fsPromises.access(indexCssPath);
    } catch {
      // Create a basic CSS file
      const indexCssContent = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.h-dvh {
  height: 100dvh;
}
`;
      await fsPromises.writeFile(indexCssPath, indexCssContent);
      console.log(`Generated ${indexCssPath}`);
    }

    // Run Vite build - it will output directly to distDir/webview per vite.config.ts
    console.log('Running Vite build...');
    try {
      // First check if package.json exists and has a build script
      const packageJsonPath = path.join(webviewDir, 'package.json');
      let useNpmRun = false;

      try {
        const packageJson = JSON.parse(
          await fsPromises.readFile(packageJsonPath, 'utf8')
        );
        if (packageJson.scripts && packageJson.scripts.build) {
          useNpmRun = true;
        }
      } catch {
        // No package.json or can't parse it - use npx vite build directly
      }

      // Run the appropriate build command
      const buildCommand = useNpmRun ? 'npm run build' : 'npx vite build';
      console.log(`Executing: ${buildCommand}`);

      const { stdout, stderr } = await execAsync(buildCommand, {
        cwd: webviewDir,
      });
      if (stderr && !stderr.includes('built in')) {
        console.warn('Vite build warnings:', stderr);
      }
      console.log('Vite build output:', stdout);
    } catch (error) {
      console.error('Vite build failed:', error);

      // Add more helpful error information
      let errorMessage = `Vite build failed: ${error.message || error}`;

      // Check if index.html exists and has correct format
      try {
        const indexHtmlPath = path.join(webviewDir, 'src', 'index.html');
        const indexHtmlContent = await fsPromises.readFile(
          indexHtmlPath,
          'utf8'
        );

        if (
          !indexHtmlContent.includes('./main.tsx') &&
          !indexHtmlContent.includes('main.tsx')
        ) {
          errorMessage +=
            '\nPossible cause: index.html does not reference main.tsx correctly.';
        }
      } catch {
        errorMessage +=
          '\nPossible cause: index.html does not exist or cannot be read.';
      }

      throw new Error(errorMessage);
    }

    console.log('Webview build completed successfully!');
    return webviewDistDir;
  } catch (error) {
    console.error('Webview build failed:', error);
    throw error;
  }
}
