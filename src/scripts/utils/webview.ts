import * as path from 'path';
import * as fs from 'fs';
import * as fsPromises from 'fs/promises';
import { Plugin, ensureDirectoryExists } from './file.js';
import { exec, spawn } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * Builds the webview UI by generating App.tsx and running the Vite build.
 * @param plugins Array of plugin objects
 * @param distDir The main distribution directory
 * @returns Promise<string> Path to the built webview directory
 */
export async function buildWebview(
  plugins: Plugin[],
  distDir: string
): Promise<string> {
  console.log('\nBuilding webview UI...');

  // Validate inputs
  if (!Array.isArray(plugins)) {
    throw new Error('Plugins must be an array');
  }

  if (!distDir) {
    throw new Error('Distribution directory must be provided');
  }

  // Path to the webview directory
  const webviewDir = path.join(process.cwd(), 'src/webview');
  const webviewDistDir = path.join(distDir, 'webview');

  try {
    // Verify webview source directory exists
    try {
      await fsPromises.access(webviewDir);
    } catch (error) {
      throw new Error(`Webview directory not found: ${webviewDir}`);
    }

    // Make sure the output directory exists (Vite will clean it)
    await ensureDirectoryExists(webviewDistDir);

    // Find plugins with webview pages - we'll use Promise.all below instead of this filter
    // since async filters don't work as expected

    // Resolve the promises in the filter
    const resolvedWebviewPlugins = await Promise.all(
      plugins
        .filter((plugin) => plugin.hasHtml && plugin.fullPath)
        .map(async (plugin) => {
          const pageFile = path.join(plugin.fullPath!, 'html', 'Page.tsx');
          try {
            await fsPromises.access(pageFile);
            return plugin;
          } catch {
            return null;
          }
        })
    );

    // Filter out null values
    const validWebviewPlugins = resolvedWebviewPlugins.filter(
      Boolean
    ) as Plugin[];

    console.log(
      `Found ${validWebviewPlugins.length} plugins with webview pages`
    );

    if (validWebviewPlugins.length === 0) {
      console.log('No webview plugins found, skipping App.tsx generation');
      return webviewDistDir;
    }

    // Set up directories - src directory is where the App.tsx and other files will be generated
    const srcDir = path.join(webviewDir, 'src');
    await ensureDirectoryExists(srcDir);

    // Generate App.tsx content
    let appContent = `// Auto-generated by cli: webview:build
// Generated on: ${new Date().toISOString()}\n\n`;

    const imports: string[] = [];
    const components: string[] = [];

    // Track used import names to avoid duplicates
    const usedImportNames = new Set<string>();

    for (const plugin of validWebviewPlugins) {
      if (!plugin.fullPath) continue;

      const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

      // Calculate relative path from src directory (Vite root) to the Page.tsx file
      // We need to make the import path relative to the src/webview/src directory
      const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');
      // Make sure the path is properly formatted for import
      // If the path doesn't start with '.', it's not a relative path, so make it one
      const formattedImportPath = importPath.startsWith('.')
        ? importPath
        : `../../${importPath}`;

      // Get the plugin's path relative to plugins directory
      const relPlugin = plugin.pathFromPluginsDir;
      const parts = relPlugin.split('/');
      const namespace = parts.length > 1 ? parts[0] : '';
      const pluginName = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

      // Clean up namespace and plugin name
      const nsClean = namespace.replace(/[\[\]\(\)\s-]/g, '');
      const pluginNameClean = pluginName
        .replace(/[\[\]\(\)\s]/g, '')
        .replace(/-/g, '_');

      // Create unique import name
      let importName = namespace
        ? `Page_${nsClean}_${pluginNameClean}`
        : `Page_${pluginNameClean}`;

      // Ensure import name is unique
      let counter = 1;
      let baseImportName = importName;
      while (usedImportNames.has(importName)) {
        importName = `${baseImportName}_${counter++}`;
      }
      usedImportNames.add(importName);

      // Create a key for React component - ensure it's unique and valid
      const key = namespace ? `${nsClean}/${pluginName}` : pluginName;

      imports.push(`import ${importName} from '${formattedImportPath}';`);
      components.push(`      <${importName} key="${key}" />`);
    }

    // Add imports
    appContent += imports.join('\n') + '\n\n';

    // Create App component
    appContent += `const App = () => {
  return (
    <>
${components.join('\n')}
    </>
  );
};

export default App;\n`;

    // Write generated content to App.tsx
    const appFilePath = path.join(srcDir, 'App.tsx');
    await fsPromises.writeFile(appFilePath, appContent);
    console.log(`Generated ${appFilePath}`);

    // Create main.tsx file
    const mainTsxContent = `
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const mainTsxPath = path.join(srcDir, 'main.tsx');
    await fsPromises.writeFile(mainTsxPath, mainTsxContent);
    console.log(`Generated ${mainTsxPath}`);

    // Create or verify index.html
    const indexHtmlPath = path.join(srcDir, 'index.html');
    let indexHtmlExists = false;

    try {
      await fsPromises.access(indexHtmlPath);
      indexHtmlExists = true;
    } catch {
      // File doesn't exist
    }

    if (!indexHtmlExists) {
      const indexHtmlContent = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Webview</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>
`;
      await fsPromises.writeFile(indexHtmlPath, indexHtmlContent);
      console.log(`Generated ${indexHtmlPath}`);
    } else {
      // File exists, check if it has the correct main.tsx reference
      const indexHtmlContent = await fsPromises.readFile(indexHtmlPath, 'utf8');
      if (
        !indexHtmlContent.includes('./main.tsx') &&
        (indexHtmlContent.includes('/webview/main.tsx') ||
          indexHtmlContent.includes('"/main.tsx"'))
      ) {
        // Fix the path
        const updatedContent = indexHtmlContent
          .replace(/["']\/webview\/main\.tsx["']/g, '"./main.tsx"')
          .replace(/["']\/main\.tsx["']/g, '"./main.tsx"');

        await fsPromises.writeFile(indexHtmlPath, updatedContent);
        console.log(`Updated ${indexHtmlPath} with correct main.tsx path`);
      }
    }

    // Create index.css if it doesn't exist
    const indexCssPath = path.join(srcDir, 'index.css');
    try {
      await fsPromises.access(indexCssPath);
    } catch {
      // Create a basic CSS file
      const indexCssContent = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.h-dvh {
  height: 100dvh;
}
`;
      await fsPromises.writeFile(indexCssPath, indexCssContent);
      console.log(`Generated ${indexCssPath}`);
    }

    // Run Vite build - it will output directly to distDir/webview per vite.config.ts
    console.log('Running Vite build...');
    try {
      // First check if package.json exists and has a build script
      const packageJsonPath = path.join(process.cwd(), 'package.json');
      let useNpmRun = false;

      try {
        const packageJson = JSON.parse(
          await fsPromises.readFile(packageJsonPath, 'utf8')
        );
        if (packageJson.scripts && packageJson.scripts.build) {
          useNpmRun = true;
        }
      } catch {
        // No package.json or can't parse it - use npx vite build directly
      }

      // Always run Vite build directly to avoid recursion
      const buildCommand = 'npx vite build';
      console.log(`Executing: ${buildCommand}`);

      // use spawn to stream logs without buffering large output
      const child = spawn(buildCommand, {
        cwd: process.cwd(),
        shell: true,
        stdio: 'inherit',
      });
      await new Promise<void>((resolve, reject) => {
        child.on('close', (code) =>
          code === 0
            ? resolve()
            : reject(new Error(`Build command failed with exit code ${code}`))
        );
      });
    } catch (error: any) {
      console.error('Vite build failed:', error);

      // Add more helpful error information
      let errorMessage = `Vite build failed: ${error?.message || error}`;

      // Check if index.html exists and has correct format
      try {
        const indexHtmlPath = path.join(srcDir, 'index.html');
        const indexHtmlContent = await fsPromises.readFile(
          indexHtmlPath,
          'utf8'
        );

        if (
          !indexHtmlContent.includes('./main.tsx') &&
          !indexHtmlContent.includes('main.tsx')
        ) {
          errorMessage +=
            '\nPossible cause: index.html does not reference main.tsx correctly.';
        }
      } catch {
        errorMessage +=
          '\nPossible cause: index.html does not exist or cannot be read.';
      }

      throw new Error(errorMessage);
    }

    console.log('Webview build completed successfully!');
    return webviewDistDir;
  } catch (error) {
    console.error('Webview build failed:', error);
    throw error;
  }
}

/**
 * Builds a webview UI for a single plugin by generating App.tsx and running the Vite build.
 * @param plugin The plugin object to build the webview for
 * @param distDir The main distribution directory
 * @returns Promise<string> Path to the built plugin webview directory
 */
/**
 * Builds a webview UI for a single plugin by generating App.tsx and running the Vite build.
 * @param plugin The plugin object to build the webview for
 * @param distDir The main distribution directory
 * @returns Promise<string> Path to the built plugin webview directory
 */
export async function buildPluginWebview(
  plugin: Plugin,
  distDir: string
): Promise<string> {
  console.log(
    `\nBuilding webview UI for plugin: ${
      plugin.name || plugin.pathFromPluginsDir || 'unknown'
    }...`
  );

  // Validate inputs
  if (!plugin) {
    throw new Error('Plugin must be provided');
  }

  if (!distDir) {
    throw new Error('Distribution directory must be provided');
  }

  // Path to the webview directory
  const webviewDir = path.join(process.cwd(), 'src/webview');

  // Determine the plugin's resource path in the dist directory
  let resourcePath;
  let pluginRelativePath;

  if (plugin.pathFromPluginsDir) {
    // Check if the path starts with 'plugins/' and strip it if needed
    const normalizedPluginPath = path.normalize(plugin.pathFromPluginsDir);
    const pluginsPathNormalized = path.normalize('plugins');
    const pathContainsPluginsPrefix =
      normalizedPluginPath.startsWith(pluginsPathNormalized) ||
      normalizedPluginPath.startsWith(pluginsPathNormalized + path.sep);

    if (pathContainsPluginsPrefix) {
      // Strip the 'plugins/' prefix to place resources directly in dist
      pluginRelativePath = path.relative(
        pluginsPathNormalized,
        normalizedPluginPath
      );
      console.log(
        `Webview: Stripped 'plugins/' prefix from path: ${normalizedPluginPath} -> ${pluginRelativePath}`
      );
    } else {
      pluginRelativePath = normalizedPluginPath;
    }

    // Convert the plugin path to a resource path in dist
    // For example: "[misc]/example" -> "dist/[misc]/example"
    resourcePath = path.join(distDir, pluginRelativePath);
  } else if (plugin.fullPath) {
    // Extract resource name from fullPath if possible
    const pluginDir = path.basename(plugin.fullPath);
    resourcePath = path.join(distDir, pluginDir);
    pluginRelativePath = pluginDir;
  } else {
    // Fallback to name if nothing else is available
    resourcePath = path.join(distDir, plugin.name);
    pluginRelativePath = plugin.name;
  }

  // Create the html directory within the resource where webview files will be placed
  const htmlOutputDir = path.join(resourcePath, 'html');

  // Extract plugin path parts for the build output directory
  const pluginDistPathParts = pluginRelativePath
    ? pluginRelativePath.split('/')
    : [plugin.name];

  console.log('Plugin path parts for webview build:', pluginDistPathParts);

  // This is where Vite will directly output the build
  const webviewPluginDistDir = path.join(distDir, ...pluginDistPathParts);
  console.log('Webview plugin dist directory:', webviewPluginDistDir);

  try {
    // Verify webview source directory exists
    try {
      await fs.promises.access(webviewDir);
    } catch (error) {
      throw new Error(`Webview directory not found: ${webviewDir}`);
    }

    // Make sure the output directory exists
    await ensureDirectoryExists(webviewPluginDistDir);

    // Check if plugin has a webview page
    if (!plugin.hasHtml || !plugin.fullPath) {
      console.log('Plugin does not have webview pages, skipping build');
      return webviewPluginDistDir;
    }

    const pageFile = path.join(plugin.fullPath, 'html', 'Page.tsx');

    try {
      await fs.promises.access(pageFile);
    } catch {
      console.log('Plugin does not have a Page.tsx file, skipping build');
      return webviewPluginDistDir;
    }

    console.log(`Found webview page for plugin: ${pageFile}`);

    // Set up directories - src directory is where the App.tsx and other files will be generated
    const srcDir = path.join(webviewDir, 'src');
    await ensureDirectoryExists(srcDir);

    // Generate App.tsx content for this single plugin
    let appContent = `// Auto-generated by cli: webview:buildPlugin
// Generated on: ${new Date().toISOString()}\n\n`;

    // Calculate relative path from src directory to the Page.tsx file
    const importPath = path.relative(srcDir, pageFile).replace(/\\/g, '/');
    const formattedImportPath = importPath.startsWith('.')
      ? importPath
      : `../../${importPath}`;

    // Get unique import name for this plugin
    let relPlugin = '';

    // Use pathFromPluginsDir if available, otherwise use name
    if (plugin.pathFromPluginsDir) {
      relPlugin = plugin.pathFromPluginsDir;
    } else if (plugin.name) {
      relPlugin = plugin.name.replace(/[^a-zA-Z0-9_-]/g, '_');
    }

    const parts = relPlugin.split('/');
    const namespace = parts.length > 1 ? parts[0] : '';
    const pluginName = parts.length > 1 ? parts.slice(1).join('_') : parts[0];

    // Clean up namespace and plugin name
    const nsClean = namespace.replace(/[\[\]\(\)\s-]/g, '');
    const pluginNameClean = pluginName
      .replace(/[\[\]\(\)\s]/g, '')
      .replace(/-/g, '_');

    // Create import name
    const importName = namespace
      ? `Page_${nsClean}_${pluginNameClean}`
      : `Page_${pluginNameClean}`;

    // Create a key for React component
    const key = namespace ? `${nsClean}/${pluginName}` : pluginName;

    // Add the import
    appContent += `import ${importName} from '${formattedImportPath}';\n\n`;

    // Create App component that only includes this plugin
    appContent += `const App = () => {
  return (
    <>
      <${importName} key="${key}" />
    </>
  );
};

export default App;\n`;

    // Write generated content to App.tsx
    const appFilePath = path.join(srcDir, 'App.tsx');
    await fs.promises.writeFile(appFilePath, appContent);
    console.log(`Generated ${appFilePath}`);

    // Create main.tsx file (same as in buildWebview)
    const mainTsxContent = `
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const mainTsxPath = path.join(srcDir, 'main.tsx');
    await fs.promises.writeFile(mainTsxPath, mainTsxContent);
    console.log(`Generated ${mainTsxPath}`);

    // Create or verify index.html
    const indexHtmlPath = path.join(srcDir, 'index.html');
    let indexHtmlExists = false;

    try {
      await fs.promises.access(indexHtmlPath);
      indexHtmlExists = true;
    } catch {
      // File doesn't exist
    }

    if (!indexHtmlExists) {
      const indexHtmlContent = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Plugin Webview - ${plugin.name || relPlugin}</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./main.tsx"></script>
  </body>
</html>
`;
      await fs.promises.writeFile(indexHtmlPath, indexHtmlContent);
      console.log(`Generated ${indexHtmlPath}`);
    } else {
      // File exists, check if it has the correct main.tsx reference
      const indexHtmlContent = await fs.promises.readFile(
        indexHtmlPath,
        'utf8'
      );
      if (
        !indexHtmlContent.includes('./main.tsx') &&
        (indexHtmlContent.includes('/webview/main.tsx') ||
          indexHtmlContent.includes('"/main.tsx"'))
      ) {
        // Fix the path
        const updatedContent = indexHtmlContent
          .replace(/["']\/webview\/main\.tsx["']/g, '"./main.tsx"')
          .replace(/["']\/main\.tsx["']/g, '"./main.tsx"');

        await fs.promises.writeFile(indexHtmlPath, updatedContent);
        console.log(`Updated ${indexHtmlPath} with correct main.tsx path`);
      }
    }

    // Create index.css if it doesn't exist
    const indexCssPath = path.join(srcDir, 'index.css');
    try {
      await fs.promises.access(indexCssPath);
    } catch {
      // Create a basic CSS file
      const indexCssContent = `* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.h-dvh {
  height: 100dvh;
}
`;
      await fs.promises.writeFile(indexCssPath, indexCssContent);
      console.log(`Generated ${indexCssPath}`);
    }

    // Run Vite build directly to the plugin's directory
    console.log(`Running Vite build for plugin: ${relPlugin}...`);
    try {
      // Build directly to the plugin's html directory
      const buildCommand = `npx vite build --outDir=${htmlOutputDir}`;
      console.log(`Executing: ${buildCommand}`);

      // Use spawn to stream logs without buffering large output
      const child = spawn(buildCommand, {
        cwd: process.cwd(),
        shell: true,
        stdio: 'inherit',
        env: {
          ...process.env,
          PLUGIN_WEBVIEW_ID: relPlugin, // Can be used in vite.config.ts to customize the build
        },
      });
      await new Promise<void>((resolve, reject) => {
        child.on('close', (code) =>
          code === 0
            ? resolve()
            : reject(new Error(`Build command failed with exit code ${code}`))
        );
      });

      console.log(`Webview built successfully at: ${htmlOutputDir}`);
      const files = await fs.promises.readdir(htmlOutputDir, {
        withFileTypes: true,
      });

      // Log the contents for verification
      for (const file of files) {
        if (file.isDirectory()) {
          console.log(`  [DIR] ${file.name}`);
        } else {
          const stats = await fs.promises.stat(
            path.join(htmlOutputDir, file.name)
          );
          console.log(`  [FILE] ${file.name} (${stats.size} bytes)`);
        }
      }
      console.log(`--- End verification of ${webviewPluginDistDir} ---`);
    } catch (error: any) {
      console.error(`Vite build for plugin ${relPlugin} failed:`, error);

      // Add more helpful error information
      let errorMessage = `Vite build for plugin ${relPlugin} failed: ${
        error?.message || error
      }`;

      // Check if index.html exists and has correct format
      try {
        const indexHtmlContent = await fs.promises.readFile(
          indexHtmlPath,
          'utf8'
        );
        if (
          !indexHtmlContent.includes('./main.tsx') &&
          !indexHtmlContent.includes('main.tsx')
        ) {
          errorMessage +=
            '\nPossible cause: index.html does not reference main.tsx correctly.';
        }
      } catch {
        errorMessage +=
          '\nPossible cause: index.html does not exist or cannot be read.';
      }

      throw new Error(errorMessage);
    }

    console.log(
      `Plugin webview build for ${relPlugin} completed successfully!`
    );
    return htmlOutputDir; // Return the html directory path
  } catch (error) {
    console.error(
      `Plugin webview build for ${
        plugin.pathFromPluginsDir || plugin.name || 'unknown'
      } failed:`,
      error
    );
    throw error;
  }
}
/**
 * Copy built webview files to the resource's html directory
 * @param sourceBuildDir Source directory containing the Vite build output
 * @param targetHtmlDir Target html directory within the resource
 */
async function copyBuildToResourceHtml(
  sourceBuildDir: string,
  targetHtmlDir: string
): Promise<void> {
  // Make sure target directory exists
  await ensureDirectoryExists(targetHtmlDir);

  // Read all files from the source build directory
  const copyDir = async (src: string, dest: string) => {
    // Read directory contents
    const entries = await fs.promises.readdir(src, { withFileTypes: true });

    for (const entry of entries) {
      const srcPath = path.join(src, entry.name);
      const destPath = path.join(dest, entry.name);

      if (entry.isDirectory()) {
        // Create destination directory
        await ensureDirectoryExists(destPath);
        // Recursively copy subdirectory
        await copyDir(srcPath, destPath);
      } else {
        // Copy file
        await fs.promises.copyFile(srcPath, destPath);
      }
    }
  };

  try {
    await copyDir(sourceBuildDir, targetHtmlDir);
    console.log(
      `Successfully copied webview files from ${sourceBuildDir} to ${targetHtmlDir}`
    );
  } catch (error) {
    console.error(`Error copying webview files:`, error);
    throw error;
  }
}
