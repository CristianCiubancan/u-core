# .\plugins\accessibleText.ts

// src/theme/plugins/accessibleText.ts
// Refactored to use theme tokens and reduce hardcoded values

import { getContrastRatio, hexToRgb } from '../utils/colorUtils';
import { typography, defaultColors, shadowOpacity } from '../tokens/constants';

/**
 * Plugin parameter types
 */
interface AccessibleTextPluginParams {
  addComponents: (components: Record<string, any>, variants?: string[]) => void;
  theme: (path: string) => any;
}

/**
 * Creates accessible text utilities for various backgrounds
 */
export function accessibleTextPlugin({
  addComponents,
  theme,
}: AccessibleTextPluginParams) {
  const colors = theme('colors');

  // Get color references
  const gray = colors.gray || {};
  const primary = colors.primary || {};
  const error = colors.error || {};
  const success = colors.success || {};
  const warning = colors.warning || {};
  const info = colors.info || {};

  // Get semantic tokens if available
  const textPrimary = theme('colors.text.primary');
  const textInverted = theme('colors.text.inverted');
  /* Removed unused variable */
  const fontWeightMedium =
    theme('fontWeight.medium') || typography.fontWeight.medium;
  const fontWeightNormal =
    theme('fontWeight.normal') || typography.fontWeight.normal;
  const letterSpacingWide =
    theme('letterSpacing.wide') || typography.letterSpacing.wide;
  const letterSpacingNormal =
    theme('letterSpacing.normal') || typography.letterSpacing.normal;

  // Base text colors using semantic tokens when available
  const darkText = textPrimary || gray[900] || defaultColors.darkText;
  const lightText = textInverted || gray[50] || defaultColors.lightText;

  // Calculate contrast information for primary brand color
  const primaryIsDark =
    getContrastRatio(
      primary[600] || defaultColors.primaryDefault[600],
      lightText
    ) < 4.5;

  // Create accessible text utilities with semantic tokens
  const accessibleTextComponents = {
    // For light backgrounds - use dark text
    '.text-on-light': {
      'color': darkText,
      'font-weight': fontWeightMedium,
    },

    // For dark backgrounds - use light text
    '.text-on-dark': {
      'color': lightText,
      'font-weight': fontWeightNormal,
      'letter-spacing': letterSpacingWide,
    },

    // For the brand color as background - dynamically choose text color
    '.text-on-brand': {
      'color': primaryIsDark ? darkText : lightText,
      'font-weight': primaryIsDark ? fontWeightMedium : fontWeightNormal,
      'letter-spacing': primaryIsDark ? letterSpacingNormal : letterSpacingWide,
    },

    // For glass elements with dark backdrop
    '.text-on-glass-dark': {
      'color': lightText,
      'text-shadow': `0 1px 2px rgba(${hexToRgb(
        theme('colors.gray.900') || gray[900] || defaultColors.grayDark[900]
      )}, ${shadowOpacity.light})`,
      'letter-spacing': letterSpacingWide,
    },

    // For glass elements with light backdrop
    '.text-on-glass-light': {
      'color': darkText,
      'font-weight': fontWeightMedium,
    },

    // Semantic text styles that are already WCAG AA compliant
    '.text-primary': {
      'color': theme('colors.text.primary'),
      'font-weight':
        theme('fontWeight.semibold') || typography.fontWeight.semibold,
    },

    '.text-secondary': {
      'color': theme('colors.text.secondary'),
      'font-weight': theme('fontWeight.normal') || typography.fontWeight.normal,
    },

    '.text-tertiary': {
      'color': theme('colors.text.tertiary'),
      'font-weight': theme('fontWeight.normal') || typography.fontWeight.normal,
    },

    '.text-inverted': {
      'color': theme('colors.text.inverted'),
      'font-weight': theme('fontWeight.normal') || typography.fontWeight.normal,
    },

    '.text-link': {
      'color': theme('colors.text.link'),
      'font-weight':
        theme('fontWeight.semibold') || typography.fontWeight.semibold,
      'text-decoration': 'none',
      '&:hover': {
        'text-decoration': 'underline',
      },
    },

    '.text-success': {
      'color': theme('colors.text.success'),
      'font-weight':
        theme('fontWeight.semibold') || typography.fontWeight.semibold,
    },

    '.text-error': {
      'color': theme('colors.text.error'),
      'font-weight':
        theme('fontWeight.semibold') || typography.fontWeight.semibold,
    },

    '.text-warning': {
      'color': theme('colors.text.warning'),
      'font-weight':
        theme('fontWeight.semibold') || typography.fontWeight.semibold,
    },

    '.text-info': {
      'color': theme('colors.text.info'),
      'font-weight':
        theme('fontWeight.semibold') || typography.fontWeight.semibold,
    },

    // Additional contrast-ensuring utilities
    '.high-contrast': {
      'font-weight':
        theme('fontWeight.semibold') || typography.fontWeight.semibold,
      'letter-spacing':
        theme('letterSpacing.wide') || typography.letterSpacing.wide,
    },

    '.text-shadow-light': {
      'text-shadow': `0 1px 2px rgba(${hexToRgb(
        theme('colors.gray.900') || gray[900] || defaultColors.grayDark[900]
      )}, ${shadowOpacity.subtle})`,
    },

    '.text-shadow-dark': {
      'text-shadow': `0 1px 3px rgba(${hexToRgb(
        theme('colors.gray.900') || gray[900] || defaultColors.grayDark[900]
      )}, ${shadowOpacity.medium})`,
    },

    // NEW: Text on primary surface using theme tokens
    '.text-on-primary-surface': {
      'color': theme('colors.primary.800') || primary[800],
      'font-weight': theme('fontWeight.medium') || typography.fontWeight.medium,
    },

    // NEW: Text on success surface using theme tokens
    '.text-on-success-surface': {
      'color': theme('colors.success.800') || success[800],
      'font-weight': theme('fontWeight.medium') || typography.fontWeight.medium,
    },

    // NEW: Text on error surface using theme tokens
    '.text-on-error-surface': {
      'color': theme('colors.error.800') || error[800],
      'font-weight': theme('fontWeight.medium') || typography.fontWeight.medium,
    },

    // NEW: Text on warning surface using theme tokens
    '.text-on-warning-surface': {
      'color': theme('colors.warning.800') || warning[800],
      'font-weight': theme('fontWeight.medium') || typography.fontWeight.medium,
    },

    // NEW: Text on info surface using theme tokens
    '.text-on-info-surface': {
      'color': theme('colors.info.800') || info[800],
      'font-weight': theme('fontWeight.medium') || typography.fontWeight.medium,
    },

    // NEW: Text with auto-contrast (computed at runtime via CSS variables)
    '.text-auto-contrast': {
      'color': 'var(--auto-contrast-text-color, inherit)',
      'font-weight': 'var(--auto-contrast-font-weight, inherit)',
      'letter-spacing': 'var(--auto-contrast-letter-spacing, inherit)',
    },
  };

  addComponents(accessibleTextComponents, ['responsive', 'hover']);
}


================================================================================

# .\plugins\glassMorphism.ts

// src/theme/plugins/glassMorphism.ts - Refactored for FiveM compatibility
// Enhanced with token references and reduced hardcoded values

import { hexToRgb } from '../utils/colorUtils';
import { borders, opacityLevels, shadowOpacity } from '../tokens/constants';

/**
 * Plugin parameter types
 */
interface GlassMorphismPluginParams {
  addComponents: (components: Record<string, any>, variants?: string[]) => void;
  theme: (path: string) => any;
}

/**
 * Glass morphism plugin for Tailwind CSS - FiveM compatible version
 * Removed backdrop-filter properties that aren't supported
 * Enhanced with theme token references
 */
export function glassMorphismPlugin({
  addComponents,
  theme,
}: GlassMorphismPluginParams) {
  // Get color palette references
  const colors = theme('colors');
  const gray = colors.gray || {};
  const primary = colors.primary || {};

  // Get semantic color references
  /* Removed unused variable */
  /* Removed unused variable */
  /* Removed unused variable */
  /* Removed unused variable */

  // Elevation references
  const shadowSm = theme('boxShadow.sm');
  const shadowMd = theme('boxShadow.md');
  const shadowLg = theme('boxShadow.lg');

  // Define glass variants
  const glassVariants = {
    // Standard light glass effect
    '.glass': createGlassStyles({
      background: `rgba(${hexToRgb(
        theme('colors.gray.50') || gray[50] || '#ffffff'
      )}, ${opacityLevels.light.high})`,
      border: `rgba(${hexToRgb(
        theme('colors.gray.100') || gray[100] || '#f3f4f6'
      )}, ${opacityLevels.light.medium})`,
      shadowColor: theme('colors.gray.900') || gray[900],
      shadowOpacity: shadowOpacity.light,
      borderRadius: theme('borderRadius.xl'),
    }),

    // Dark glass effect
    '.glass-dark': createGlassStyles({
      background: `rgba(${hexToRgb(
        theme('colors.gray.900') || gray[900] || '#111827'
      )}, ${opacityLevels.dark.medium})`,
      border: `rgba(${hexToRgb(
        theme('colors.gray.800') || gray[800] || '#1f2937'
      )}, ${opacityLevels.light.medium})`,
      shadowColor: theme('colors.gray.950') || gray[950] || gray[900],
      shadowOpacity: shadowOpacity.medium,
      borderRadius: theme('borderRadius.xl'),
    }),

    // Brand-colored glass effect
    '.glass-brand': createGlassStyles({
      background: `rgba(${hexToRgb(
        theme('colors.primary.500') || primary[500]
      )}, ${opacityLevels.brand.low})`,
      border: `rgba(${hexToRgb(theme('colors.primary.400') || primary[400])}, ${
        opacityLevels.brand.medium
      })`,
      shadowColor: theme('colors.primary.700') || primary[700],
      shadowOpacity: shadowOpacity.medium,
      borderRadius: theme('borderRadius.xl'),
    }),

    // Dark brand-colored glass effect
    '.glass-brand-dark': createGlassStyles({
      background: `rgba(${hexToRgb(
        theme('colors.primary.800') || primary[800]
      )}, ${opacityLevels.dark.medium})`,
      border: `rgba(${hexToRgb(theme('colors.primary.700') || primary[700])}, ${
        opacityLevels.light.medium
      })`,
      shadowColor: theme('colors.primary.900') || primary[900],
      shadowOpacity: shadowOpacity.strong,
      borderRadius: theme('borderRadius.xl'),
    }),

    // Just background effect without borders/shadows
    '.glass-bg': {
      'background': `rgba(${hexToRgb(
        theme('colors.gray.50') || gray[50] || '#ffffff'
      )}, ${opacityLevels.light.high})`,
    },

    '.glass-bg-dark': {
      'background': `rgba(${hexToRgb(
        theme('colors.gray.900') || gray[900] || '#111827'
      )}, ${opacityLevels.dark.medium})`,
    },

    // Special subtle glass variants
    '.glass-subtle': {
      'background': `rgba(${hexToRgb(
        theme('colors.gray.50') || gray[50] || '#ffffff'
      )}, ${opacityLevels.light.medium})`,
      'border': `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.100') || gray[100] || '#f3f4f6'
      )}, ${opacityLevels.light.low})`,
      'border-radius': theme('borderRadius.xl'),
    },

    '.glass-subtle-dark': {
      'background': `rgba(${hexToRgb(
        theme('colors.gray.900') || gray[900] || '#111827'
      )}, ${opacityLevels.dark.low})`,
      'border': `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.800') || gray[800] || '#1f2937'
      )}, ${opacityLevels.light.low})`,
      'border-radius': theme('borderRadius.xl'),
    },

    // Gaming UI specific glass styles - Using theme tokens
    '.glass-gaming': {
      'background': `rgba(${hexToRgb(theme('colors.gray.900') || gray[900])}, ${
        opacityLevels.dark.high
      })`,
      'border': `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.700') || gray[700]
      )}, ${opacityLevels.light.low})`,
      'border-radius': theme('borderRadius.DEFAULT'),
      'box-shadow':
        shadowMd ||
        `0 4px 16px rgba(${hexToRgb(
          theme('colors.gray.950') || gray[950] || gray[900]
        )}, ${shadowOpacity.medium})`,
    },

    // Gaming UI button glass effect - Using theme tokens
    '.glass-button': {
      'background': `rgba(${hexToRgb(theme('colors.gray.800') || gray[800])}, ${
        opacityLevels.dark.high
      })`,
      'border': `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.600') || gray[600]
      )}, ${opacityLevels.light.low})`,
      'border-radius': theme('borderRadius.DEFAULT'),
      'transition': theme('transitionProperty.DEFAULT'),
      '&:hover': {
        'background': `rgba(${hexToRgb(
          theme('colors.gray.700') || gray[700]
        )}, ${opacityLevels.dark.high})`,
        'box-shadow':
          shadowSm ||
          `0 4px 12px rgba(${hexToRgb(
            theme('colors.gray.950') || gray[950] || gray[900]
          )}, ${shadowOpacity.medium})`,
      },
    },

    // Gaming UI header glass effect - Using theme tokens
    '.glass-header': {
      'background': `rgba(${hexToRgb(theme('colors.gray.900') || gray[900])}, ${
        opacityLevels.dark.high
      })`,
      'border-bottom': `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.800') || gray[800]
      )}, ${opacityLevels.light.low})`,
      'box-shadow': `0 4px 6px rgba(${hexToRgb(
        theme('colors.gray.950') || gray[950] || gray[900]
      )}, ${shadowOpacity.light})`,
    },

    // Gaming UI sidebar glass effect - Using theme tokens
    '.glass-sidebar': {
      'background': `rgba(${hexToRgb(theme('colors.gray.900') || gray[900])}, ${
        opacityLevels.dark.high
      })`,
      'border-right': `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.800') || gray[800]
      )}, ${opacityLevels.light.low})`,
      'box-shadow':
        shadowLg ||
        `4px 0 16px rgba(${hexToRgb(
          theme('colors.gray.950') || gray[950] || gray[900]
        )}, ${shadowOpacity.medium})`,
    },

    // Gaming UI active/selected item - Using theme tokens
    '.glass-active': {
      'background': `rgba(${hexToRgb(
        theme('colors.primary.600') || primary[600]
      )}, ${opacityLevels.light.high})`,
      'border': `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.primary.400') || primary[400]
      )}, ${opacityLevels.light.high})`,
      'box-shadow': `0 2px 8px rgba(${hexToRgb(
        theme('colors.primary.900') || primary[900]
      )}, ${shadowOpacity.intense})`,
    },
  };

  addComponents(glassVariants, ['responsive', 'hover']);
}

// Modified styleUtils.ts for FiveM compatibility
// Removed backdrop-filter from glass styles

/**
 * Creates glass effect styles with optimized properties for FiveM
 * Removed backdrop blur properties
 * @param config - Glass effect configuration
 * @returns Object with CSS properties for glass effect
 */
export function createGlassStyles(config: GlassConfig) {
  const { background, border, shadowColor, shadowOpacity, borderRadius } =
    config;

  const rgbShadowColor = hexToRgb(shadowColor);

  return {
    'background': background,
    'border': `${borders.width.thin} solid ${border}`,
    'border-radius': borderRadius,
    'box-shadow': `0 8px 32px rgba(${rgbShadowColor}, ${shadowOpacity})`,
  };
}

// Responsive typography generator - Updated to use theme tokens
export function generateResponsiveTypography(theme: (path: string) => any) {
  /* Removed unused variable */
  const lineHeight = theme('lineHeight') || {};

  return {
    // Generate fluid typography utilities with theme references
    '.text-fluid-xs': {
      'fontSize': 'clamp(0.75rem, 0.7rem + 0.25vw, 0.875rem)',
      'lineHeight': lineHeight.normal || '1.5',
    },
    '.text-fluid-sm': {
      'fontSize': 'clamp(0.875rem, 0.8rem + 0.375vw, 1rem)',
      'lineHeight': lineHeight.normal || '1.5',
    },
    '.text-fluid-base': {
      'fontSize': 'clamp(1rem, 0.9rem + 0.5vw, 1.125rem)',
      'lineHeight': lineHeight.normal || '1.5',
    },
    '.text-fluid-lg': {
      'fontSize': 'clamp(1.125rem, 1rem + 0.625vw, 1.25rem)',
      'lineHeight': lineHeight.normal || '1.5',
    },
    '.text-fluid-xl': {
      'fontSize': 'clamp(1.25rem, 1.1rem + 0.75vw, 1.5rem)',
      'lineHeight': lineHeight.relaxed || '1.4',
    },
    '.text-fluid-2xl': {
      'fontSize': 'clamp(1.5rem, 1.3rem + 1vw, 1.875rem)',
      'lineHeight': lineHeight.relaxed || '1.3',
    },
    '.text-fluid-3xl': {
      'fontSize': 'clamp(1.875rem, 1.6rem + 1.375vw, 2.25rem)',
      'lineHeight': lineHeight.tight || '1.2',
    },
    '.text-fluid-4xl': {
      'fontSize': 'clamp(2.25rem, 1.9rem + 1.75vw, 3rem)',
      'lineHeight': lineHeight.tight || '1.1',
    },
    '.text-fluid-5xl': {
      'fontSize': 'clamp(3rem, 2.5rem + 2.5vw, 4rem)',
      'lineHeight': lineHeight.tight || '1',
    },

    // Utilities for high-resolution displays
    '.text-hd': {
      '-webkit-font-smoothing': 'antialiased',
      '-moz-osx-font-smoothing': 'grayscale',
      'font-feature-settings': '"kern" 1, "liga" 1, "calt" 1',
    },

    // Utilities for maximum readability
    '.text-readable': {
      'max-width': '70ch',
      'word-spacing': '0.05em',
      // Removed 'hyphens': 'auto' as it might not be well supported
    },
  };
}

// Updated constants.ts - keep blur levels for reference but they won't be used

/**
 * Blur levels - kept for reference but not used in FiveM
 */
export const blurLevels = {
  none: '0px',
  sm: '4px',
  md: '8px',
  lg: '12px',
  xl: '16px',
  '2xl': '24px',
};

// Updated GlassConfig interface for styleUtils.ts

/**
 * Glass effect configuration - FiveM compatible
 * Removed backdropBlur property
 */
export interface GlassConfig {
  background: string;
  border: string;
  shadowColor: string;
  shadowOpacity: number;
  borderRadius: string;
}


================================================================================

# .\plugins\scrollbar.ts

// src/theme/plugins/scrollbar.ts
// Refactored to use theme tokens and reduce hardcoded values

import { hexToRgb } from '../utils/colorUtils';
import { scrollbars, opacityLevels, borders } from '../tokens/constants';

/**
 * Scrollbar configuration interface
 */
interface ScrollbarConfig {
  trackBg: string;
  thumbBg: string;
  thumbBorder: string;
  thumbHoverBg: string;
  width?: string;
  height?: string;
  borderRadius?: string;
}

/**
 * Plugin parameter types
 */
interface ScrollbarPluginParams {
  addBase: (baseStyles: Record<string, any>) => void;
  addComponents: (components: Record<string, any>, variants?: string[]) => void;
  theme: (path: string) => any;
}

/**
 * Creates consistent scrollbar styles
 */
function createScrollbarStyles({
  trackBg,
  thumbBg,
  thumbBorder,
  thumbHoverBg,
  width = scrollbars.width.default,
  height = scrollbars.width.default,
  borderRadius = scrollbars.borderRadius.default,
}: ScrollbarConfig) {
  return {
    // WebKit-based browsers (Chrome, Safari, newer versions of Edge)
    '&::-webkit-scrollbar': {
      width,
      height,
    },
    '&::-webkit-scrollbar-track': {
      background: trackBg,
      borderRadius,
    },
    '&::-webkit-scrollbar-thumb': {
      background: thumbBg,
      borderRadius,
      border: thumbBorder,
    },
    '&::-webkit-scrollbar-thumb:hover': {
      background: thumbHoverBg,
    },

    // Firefox
    'scrollbar-width': 'thin',
    'scrollbar-color': `${thumbBg} ${trackBg}`,
  };
}

/**
 * Scrollbar plugin for Tailwind CSS
 */
export function scrollbarPlugin({
  addBase,
  addComponents,
  theme,
}: ScrollbarPluginParams) {
  // Get color references from theme
  const colors = theme('colors');
  const gray = colors.gray || {};
  const primary = colors.primary || {};

  // Get semantic color tokens if available
  const surfaceSubtle = theme('colors.bg.subtle');
  const borderSubtle = theme('colors.border.subtle');
  const borderModerate = theme('colors.border.moderate');

  // Apply minimal global scrollbar styles with theme tokens
  addBase({
    'html': {
      'scrollbar-width': 'thin',
      'scrollbar-color': `rgba(${hexToRgb(
        theme('colors.gray.400') || gray[400]
      )}, ${opacityLevels.light.low}) transparent`,
    },
    'body': {
      'scrollbar-width': 'thin',
      'scrollbar-color': `rgba(${hexToRgb(
        theme('colors.gray.400') || gray[400]
      )}, ${opacityLevels.light.low}) transparent`,
    },
    '::-webkit-scrollbar': {
      width: scrollbars.width.default,
      height: scrollbars.width.default,
    },
    '::-webkit-scrollbar-track': {
      background: 'transparent',
    },
    '::-webkit-scrollbar-thumb': {
      background: `rgba(${hexToRgb(theme('colors.gray.400') || gray[400])}, ${
        opacityLevels.light.low
      })`,
      borderRadius: scrollbars.borderRadius.default,
    },
    '::-webkit-scrollbar-thumb:hover': {
      background: `rgba(${hexToRgb(theme('colors.gray.500') || gray[500])}, ${
        opacityLevels.light.medium
      })`,
    },
  });

  // Define scrollbar variants as components using theme tokens
  const scrollbarComponents = {
    // Light theme scrollbars
    '.scrollbar-light': createScrollbarStyles({
      trackBg:
        surfaceSubtle ||
        `rgba(${hexToRgb(theme('colors.gray.100') || gray[100])}, ${
          opacityLevels.light.low
        })`,
      thumbBg:
        borderSubtle ||
        `rgba(${hexToRgb(theme('colors.gray.300') || gray[300])}, ${
          opacityLevels.light.low
        })`,
      thumbBorder: `${borders.width.medium} solid ${
        borderSubtle ||
        `rgba(${hexToRgb(theme('colors.gray.200') || gray[200])}, ${
          opacityLevels.light.low
        })`
      }`,
      thumbHoverBg:
        borderModerate ||
        `rgba(${hexToRgb(theme('colors.gray.400') || gray[400])}, ${
          opacityLevels.light.medium
        })`,
    }),

    // Dark theme scrollbars
    '.scrollbar-dark': createScrollbarStyles({
      trackBg: `rgba(${hexToRgb(theme('colors.gray.800') || gray[800])}, ${
        opacityLevels.light.medium
      })`,
      thumbBg: `rgba(${hexToRgb(theme('colors.gray.600') || gray[600])}, ${
        opacityLevels.light.high
      })`,
      thumbBorder: `${borders.width.medium} solid rgba(${hexToRgb(
        theme('colors.gray.700') || gray[700]
      )}, ${opacityLevels.light.low})`,
      thumbHoverBg: `rgba(${hexToRgb(theme('colors.gray.500') || gray[500])}, ${
        opacityLevels.light.high
      })`,
    }),

    // Brand-colored scrollbars
    '.scrollbar-brand': createScrollbarStyles({
      trackBg: `rgba(${hexToRgb(
        theme('colors.primary.100') || primary[100]
      )}, ${opacityLevels.light.low})`,
      thumbBg: `rgba(${hexToRgb(
        theme('colors.primary.400') || primary[400]
      )}, ${opacityLevels.light.medium})`,
      thumbBorder: `${borders.width.medium} solid rgba(${hexToRgb(
        theme('colors.primary.300') || primary[300]
      )}, ${opacityLevels.light.low})`,
      thumbHoverBg: `rgba(${hexToRgb(
        theme('colors.primary.500') || primary[500]
      )}, ${opacityLevels.light.high})`,
    }),

    // Thin scrollbars for compact UI elements - use border tokens
    '.scrollbar-thin': createScrollbarStyles({
      trackBg: `rgba(${hexToRgb(theme('colors.gray.100') || gray[100])}, ${
        opacityLevels.light.low
      })`,
      thumbBg: `rgba(${hexToRgb(theme('colors.gray.300') || gray[300])}, ${
        opacityLevels.light.low
      })`,
      thumbBorder: `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.200') || gray[200]
      )}, ${opacityLevels.light.low})`,
      thumbHoverBg: `rgba(${hexToRgb(theme('colors.gray.400') || gray[400])}, ${
        opacityLevels.light.medium
      })`,
      width: scrollbars.width.thin,
      height: scrollbars.width.thin,
      borderRadius: scrollbars.borderRadius.sm,
    }),

    // Thin dark scrollbars - use border tokens
    '.scrollbar-thin-dark': createScrollbarStyles({
      trackBg: `rgba(${hexToRgb(theme('colors.gray.800') || gray[800])}, ${
        opacityLevels.light.medium
      })`,
      thumbBg: `rgba(${hexToRgb(theme('colors.gray.600') || gray[600])}, ${
        opacityLevels.light.high
      })`,
      thumbBorder: `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.700') || gray[700]
      )}, ${opacityLevels.light.low})`,
      thumbHoverBg: `rgba(${hexToRgb(theme('colors.gray.500') || gray[500])}, ${
        opacityLevels.light.high
      })`,
      width: scrollbars.width.thin,
      height: scrollbars.width.thin,
      borderRadius: scrollbars.borderRadius.sm,
    }),

    // Hide scrollbars but keep functionality
    '.scrollbar-hidden': {
      '-ms-overflow-style': 'none',
      'scrollbar-width': 'none',
      '&::-webkit-scrollbar': {
        display: 'none',
      },
    },

    // Rounded scrollbars - use border and shadow tokens
    '.scrollbar-rounded': createScrollbarStyles({
      trackBg: `rgba(${hexToRgb(theme('colors.gray.100') || gray[100])}, ${
        opacityLevels.light.low
      })`,
      thumbBg: `rgba(${hexToRgb(theme('colors.gray.300') || gray[300])}, ${
        opacityLevels.light.low
      })`,
      thumbBorder: `${borders.width.thin} solid rgba(${hexToRgb(
        theme('colors.gray.200') || gray[200]
      )}, ${opacityLevels.light.low})`,
      thumbHoverBg: `rgba(${hexToRgb(theme('colors.gray.400') || gray[400])}, ${
        opacityLevels.light.medium
      })`,
      borderRadius: scrollbars.borderRadius.rounded,
    }),

    // NEW: Subtle scrollbars with shadow - theme token powered
    '.scrollbar-subtle': createScrollbarStyles({
      trackBg: 'transparent',
      thumbBg: `rgba(${hexToRgb(theme('colors.gray.400') || gray[400])}, ${
        opacityLevels.light.medium
      })`,
      thumbBorder: 'none',
      thumbHoverBg: `rgba(${hexToRgb(theme('colors.gray.500') || gray[500])}, ${
        opacityLevels.light.high
      })`,
      width: scrollbars.width.thin,
      borderRadius: scrollbars.borderRadius.rounded,
    }),

    // NEW: Glass-style scrollbars for glass UI elements - theme token powered
    '.scrollbar-glass': createScrollbarStyles({
      trackBg:
        theme('colors.glass.light-bg') ||
        `rgba(255, 255, 255, ${opacityLevels.subtle})`,
      thumbBg:
        theme('colors.glass.light-border') ||
        `rgba(255, 255, 255, ${opacityLevels.light.medium})`,
      thumbBorder: 'none',
      thumbHoverBg: `rgba(255, 255, 255, ${opacityLevels.light.high})`,
      width: scrollbars.width.thin,
      borderRadius: scrollbars.borderRadius.rounded,
    }),

    // NEW: Glass-dark scrollbars - theme token powered
    '.scrollbar-glass-dark': createScrollbarStyles({
      trackBg:
        theme('colors.glass.dark-bg') ||
        `rgba(0, 0, 0, ${opacityLevels.subtle})`,
      thumbBg:
        theme('colors.glass.dark-border') ||
        `rgba(${hexToRgb(theme('colors.gray.700') || gray[700])}, ${
          opacityLevels.light.medium
        })`,
      thumbBorder: 'none',
      thumbHoverBg: `rgba(${hexToRgb(theme('colors.gray.600') || gray[600])}, ${
        opacityLevels.light.high
      })`,
      width: scrollbars.width.thin,
      borderRadius: scrollbars.borderRadius.rounded,
    }),
  };

  addComponents(scrollbarComponents, ['responsive']);
}


================================================================================

# .\tokens\animation.ts

// src/webview/theme/tokens/animation.ts

/**
 * Animation tokens for consistent motion design
 */
export const animation = {
  // Transition properties
  transitionProperty: {
    none: 'none',
    all: 'all',
    DEFAULT: 'background-color, border-color, color, fill, stroke, opacity, box-shadow, transform',
    colors: 'background-color, border-color, color, fill, stroke',
    opacity: 'opacity',
    shadow: 'box-shadow',
    transform: 'transform',
  },
  
  // Timing functions
  transitionTimingFunction: {
    DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',
    linear: 'linear',
    in: 'cubic-bezier(0.4, 0, 1, 1)',
    out: 'cubic-bezier(0, 0, 0.2, 1)',
    'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
    
    // Custom easing functions
    'bounce': 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
    'smooth': 'cubic-bezier(0.645, 0.045, 0.355, 1.000)',
  },
  
  // Duration values
  transitionDuration: {
    DEFAULT: '150ms',
    75: '75ms',
    100: '100ms',
    150: '150ms',
    200: '200ms',
    300: '300ms',
    500: '500ms',
    700: '700ms',
    1000: '1000ms',
  },
};


================================================================================

# .\tokens\breakpoints.ts

// src/webview/theme/tokens/breakpoints.ts

/**
 * Breakpoint tokens for responsive design
 */
export const breakpoints = {
  xs: '320px',
  sm: '640px',
  md: '768px',
  lg: '1024px',
  xl: '1280px',
  '2xl': '1536px',
};

/**
 * Creates a media query string for the given breakpoint
 * @param breakpoint - Breakpoint key from the breakpoints object
 * @returns Media query string
 */
export function createMediaQuery(breakpoint: keyof typeof breakpoints) {
  return `@media (min-width: ${breakpoints[breakpoint]})`;
}


================================================================================

# .\tokens\colors.ts

// Enhanced CSS Variables Generator for tailwind.config.ts
// This extends the existing generateColorCssVariables function

import { hexToRgb } from '../utils/colorUtils';
import { shadowOpacity, typography, borders, scrollbars } from './constants';
import { extractRawColorValues, ThemeOptions } from './tailwindColors';

/**
 * Generate enhanced CSS variables for light and dark mode
 * Includes more comprehensive set of theme tokens as CSS variables
 */
export function generateEnhancedCssVariables(
  options: ThemeOptions,
  mode: 'light' | 'dark' = 'light'
): string {
  const rawColors = extractRawColorValues(options);

  // Base color variables from the original function
  let cssVars = `
:root {
  /* Primary brand colors */
  --color-primary-50: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[50])
      : rawColors.primary[50]
  };
  --color-primary-100: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[100])
      : rawColors.primary[100]
  };
  --color-primary-200: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[200])
      : rawColors.primary[200]
  };
  --color-primary-300: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[300])
      : rawColors.primary[300]
  };
  --color-primary-400: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[400])
      : rawColors.primary[400]
  };
  --color-primary-500: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[500])
      : rawColors.primary[500]
  };
  --color-primary-600: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[600])
      : rawColors.primary[600]
  };
  --color-primary-700: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[700])
      : rawColors.primary[700]
  };
  --color-primary-800: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[800])
      : rawColors.primary[800]
  };
  --color-primary-900: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[900])
      : rawColors.primary[900]
  };
  --color-primary-950: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[950])
      : rawColors.primary[950]
  };
  
  /* Gray scale */
  --color-gray-50: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[50]) : rawColors.gray[50]
  };
  --color-gray-100: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[100]) : rawColors.gray[100]
  };
  --color-gray-200: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[200]) : rawColors.gray[200]
  };
  --color-gray-300: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[300]) : rawColors.gray[300]
  };
  --color-gray-400: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[400]) : rawColors.gray[400]
  };
  --color-gray-500: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[500]) : rawColors.gray[500]
  };
  --color-gray-600: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[600]) : rawColors.gray[600]
  };
  --color-gray-700: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[700]) : rawColors.gray[700]
  };
  --color-gray-800: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[800]) : rawColors.gray[800]
  };
  --color-gray-900: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[900]) : rawColors.gray[900]
  };
  --color-gray-950: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[950]) : rawColors.gray[950]
  };`;

  // Add existing semantic color tokens (shortened for brevity)
  cssVars += `
  /* Semantic context colors - mode specific */
  --color-background-page: ${
    mode === 'light' ? rawColors.gray[50] : rawColors.gray[950]
  };
  --color-background-card: ${
    mode === 'light' ? '#ffffff' : rawColors.gray[900]
  };
  --color-background-subtle: ${
    mode === 'light' ? rawColors.gray[100] : rawColors.gray[800]
  };
  --color-background-muted: ${
    mode === 'light' ? rawColors.gray[200] : rawColors.gray[700]
  };
  --color-background-elevated: ${
    mode === 'light' ? '#ffffff' : rawColors.gray[800]
  };
  
  --color-text-primary: ${mode === 'light' ? rawColors.gray[900] : '#ffffff'};
  --color-text-secondary: ${
    mode === 'light' ? rawColors.gray[700] : rawColors.gray[300]
  };
  --color-text-tertiary: ${
    mode === 'light' ? rawColors.gray[500] : rawColors.gray[400]
  };
  --color-text-disabled: ${
    mode === 'light' ? rawColors.gray[400] : rawColors.gray[600]
  };
  --color-text-inverted: ${
    mode === 'light' ? '#ffffff' : rawColors.gray[900]
  };`;

  // NEW: Add shadow tokens as CSS variables
  cssVars += `
  /* Shadow tokens */
  --shadow-color: ${hexToRgb(
    mode === 'light' ? rawColors.gray[900] : '#000000'
  )};
  --shadow-subtle: 0 1px 2px rgba(var(--shadow-color), ${shadowOpacity.subtle});
  --shadow-light: 0 1px 3px rgba(var(--shadow-color), ${shadowOpacity.light});
  --shadow-medium: 0 4px 6px rgba(var(--shadow-color), ${shadowOpacity.medium});
  --shadow-strong: 0 10px 15px rgba(var(--shadow-color), ${
    shadowOpacity.strong
  });
  --shadow-intense: 0 20px 25px rgba(var(--shadow-color), ${
    shadowOpacity.intense
  });
  
  /* Brand shadow tokens */
  --shadow-brand-color: ${hexToRgb(rawColors.primary[900])};
  --shadow-brand-light: 0 1px 3px rgba(var(--shadow-brand-color), ${
    shadowOpacity.light
  });
  --shadow-brand-medium: 0 4px 8px rgba(var(--shadow-brand-color), ${
    shadowOpacity.medium
  });
  --shadow-brand-strong: 0 8px 16px rgba(var(--shadow-brand-color), ${
    shadowOpacity.strong
  });`;

  // NEW: Add typography tokens as CSS variables
  cssVars += `
  /* Typography tokens */
  --font-weight-light: ${typography.fontWeight.light};
  --font-weight-normal: ${typography.fontWeight.normal};
  --font-weight-medium: ${typography.fontWeight.medium};
  --font-weight-semibold: ${typography.fontWeight.semibold};
  --font-weight-bold: ${typography.fontWeight.bold};
  
  --letter-spacing-tight: ${typography.letterSpacing.tight};
  --letter-spacing-normal: ${typography.letterSpacing.normal};
  --letter-spacing-wide: ${typography.letterSpacing.wide};
  --letter-spacing-wider: ${typography.letterSpacing.wider};
  --letter-spacing-widest: ${typography.letterSpacing.widest};
  
  --line-height-none: ${typography.lineHeight.none};
  --line-height-tight: ${typography.lineHeight.tight};
  --line-height-normal: ${typography.lineHeight.normal};
  --line-height-relaxed: ${typography.lineHeight.relaxed};
  --line-height-loose: ${typography.lineHeight.loose};`;

  // NEW: Add border tokens as CSS variables
  cssVars += `
  /* Border tokens */
  --border-width-thin: ${borders.width.thin};
  --border-width-medium: ${borders.width.medium};
  --border-width-thick: ${borders.width.thick};
  --border-width-heavy: ${borders.width.heavy};
  
  --border-radius-sm: ${borders.radius.sm};
  --border-radius-base: ${borders.radius.base};
  --border-radius-md: ${borders.radius.md};
  --border-radius-lg: ${borders.radius.lg};
  --border-radius-xl: ${borders.radius.xl};
  --border-radius-2xl: ${borders.radius['2xl']};
  --border-radius-3xl: ${borders.radius['3xl']};
  --border-radius-full: ${borders.radius.full};
  
  /* Border colors */
  --border-light: ${
    mode === 'light' ? rawColors.gray[200] : rawColors.gray[700]
  };
  --border-medium: ${
    mode === 'light' ? rawColors.gray[300] : rawColors.gray[600]
  };
  --border-strong: ${
    mode === 'light' ? rawColors.gray[400] : rawColors.gray[500]
  };
  --border-focus: ${rawColors.primary[500]};`;

  // NEW: Add scrollbar tokens as CSS variables
  cssVars += `
  /* Scrollbar tokens */
  --scrollbar-width-thin: ${scrollbars.width.thin};
  --scrollbar-width-default: ${scrollbars.width.default};
  --scrollbar-width-medium: ${scrollbars.width.medium};
  --scrollbar-width-thick: ${scrollbars.width.thick};
  
  --scrollbar-radius-default: ${scrollbars.borderRadius.default};
  --scrollbar-radius-rounded: ${scrollbars.borderRadius.rounded};
  
  --scrollbar-track-light: rgba(${hexToRgb(rawColors.gray[100])}, ${
    mode === 'light' ? opacityLevels.light.low : opacityLevels.dark.low
  });
  --scrollbar-thumb-light: rgba(${hexToRgb(rawColors.gray[300])}, ${
    mode === 'light' ? opacityLevels.light.medium : opacityLevels.dark.medium
  });
  --scrollbar-thumb-hover-light: rgba(${hexToRgb(rawColors.gray[400])}, ${
    mode === 'light' ? opacityLevels.light.high : opacityLevels.dark.high
  });
  
  --scrollbar-track-dark: rgba(${hexToRgb(rawColors.gray[800])}, ${
    mode === 'light' ? opacityLevels.light.low : opacityLevels.dark.low
  });
  --scrollbar-thumb-dark: rgba(${hexToRgb(rawColors.gray[600])}, ${
    mode === 'light' ? opacityLevels.light.medium : opacityLevels.dark.medium
  });
  --scrollbar-thumb-hover-dark: rgba(${hexToRgb(rawColors.gray[500])}, ${
    mode === 'light' ? opacityLevels.light.high : opacityLevels.dark.high
  });`;

  // NEW: Add glass tokens as CSS variables
  cssVars += `
  /* Glass tokens */
  --glass-light-bg: rgba(255, 255, 255, ${opacityLevels.light.high});
  --glass-light-border: rgba(255, 255, 255, ${opacityLevels.light.medium});
  
  --glass-dark-bg: rgba(15, 23, 42, ${opacityLevels.dark.medium});
  --glass-dark-border: rgba(30, 41, 59, ${opacityLevels.light.medium});
  
  --glass-brand-bg: rgba(${hexToRgb(rawColors.primary[500])}, ${
    opacityLevels.brand.low
  });
  --glass-brand-border: rgba(${hexToRgb(rawColors.primary[400])}, ${
    opacityLevels.brand.medium
  });
  
  /* Gaming UI tokens */
  --gaming-bg-dark: rgba(${hexToRgb(rawColors.gray[900])}, ${
    opacityLevels.dark.high
  });
  --gaming-bg-medium: rgba(${hexToRgb(rawColors.gray[800])}, ${
    opacityLevels.dark.high
  });
  --gaming-bg-light: rgba(${hexToRgb(rawColors.gray[700])}, ${
    opacityLevels.dark.high
  });
  
  --gaming-border-dark: rgba(${hexToRgb(rawColors.gray[800])}, ${
    opacityLevels.light.medium
  });
  --gaming-border-light: rgba(${hexToRgb(rawColors.gray[600])}, ${
    opacityLevels.light.low
  });
  
  --gaming-shadow-default: 0 4px 16px rgba(0, 0, 0, ${shadowOpacity.medium});
  --gaming-shadow-hover: 0 4px 12px rgba(0, 0, 0, ${shadowOpacity.medium});
  --gaming-shadow-header: 0 4px 6px rgba(0, 0, 0, ${shadowOpacity.light});`;

  // Close the root selector
  cssVars += `
}`;

  return cssVars;
}

// Helper function to adjust color for dark mode (from the original function)
function adjustForMode(color: string): string {
  // This would be the implementation of your existing adjustColorLightness function
  // For brevity, I've omitted the implementation here
  return color;
}

// For reference: opacity levels (defined in constants.ts)
const opacityLevels = {
  transparent: 0,
  subtle: 0.1,
  light: {
    low: 0.3,
    medium: 0.5,
    high: 0.7,
    opaque: 0.9,
  },
  dark: {
    low: 0.4,
    medium: 0.75,
    high: 0.85,
    opaque: 0.95,
  },
  brand: {
    low: 0.15,
    medium: 0.3,
    high: 0.5,
    opaque: 0.8,
  },
};


================================================================================

# .\tokens\constants.ts

// src/theme/tokens/constants.ts
// Centralized constants for the design system

/**
 * Default color values used when no theme colors are available
 */
export const defaultColors = {
  // Base neutral colors
  darkText: '#111827',
  lightText: '#f9fafb',

  // Default gray scale colors
  grayDark: {
    950: '#030712',
    900: '#111827',
    800: '#1f2937',
    700: '#374151',
    600: '#4b5563',
    500: '#6b7280',
    400: '#9ca3af',
    300: '#d1d5db',
    200: '#e5e7eb',
    100: '#f3f4f6',
    50: '#f9fafb',
  },
  grayLight: {
    50: '#f9fafb',
    100: '#f3f4f6',
    200: '#e5e7eb',
    300: '#d1d5db',
    400: '#9ca3af',
    500: '#6b7280',
    600: '#4b5563',
    700: '#374151',
    800: '#1f2937',
    900: '#111827',
    950: '#030712',
  },

  // Default primary colors
  primaryDefault: {
    950: '#1e1b4b',
    900: '#312e81',
    800: '#3730a3',
    700: '#4338ca',
    600: '#4f46e5',
    500: '#6366f1',
    400: '#818cf8',
    300: '#a5b4fc',
    200: '#c7d2fe',
    100: '#e0e7ff',
    50: '#eef2ff',
  },
};

/**
 * Border dimensions
 */
export const borders = {
  width: {
    none: '0',
    hairline: '0.5px',
    thin: '1px',
    medium: '2px',
    thick: '3px',
    heavy: '4px',
  },
  radius: {
    none: '0',
    sm: '0.125rem', // 2px
    base: '0.25rem', // 4px
    md: '0.375rem', // 6px
    lg: '0.5rem', // 8px
    xl: '0.75rem', // 12px
    '2xl': '1rem', // 16px
    '3xl': '1.5rem', // 24px
    full: '9999px',
  },
};

/**
 * Scrollbar dimensions
 */
export const scrollbars = {
  width: {
    thin: '6px',
    default: '8px',
    medium: '10px',
    thick: '12px',
  },
  borderRadius: {
    sm: '3px',
    default: '4px',
    md: '6px',
    lg: '8px',
    rounded: '999px',
  },
};

/**
 * Opacity levels
 */
export const opacityLevels = {
  transparent: 0,
  subtle: 0.1,
  light: {
    low: 0.3,
    medium: 0.5,
    high: 0.7,
    opaque: 0.9,
  },
  dark: {
    low: 0.4,
    medium: 0.75,
    high: 0.85,
    opaque: 0.95,
  },
  brand: {
    low: 0.15,
    medium: 0.3,
    high: 0.5,
    opaque: 0.8,
  },
};

/**
 * Blur levels
 */
export const blurLevels = {
  none: '0px',
  sm: '4px',
  md: '8px',
  lg: '12px',
  xl: '16px',
  '2xl': '24px',
};

/**
 * Shadow opacity levels
 */
export const shadowOpacity = {
  subtle: 0.05,
  light: 0.15,
  medium: 0.25,
  strong: 0.3,
  intense: 0.4,
};

/**
 * Default background color values for different UI contexts
 */
export const backgroundDefaults = {
  glass: {
    light: 'rgba(255, 255, 255, 0.7)',
    dark: 'rgba(15, 23, 42, 0.75)',
    brand: 'rgba(79, 70, 229, 0.15)',
  },
};

/**
 * Typography configuration
 */
export const typography = {
  fontWeight: {
    light: '300',
    normal: '400',
    medium: '450',
    semibold: '500',
    bold: '700',
  },
  letterSpacing: {
    tighter: '-0.05em',
    tight: '-0.025em',
    normal: '0em',
    wide: '0.01em',
    wider: '0.025em',
    widest: '0.05em',
  },
  lineHeight: {
    none: 1,
    tight: 1.25,
    snug: 1.375,
    normal: 1.5,
    relaxed: 1.625,
    loose: 2,
  },
  fontSize: {
    '2xs': '0.625rem',
    xs: '0.75rem',
    sm: '0.875rem',
    base: '1rem',
    lg: '1.125rem',
    xl: '1.25rem',
    '2xl': '1.5rem',
    '3xl': '1.875rem',
    '4xl': '2.25rem',
    '5xl': '3rem',
  },
};

/**
 * Error fallback values
 */
export const fallbacks = {
  color: {
    rgb: '0, 0, 0',
    hex: '#000000',
  },
  opacity: 0.5,
};

/**
 * Common UI element styles - replacing hardcoded values with tokens
 * These variables can be used when creating themed components
 */
export const elements = {
  gaming: {
    // Updated to use token references - not hardcoded values
    background: {
      dark: `rgba(${defaultColors.grayDark[900].replace('#', '')}, ${
        opacityLevels.dark.high
      })`,
      medium: `rgba(${defaultColors.grayDark[800].replace('#', '')}, ${
        opacityLevels.dark.high
      })`,
      light: `rgba(${defaultColors.grayDark[700].replace('#', '')}, ${
        opacityLevels.dark.high
      })`,
    },
    border: {
      dark: `rgba(${defaultColors.grayDark[800].replace('#', '')}, ${
        opacityLevels.light.medium
      })`,
      light: `rgba(${defaultColors.grayDark[500].replace('#', '')}, ${
        opacityLevels.light.low
      })`,
    },
    shadow: {
      default: `0 4px 16px rgba(0, 0, 0, ${shadowOpacity.medium})`,
      hover: `0 4px 12px rgba(0, 0, 0, ${shadowOpacity.medium})`,
      header: `0 4px 6px rgba(0, 0, 0, ${shadowOpacity.light})`,
      sidebar: `4px 0 16px rgba(0, 0, 0, ${shadowOpacity.medium})`,
    },
  },

  // NEW: Adding card elements with standardized styles
  card: {
    background: {
      light: '#ffffff',
      dark: defaultColors.grayDark[900],
      brand: `rgba(${defaultColors.primaryDefault[50].replace('#', '')}, ${
        opacityLevels.light.opaque
      })`,
    },
    border: {
      light: `${borders.width.thin} solid ${defaultColors.grayLight[200]}`,
      dark: `${borders.width.thin} solid ${defaultColors.grayDark[700]}`,
      brand: `${borders.width.thin} solid ${defaultColors.primaryDefault[200]}`,
    },
    shadow: {
      small: `0 1px 3px rgba(0, 0, 0, ${shadowOpacity.subtle})`,
      medium: `0 4px 6px rgba(0, 0, 0, ${shadowOpacity.light})`,
      large: `0 10px 15px rgba(0, 0, 0, ${shadowOpacity.medium})`,
    },
    radius: {
      default: borders.radius.lg,
      large: borders.radius.xl,
    },
  },

  // NEW: Button elements
  button: {
    background: {
      primary: defaultColors.primaryDefault[600],
      secondary: defaultColors.grayLight[200],
      danger: '#ef4444', // Red-500
      success: '#10b981', // Emerald-500
      warning: '#f59e0b', // Amber-500
      info: '#3b82f6', // Blue-500
    },
    hover: {
      primary: defaultColors.primaryDefault[700],
      secondary: defaultColors.grayLight[300],
      danger: '#dc2626', // Red-600
      success: '#059669', // Emerald-600
      warning: '#d97706', // Amber-600
      info: '#2563eb', // Blue-600
    },
    border: {
      width: borders.width.thin,
      radius: {
        default: borders.radius.md,
        rounded: borders.radius.full,
      },
    },
    padding: {
      sm: '0.5rem 1rem',
      md: '0.75rem 1.5rem',
      lg: '1rem 2rem',
    },
    fontSize: {
      sm: typography.fontSize.sm,
      md: typography.fontSize.base,
      lg: typography.fontSize.lg,
    },
    fontWeight: typography.fontWeight.medium,
  },

  // NEW: Form elements
  form: {
    input: {
      background: {
        default: '#ffffff',
        disabled: defaultColors.grayLight[100],
      },
      border: {
        default: `${borders.width.thin} solid ${defaultColors.grayLight[300]}`,
        focus: `${borders.width.thin} solid ${defaultColors.primaryDefault[500]}`,
        error: `${borders.width.thin} solid #ef4444`, // Red-500
      },
      padding: '0.5rem 0.75rem',
      fontSize: typography.fontSize.base,
      radius: borders.radius.md,
    },
    label: {
      fontSize: typography.fontSize.sm,
      fontWeight: typography.fontWeight.medium,
      color: defaultColors.grayDark[700],
      marginBottom: '0.25rem',
    },
    helperText: {
      fontSize: typography.fontSize.xs,
      color: defaultColors.grayDark[500],
      marginTop: '0.25rem',
    },
    errorText: {
      fontSize: typography.fontSize.xs,
      color: '#ef4444', // Red-500
      fontWeight: typography.fontWeight.medium,
      marginTop: '0.25rem',
    },
  },
};

/**
 * Z-index scale for consistent stacking order
 */
export const zIndex = {
  0: 0,
  10: 10,
  20: 20,
  30: 30,
  40: 40,
  50: 50, // Default
  60: 60,
  70: 70,
  80: 80,
  90: 90,
  100: 100, // Dropdowns
  200: 200, // Sticky headers
  300: 300, // Fixed elements
  400: 400, // Modal backdrop
  500: 500, // Modal content
  600: 600, // Popovers
  700: 700, // Tooltips
  800: 800, // Alerts/notifications
  900: 900, // Top-level floating elements
  999: 999, // Maximum z-index
};

/**
 * Standard spacing scale for layout and component spacing
 */
export const spacingScale = {
  px: '1px',
  0: '0',
  0.5: '0.125rem', // 2px
  1: '0.25rem', // 4px
  1.5: '0.375rem', // 6px
  2: '0.5rem', // 8px
  2.5: '0.625rem', // 10px
  3: '0.75rem', // 12px
  3.5: '0.875rem', // 14px
  4: '1rem', // 16px
  5: '1.25rem', // 20px
  6: '1.5rem', // 24px
  7: '1.75rem', // 28px
  8: '2rem', // 32px
  9: '2.25rem', // 36px
  10: '2.5rem', // 40px
  11: '2.75rem', // 44px
  12: '3rem', // 48px
  14: '3.5rem', // 56px
  16: '4rem', // 64px
  20: '5rem', // 80px
  24: '6rem', // 96px
  28: '7rem', // 112px
  32: '8rem', // 128px
  36: '9rem', // 144px
  40: '10rem', // 160px
};


================================================================================

# .\tokens\effects.ts

// src/webview/theme/tokens/effects.ts

import { blurLevels, opacityLevels, borders } from './constants';

/**
 * Effect tokens for consistent visual treatments across the UI
 */
export const effects = {
  /**
   * Blur effect tokens for consistent backdrop-filter blur values
   */
  blur: blurLevels,

  /**
   * Opacity tokens for consistent transparency levels
   */
  opacity: opacityLevels,

  /**
   * Border width tokens
   */
  borderWidth: borders.width,
};


================================================================================

# .\tokens\elevation.ts

// src/webview/theme/tokens/elevation.ts

/**
 * Elevation tokens for consistent shadow effects
 * These create a sense of depth and hierarchy in the UI
 */
export const elevation = {
  none: 'none',
  xs: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
  sm: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
  md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
  lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
  xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
  '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
  inner: 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',
  
  // Glass-specific shadows
  'glass-light': '0 4px 12px 0 rgba(31, 38, 135, 0.07)',
  'glass-dark': '0 4px 12px 0 rgba(0, 0, 0, 0.25)',
  'glass-brand': '0 8px 32px 0 rgba(31, 38, 135, 0.15)',
};


================================================================================

# .\tokens\index.ts

// src/theme/tokens/index.ts
// The root file that exports all design tokens

export * from './colors';
export * from './typography';
export * from './spacing';
export * from './elevation';
export * from './radius';
export * from './animation';
export * from './effects';
export * from './breakpoints';

// Re-export the theme resolver for convenience
export { resolveTokens } from './resolver';


================================================================================

# .\tokens\radius.ts

// src/webview/theme/tokens/radius.ts

import { borders } from './constants';

/**
 * Border radius tokens for consistent rounding of UI elements
 */
export const borderRadius = borders.radius;


================================================================================

# .\tokens\resolver.ts

// src/theme/tokens/resolver.ts

import {
  fontFamily,
  fontSize,
  fontWeight,
  letterSpacing,
  lineHeight,
  textStyles,
} from './typography';
import { spacing } from './spacing';
import { borderRadius } from './radius';
import { elevation } from './elevation';
import { animation } from './animation';
import { effects } from './effects';
import { breakpoints } from './breakpoints';
import {
  createColorScales,
  ThemeOptions,
  defaultThemeOptions,
} from './tailwindColors';
import { semanticColors } from '../../colors';

export type ThemeMode = 'light' | 'dark';

/**
 * Helper function to resolve a color token based on theme mode
 * @param path - Dot notation path to the color token (e.g., 'text.primary')
 * @param mode - Theme mode (light or dark)
 */
function resolveColorToken(path: string, mode: ThemeMode): string {
  const parts = path.split('.');
  let current: any = semanticColors;

  // Navigate through the path
  for (const part of parts) {
    if (!current[part]) {
      console.warn(`Color token path "${path}" not found`);
      return mode === 'light' ? '#000000' : '#ffffff'; // Fallback
    }
    current = current[part];
  }

  // Check if we have a mode-specific value
  if (typeof current === 'object' && (current.light || current.dark)) {
    return current[mode];
  }

  // Return the value directly if it's not mode-specific
  return current;
}

/**
 * Resolves all design tokens into a Tailwind-compatible theme configuration
 * @param mode - The theme mode (light or dark)
 * @param options - Theme color options
 * @returns Fully resolved theme configuration
 */
export function resolveTokens(
  mode: ThemeMode = 'light',
  options: ThemeOptions = defaultThemeOptions
) {
  // Get color scales from our theme options
  const colorScales = createColorScales(options);

  // Create semantic color references with correct mode
  const resolvedColors = {
    // Add all color scales directly
    ...colorScales,

    // Also add semantic color tokens with mode-specific values
    bg: {
      page: resolveColorToken('background.page', mode),
      card: resolveColorToken('background.card', mode),
      subtle: resolveColorToken('background.subtle', mode),
      muted: resolveColorToken('background.muted', mode),
      elevated: resolveColorToken('background.elevated', mode),
    },
    surface: {
      primary: resolveColorToken('surface.primary', mode),
      success: resolveColorToken('surface.success', mode),
      warning: resolveColorToken('surface.warning', mode),
      error: resolveColorToken('surface.error', mode),
      info: resolveColorToken('surface.info', mode),
    },
    border: {
      subtle: resolveColorToken('border.subtle', mode),
      moderate: resolveColorToken('border.moderate', mode),
      strong: resolveColorToken('border.strong', mode),
      focus: resolveColorToken('border.focus', mode),
      error: resolveColorToken('border.error', mode),
    },
    text: {
      primary: resolveColorToken('text.primary', mode),
      secondary: resolveColorToken('text.secondary', mode),
      tertiary: resolveColorToken('text.tertiary', mode),
      disabled: resolveColorToken('text.disabled', mode),
      inverted: resolveColorToken('text.inverted', mode),
      link: resolveColorToken('text.link', mode),
      success: resolveColorToken('text.success', mode),
      error: resolveColorToken('text.error', mode),
      warning: resolveColorToken('text.warning', mode),
      info: resolveColorToken('text.info', mode),
    },
    icon: {
      primary: resolveColorToken('icon.primary', mode),
      secondary: resolveColorToken('icon.secondary', mode),
      tertiary: resolveColorToken('icon.tertiary', mode),
      inverted: resolveColorToken('icon.inverted', mode),
    },
    glass: {
      'light-bg': resolveColorToken('glass.light.background', mode),
      'light-border': resolveColorToken('glass.light.border', mode),
      'dark-bg': resolveColorToken('glass.dark.background', mode),
      'dark-border': resolveColorToken('glass.dark.border', mode),
      'brand-bg': resolveColorToken('glass.brand.background', mode),
      'brand-border': resolveColorToken('glass.brand.border', mode),
    },
  };

  // Return the full theme configuration
  return {
    colors: resolvedColors,
    fontFamily,
    fontSize,
    fontWeight,
    letterSpacing,
    lineHeight,
    spacing,
    borderRadius,
    boxShadow: elevation,
    transitionProperty: animation.transitionProperty,
    transitionTimingFunction: animation.transitionTimingFunction,
    transitionDuration: animation.transitionDuration,
    screens: breakpoints,
    blur: effects.blur,
  };
}

// Export a utility to get design tokens with resolved values
export function getDesignTokens(
  mode: ThemeMode = 'light',
  options: ThemeOptions = defaultThemeOptions
) {
  const colorScales = createColorScales(options);

  return {
    colors: {
      scales: colorScales,
      semantic: Object.entries(semanticColors).reduce(
        (acc: Record<string, Record<string, any>>, [category, values]) => {
          acc[category] = Object.entries(values).reduce(
            (catAcc: Record<string, any>, [key, value]) => {
              if (typeof value === 'object' && (value.light || value.dark)) {
                catAcc[key] = value[mode];
              } else {
                catAcc[key] = value;
              }
              return catAcc;
            },
            {}
          );
          return acc;
        },
        {}
      ),
    },
    typography: {
      fontFamily,
      fontSize,
      fontWeight,
      letterSpacing,
      lineHeight,
      textStyles,
    },
    spacing,
    borderRadius,
    elevation,
    animation,
    effects,
    breakpoints,
  };
}


================================================================================

# .\tokens\spacing.ts

// src/webview/theme/tokens/spacing.ts

/**
 * Spacing scale for consistent layout spacing
 * Uses a 4px base unit (0.25rem) with consistent scaling
 */
export const spacing = {
  px: '1px',
  0: '0',
  0.5: '0.125rem', // 2px
  1: '0.25rem', // 4px
  1.5: '0.375rem', // 6px
  2: '0.5rem', // 8px
  2.5: '0.625rem', // 10px
  3: '0.75rem', // 12px
  3.5: '0.875rem', // 14px
  4: '1rem', // 16px
  5: '1.25rem', // 20px
  6: '1.5rem', // 24px
  7: '1.75rem', // 28px
  8: '2rem', // 32px
  9: '2.25rem', // 36px
  10: '2.5rem', // 40px
  11: '2.75rem', // 44px
  12: '3rem', // 48px
  14: '3.5rem', // 56px
  16: '4rem', // 64px
  20: '5rem', // 80px
  24: '6rem', // 96px
  28: '7rem', // 112px
  32: '8rem', // 128px
  36: '9rem', // 144px
  40: '10rem', // 160px
  44: '11rem', // 176px
  48: '12rem', // 192px
  52: '13rem', // 208px
  56: '14rem', // 224px
  60: '15rem', // 240px
  64: '16rem', // 256px
  72: '18rem', // 288px
  80: '20rem', // 320px
  96: '24rem', // 384px
};


================================================================================

# .\tokens\tailwindColors.ts

// tailwindColors.ts - Enhanced with dynamic color generation
import * as tailwindColorsModule from 'tailwindcss/colors';
import {
  adjustColorLightness,
  generateColorPalette,
} from '../utils/colorUtils';

// Export the tailwind colors for use in other modules
export const tailwindColors = tailwindColorsModule;

// Define color palette names for type safety
export type ColorPaletteName =
  | 'slate'
  | 'gray'
  | 'zinc'
  | 'neutral'
  | 'stone'
  | 'red'
  | 'orange'
  | 'amber'
  | 'yellow'
  | 'lime'
  | 'green'
  | 'emerald'
  | 'teal'
  | 'cyan'
  | 'sky'
  | 'blue'
  | 'indigo'
  | 'violet'
  | 'purple'
  | 'fuchsia'
  | 'pink'
  | 'rose';

// Expanded theme options
export interface ThemeOptions {
  brandColor: ColorPaletteName | string; // Allow hex color strings for custom colors
  grayColor: ColorPaletteName;
  accentColor?: ColorPaletteName | string; // Optional accent color
  contrastThreshold?: number; // WCAG contrast threshold (default: 4.5)
  colorScheme?:
    | 'analogous'
    | 'complementary'
    | 'triadic'
    | 'tetradic'
    | 'monochromatic'; // Color harmony
  saturationAdjustment?: number; // Adjust saturation of generated colors (-1 to 1)
  brightnessAdjustment?: number; // Adjust brightness of generated colors (-1 to 1)
}

// Define theme presets
export type ThemePreset =
  | 'default'
  | 'vibrant'
  | 'muted'
  | 'pastel'
  | 'dark'
  | 'light'
  | 'high-contrast';

// Helper function to check if a string is a hex color
function isHexColor(value: string): boolean {
  return value.startsWith('#');
}

// Function to create semantic color mapping based on theme options
export function createColorScales(options: ThemeOptions) {
  // Handle custom colors (hex strings) vs. named Tailwind colors
  const brandPalette =
    typeof options.brandColor === 'string' && isHexColor(options.brandColor)
      ? generateDynamicColorScale(options.brandColor)
      : (tailwindColors as Record<string, any>)[options.brandColor as string] ||
        tailwindColors.indigo;

  const grayPalette =
    (tailwindColors as Record<string, any>)[options.grayColor] ||
    tailwindColors.zinc; // Updated from 'gray' to 'zinc' based on warnings

  // Generate accent color if provided
  let accentPalette;
  if (options.accentColor) {
    accentPalette =
      typeof options.accentColor === 'string' && isHexColor(options.accentColor)
        ? generateDynamicColorScale(options.accentColor)
        : (tailwindColors as Record<string, any>)[
            options.accentColor as string
          ];
  } else {
    accentPalette = generateHarmonicColor(
      options.brandColor,
      options.colorScheme || 'complementary'
    );
  }

  // Create the base scales using CSS variables that will be defined
  return {
    // Base colors directly from the selected palettes
    [typeof options.brandColor === 'string' && isHexColor(options.brandColor)
      ? 'custom-brand'
      : options.brandColor]: brandPalette,

    [options.grayColor]: grayPalette,

    // Accent color
    accent: accentPalette,

    // Primary brand colors - these use CSS variables for theming
    primary: {
      50: 'var(--color-primary-50)',
      100: 'var(--color-primary-100)',
      200: 'var(--color-primary-200)',
      300: 'var(--color-primary-300)',
      400: 'var(--color-primary-400)',
      500: 'var(--color-primary-500)',
      600: 'var(--color-primary-600)',
      700: 'var(--color-primary-700)',
      800: 'var(--color-primary-800)',
      900: 'var(--color-primary-900)',
      950: 'var(--color-primary-950)',
    },

    // Gray scale
    gray: {
      50: 'var(--color-gray-50)',
      100: 'var(--color-gray-100)',
      200: 'var(--color-gray-200)',
      300: 'var(--color-gray-300)',
      400: 'var(--color-gray-400)',
      500: 'var(--color-gray-500)',
      600: 'var(--color-gray-600)',
      700: 'var(--color-gray-700)',
      800: 'var(--color-gray-800)',
      900: 'var(--color-gray-900)',
      950: 'var(--color-gray-950)',
    },

    // Accent colors with full range of shades
    accentColor: {
      50: 'var(--color-accent-50)',
      100: 'var(--color-accent-100)',
      200: 'var(--color-accent-200)',
      300: 'var(--color-accent-300)',
      400: 'var(--color-accent-400)',
      500: 'var(--color-accent-500)',
      600: 'var(--color-accent-600)',
      700: 'var(--color-accent-700)',
      800: 'var(--color-accent-800)',
      900: 'var(--color-accent-900)',
      950: 'var(--color-accent-950)',
    },

    // Essential semantic colors with full range of shades
    success: {
      50: 'var(--color-success-50)',
      100: 'var(--color-success-100)',
      200: 'var(--color-success-200)',
      300: 'var(--color-success-300)',
      400: 'var(--color-success-400)',
      500: 'var(--color-success-500)',
      600: 'var(--color-success-600)',
      700: 'var(--color-success-700)',
      800: 'var(--color-success-800)',
      900: 'var(--color-success-900)',
      950: 'var(--color-success-950)',
    },
    error: {
      50: 'var(--color-error-50)',
      100: 'var(--color-error-100)',
      200: 'var(--color-error-200)',
      300: 'var(--color-error-300)',
      400: 'var(--color-error-400)',
      500: 'var(--color-error-500)',
      600: 'var(--color-error-600)',
      700: 'var(--color-error-700)',
      800: 'var(--color-error-800)',
      900: 'var(--color-error-900)',
      950: 'var(--color-error-950)',
    },
    warning: {
      50: 'var(--color-warning-50)',
      100: 'var(--color-warning-100)',
      200: 'var(--color-warning-200)',
      300: 'var(--color-warning-300)',
      400: 'var(--color-warning-400)',
      500: 'var(--color-warning-500)',
      600: 'var(--color-warning-600)',
      700: 'var(--color-warning-700)',
      800: 'var(--color-warning-800)',
      900: 'var(--color-warning-900)',
      950: 'var(--color-warning-950)',
    },
    info: {
      50: 'var(--color-info-50)',
      100: 'var(--color-info-100)',
      200: 'var(--color-info-200)',
      300: 'var(--color-info-300)',
      400: 'var(--color-info-400)',
      500: 'var(--color-info-500)',
      600: 'var(--color-info-600)',
      700: 'var(--color-info-700)',
      800: 'var(--color-info-800)',
      900: 'var(--color-info-900)',
      950: 'var(--color-info-950)',
    },
    // Add any additional color scales as needed
  };
}

/**
 * Generate a full color scale from a single hex color
 * Uses advanced algorithms to create balanced scales
 */
export function generateDynamicColorScale(
  baseColor: string
): Record<string, string> {
  return generateColorPalette(baseColor);
}

/**
 * Generate a harmonious color based on color theory
 * @param baseColor - The base color to derive harmony from
 * @param scheme - The color harmony scheme to use
 * @returns A harmonious color in hex format
 */
export function generateHarmonicColor(
  baseColor: ColorPaletteName | string,
  scheme: ThemeOptions['colorScheme'] = 'complementary'
): Record<string, string> {
  // Get the base color in hex format
  const baseHex =
    typeof baseColor === 'string' && isHexColor(baseColor)
      ? baseColor
      : (tailwindColors as Record<string, any>)[baseColor as string]?.[500] ||
        '#6366f1'; // Default to indigo if not found

  // Remove # if present
  const hex = baseHex.replace(/^#/, '');

  // Convert hex to HSL
  const r = parseInt(hex.substring(0, 2), 16) / 255;
  const g = parseInt(hex.substring(2, 4), 16) / 255;
  const b = parseInt(hex.substring(4, 6), 16) / 255;

  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0,
    s = 0,
    l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // achromatic
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
      default:
        h = 0;
    }
    h /= 6;
  }

  // Generate harmonious color based on scheme
  let newH = h;
  switch (scheme) {
    case 'complementary':
      newH = (h + 0.5) % 1;
      break;
    case 'analogous':
      newH = (h + 1 / 12) % 1; // 30 degrees
      break;
    case 'triadic':
      newH = (h + 1 / 3) % 1; // 120 degrees
      break;
    case 'tetradic':
      newH = (h + 0.25) % 1; // 90 degrees
      break;
    case 'monochromatic':
      // For monochromatic, we just adjust saturation/lightness
      s = Math.min(1, s * 1.2);
      l = Math.max(0, Math.min(1, l < 0.5 ? l * 1.2 : l * 0.8));
      break;
  }

  // Convert back to hex
  const hslToRgb = (hue: number, sat: number, light: number) => {
    let r, g, b;

    if (sat === 0) {
      r = g = b = light; // achromatic
    } else {
      const hue2rgb = (p: number, q: number, t: number) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      };

      const q = light < 0.5 ? light * (1 + sat) : light + sat - light * sat;
      const p = 2 * light - q;
      r = hue2rgb(p, q, hue + 1 / 3);
      g = hue2rgb(p, q, hue);
      b = hue2rgb(p, q, hue - 1 / 3);
    }

    const toHex = (x: number) => {
      const hex = Math.round(x * 255).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };

    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  };

  const harmonicColor = hslToRgb(newH, s, l);

  // Generate a full palette from this harmonic color
  return generateColorPalette(harmonicColor);
}

// Extract raw color values from the theme for CSS variable generation
export function extractRawColorValues(options: ThemeOptions) {
  // Handle custom colors (hex strings) vs. named Tailwind colors
  const brandPalette =
    typeof options.brandColor === 'string' && isHexColor(options.brandColor)
      ? generateDynamicColorScale(options.brandColor)
      : (tailwindColors as Record<string, any>)[options.brandColor as string] ||
        tailwindColors.indigo;

  const grayPalette =
    (tailwindColors as Record<string, any>)[options.grayColor] ||
    tailwindColors.zinc; // Updated from 'gray' to 'zinc' based on warnings

  // Generate accent color if provided
  let accentPalette;
  if (options.accentColor) {
    accentPalette =
      typeof options.accentColor === 'string' && isHexColor(options.accentColor)
        ? generateDynamicColorScale(options.accentColor)
        : (tailwindColors as Record<string, any>)[
            options.accentColor as string
          ];
  } else {
    accentPalette = generateHarmonicColor(
      options.brandColor,
      options.colorScheme || 'complementary'
    );
  }

  return {
    // Map brand color to primary
    primary: {
      50: brandPalette[50] || brandPalette['50'],
      100: brandPalette[100] || brandPalette['100'],
      200: brandPalette[200] || brandPalette['200'],
      300: brandPalette[300] || brandPalette['300'],
      400: brandPalette[400] || brandPalette['400'],
      500: brandPalette[500] || brandPalette['500'],
      600: brandPalette[600] || brandPalette['600'],
      700: brandPalette[700] || brandPalette['700'],
      800: brandPalette[800] || brandPalette['800'],
      900: brandPalette[900] || brandPalette['900'],
      950: brandPalette[950] || brandPalette['950'],
    },
    // Map gray color
    gray: {
      50: grayPalette[50] || grayPalette['50'],
      100: grayPalette[100] || grayPalette['100'],
      200: grayPalette[200] || grayPalette['200'],
      300: grayPalette[300] || grayPalette['300'],
      400: grayPalette[400] || grayPalette['400'],
      500: grayPalette[500] || grayPalette['500'],
      600: grayPalette[600] || grayPalette['600'],
      700: grayPalette[700] || grayPalette['700'],
      800: grayPalette[800] || grayPalette['800'],
      900: grayPalette[900] || grayPalette['900'],
      950: grayPalette[950] || grayPalette['950'],
    },
    // Map accent color
    accent: {
      50: accentPalette[50] || accentPalette['50'],
      100: accentPalette[100] || accentPalette['100'],
      200: accentPalette[200] || accentPalette['200'],
      300: accentPalette[300] || accentPalette['300'],
      400: accentPalette[400] || accentPalette['400'],
      500: accentPalette[500] || accentPalette['500'],
      600: accentPalette[600] || accentPalette['600'],
      700: accentPalette[700] || accentPalette['700'],
      800: accentPalette[800] || accentPalette['800'],
      900: accentPalette[900] || accentPalette['900'],
      950: accentPalette[950] || accentPalette['950'],
    },
    // Use standard Tailwind colors for semantic colors
    success: {
      50: tailwindColors.green[50],
      100: tailwindColors.green[100],
      200: tailwindColors.green[200],
      300: tailwindColors.green[300],
      400: tailwindColors.green[400],
      500: tailwindColors.green[500],
      600: tailwindColors.green[600],
      700: tailwindColors.green[700],
      800: tailwindColors.green[800],
      900: tailwindColors.green[900],
      950: tailwindColors.green[950] || 'rgb(5, 46, 22)', // Fallback
    },
    error: {
      50: tailwindColors.red[50],
      100: tailwindColors.red[100],
      200: tailwindColors.red[200],
      300: tailwindColors.red[300],
      400: tailwindColors.red[400],
      500: tailwindColors.red[500],
      600: tailwindColors.red[600],
      700: tailwindColors.red[700],
      800: tailwindColors.red[800],
      900: tailwindColors.red[900],
      950: tailwindColors.red[950] || 'rgb(69, 10, 10)', // Fallback
    },
    warning: {
      50: tailwindColors.amber[50],
      100: tailwindColors.amber[100],
      200: tailwindColors.amber[200],
      300: tailwindColors.amber[300],
      400: tailwindColors.amber[400],
      500: tailwindColors.amber[500],
      600: tailwindColors.amber[600],
      700: tailwindColors.amber[700],
      800: tailwindColors.amber[800],
      900: tailwindColors.amber[900],
      950: tailwindColors.amber[950] || 'rgb(69, 26, 3)', // Fallback
    },
    info: {
      50: tailwindColors.blue[50],
      100: tailwindColors.blue[100],
      200: tailwindColors.blue[200],
      300: tailwindColors.blue[300],
      400: tailwindColors.blue[400],
      500: tailwindColors.blue[500],
      600: tailwindColors.blue[600],
      700: tailwindColors.blue[700],
      800: tailwindColors.blue[800],
      900: tailwindColors.blue[900],
      950: tailwindColors.blue[950] || 'rgb(23, 37, 84)', // Fallback
    },
  };
}

// Default theme options
export const defaultThemeOptions: ThemeOptions = {
  brandColor: 'indigo',
  grayColor: 'zinc', // Updated from 'gray' to 'zinc'
};

// Apply a theme preset to customize color options
export function applyThemePreset(
  preset: ThemePreset,
  baseOptions?: Partial<ThemeOptions>
): ThemeOptions {
  const options = { ...defaultThemeOptions, ...baseOptions };

  switch (preset) {
    case 'vibrant':
      return {
        brandColor: options.brandColor || 'violet',
        grayColor: 'slate',
        colorScheme: 'triadic',
        saturationAdjustment: 0.2,
        brightnessAdjustment: 0.1,
      };
    case 'muted':
      return {
        brandColor: options.brandColor || 'teal',
        grayColor: 'stone',
        colorScheme: 'analogous',
        saturationAdjustment: -0.2,
        brightnessAdjustment: -0.1,
      };
    case 'pastel':
      return {
        brandColor: options.brandColor || 'sky',
        grayColor: 'zinc',
        colorScheme: 'monochromatic',
        saturationAdjustment: -0.3,
        brightnessAdjustment: 0.3,
      };
    case 'dark':
      return {
        brandColor: options.brandColor || 'indigo',
        grayColor: 'zinc',
        colorScheme: 'monochromatic',
        saturationAdjustment: 0.1,
        brightnessAdjustment: -0.2,
      };
    case 'light':
      return {
        brandColor: options.brandColor || 'sky',
        grayColor: 'slate',
        colorScheme: 'monochromatic',
        saturationAdjustment: -0.1,
        brightnessAdjustment: 0.2,
      };
    case 'high-contrast':
      return {
        brandColor: options.brandColor || 'indigo',
        grayColor: 'zinc',
        contrastThreshold: 7, // Higher contrast for accessibility
        colorScheme: 'complementary',
      };
    case 'default':
    default:
      return {
        ...defaultThemeOptions,
        ...baseOptions,
      };
  }
}

// Generate CSS variables for light and dark mode with enhanced customization
export function generateColorCssVariables(
  options: ThemeOptions,
  mode: 'light' | 'dark' = 'light'
): string {
  const rawColors = extractRawColorValues(options);

  // Apply lighting adjustments based on mode
  const adjustForMode = (color: string): string => {
    if (mode === 'dark') {
      // For dark mode, darken and slightly desaturate colors
      return adjustColorLightness(color, -0.15);
    }
    return color;
  };

  // Create CSS variables string
  return `
:root {
  /* Primary brand colors */
  --color-primary-50: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[50])
      : rawColors.primary[50]
  };
  --color-primary-100: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[100])
      : rawColors.primary[100]
  };
  --color-primary-200: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[200])
      : rawColors.primary[200]
  };
  --color-primary-300: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[300])
      : rawColors.primary[300]
  };
  --color-primary-400: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[400])
      : rawColors.primary[400]
  };
  --color-primary-500: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[500])
      : rawColors.primary[500]
  };
  --color-primary-600: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[600])
      : rawColors.primary[600]
  };
  --color-primary-700: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[700])
      : rawColors.primary[700]
  };
  --color-primary-800: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[800])
      : rawColors.primary[800]
  };
  --color-primary-900: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[900])
      : rawColors.primary[900]
  };
  --color-primary-950: ${
    mode === 'dark'
      ? adjustForMode(rawColors.primary[950])
      : rawColors.primary[950]
  };
  
  /* Gray scale */
  --color-gray-50: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[50]) : rawColors.gray[50]
  };
  --color-gray-100: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[100]) : rawColors.gray[100]
  };
  --color-gray-200: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[200]) : rawColors.gray[200]
  };
  --color-gray-300: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[300]) : rawColors.gray[300]
  };
  --color-gray-400: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[400]) : rawColors.gray[400]
  };
  --color-gray-500: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[500]) : rawColors.gray[500]
  };
  --color-gray-600: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[600]) : rawColors.gray[600]
  };
  --color-gray-700: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[700]) : rawColors.gray[700]
  };
  --color-gray-800: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[800]) : rawColors.gray[800]
  };
  --color-gray-900: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[900]) : rawColors.gray[900]
  };
  --color-gray-950: ${
    mode === 'dark' ? adjustForMode(rawColors.gray[950]) : rawColors.gray[950]
  };
  
  /* Accent colors */
  --color-accent-50: ${
    mode === 'dark' ? adjustForMode(rawColors.accent[50]) : rawColors.accent[50]
  };
  --color-accent-100: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[100])
      : rawColors.accent[100]
  };
  --color-accent-200: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[200])
      : rawColors.accent[200]
  };
  --color-accent-300: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[300])
      : rawColors.accent[300]
  };
  --color-accent-400: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[400])
      : rawColors.accent[400]
  };
  --color-accent-500: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[500])
      : rawColors.accent[500]
  };
  --color-accent-600: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[600])
      : rawColors.accent[600]
  };
  --color-accent-700: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[700])
      : rawColors.accent[700]
  };
  --color-accent-800: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[800])
      : rawColors.accent[800]
  };
  --color-accent-900: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[900])
      : rawColors.accent[900]
  };
  --color-accent-950: ${
    mode === 'dark'
      ? adjustForMode(rawColors.accent[950])
      : rawColors.accent[950]
  };
  
  /* Semantic colors - full shade range */
  --color-success-50: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[50])
      : rawColors.success[50]
  };
  --color-success-100: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[100])
      : rawColors.success[100]
  };
  --color-success-200: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[200])
      : rawColors.success[200]
  };
  --color-success-300: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[300])
      : rawColors.success[300]
  };
  --color-success-400: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[400])
      : rawColors.success[400]
  };
  --color-success-500: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[500])
      : rawColors.success[500]
  };
  --color-success-600: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[600])
      : rawColors.success[600]
  };
  --color-success-700: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[700])
      : rawColors.success[700]
  };
  --color-success-800: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[800])
      : rawColors.success[800]
  };
  --color-success-900: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[900])
      : rawColors.success[900]
  };
  --color-success-950: ${
    mode === 'dark'
      ? adjustForMode(rawColors.success[950])
      : rawColors.success[950]
  };
  
  --color-error-50: ${
    mode === 'dark' ? adjustForMode(rawColors.error[50]) : rawColors.error[50]
  };
  --color-error-100: ${
    mode === 'dark' ? adjustForMode(rawColors.error[100]) : rawColors.error[100]
  };
  --color-error-200: ${
    mode === 'dark' ? adjustForMode(rawColors.error[200]) : rawColors.error[200]
  };
  --color-error-300: ${
    mode === 'dark' ? adjustForMode(rawColors.error[300]) : rawColors.error[300]
  };
  --color-error-400: ${
    mode === 'dark' ? adjustForMode(rawColors.error[400]) : rawColors.error[400]
  };
  --color-error-500: ${
    mode === 'dark' ? adjustForMode(rawColors.error[500]) : rawColors.error[500]
  };
  --color-error-600: ${
    mode === 'dark' ? adjustForMode(rawColors.error[600]) : rawColors.error[600]
  };
  --color-error-700: ${
    mode === 'dark' ? adjustForMode(rawColors.error[700]) : rawColors.error[700]
  };
  --color-error-800: ${
    mode === 'dark' ? adjustForMode(rawColors.error[800]) : rawColors.error[800]
  };
  --color-error-900: ${
    mode === 'dark' ? adjustForMode(rawColors.error[900]) : rawColors.error[900]
  };
  --color-error-950: ${
    mode === 'dark' ? adjustForMode(rawColors.error[950]) : rawColors.error[950]
  };
  
  --color-warning-50: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[50])
      : rawColors.warning[50]
  };
  --color-warning-100: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[100])
      : rawColors.warning[100]
  };
  --color-warning-200: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[200])
      : rawColors.warning[200]
  };
  --color-warning-300: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[300])
      : rawColors.warning[300]
  };
  --color-warning-400: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[400])
      : rawColors.warning[400]
  };
  --color-warning-500: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[500])
      : rawColors.warning[500]
  };
  --color-warning-600: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[600])
      : rawColors.warning[600]
  };
  --color-warning-700: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[700])
      : rawColors.warning[700]
  };
  --color-warning-800: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[800])
      : rawColors.warning[800]
  };
  --color-warning-900: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[900])
      : rawColors.warning[900]
  };
  --color-warning-950: ${
    mode === 'dark'
      ? adjustForMode(rawColors.warning[950])
      : rawColors.warning[950]
  };
  
  --color-info-50: ${
    mode === 'dark' ? adjustForMode(rawColors.info[50]) : rawColors.info[50]
  };
  --color-info-100: ${
    mode === 'dark' ? adjustForMode(rawColors.info[100]) : rawColors.info[100]
  };
  --color-info-200: ${
    mode === 'dark' ? adjustForMode(rawColors.info[200]) : rawColors.info[200]
  };
  --color-info-300: ${
    mode === 'dark' ? adjustForMode(rawColors.info[300]) : rawColors.info[300]
  };
  --color-info-400: ${
    mode === 'dark' ? adjustForMode(rawColors.info[400]) : rawColors.info[400]
  };
  --color-info-500: ${
    mode === 'dark' ? adjustForMode(rawColors.info[500]) : rawColors.info[500]
  };
  --color-info-600: ${
    mode === 'dark' ? adjustForMode(rawColors.info[600]) : rawColors.info[600]
  };
  --color-info-700
    mode === 'dark' ? adjustForMode(rawColors.info[700]) : rawColors.info[700]
  };
  --color-info-800: ${
    mode === 'dark' ? adjustForMode(rawColors.info[800]) : rawColors.info[800]
  };
  --color-info-900: ${
    mode === 'dark' ? adjustForMode(rawColors.info[900]) : rawColors.info[900]
  };
  --color-info-950: ${
    mode === 'dark' ? adjustForMode(rawColors.info[950]) : rawColors.info[950]
  };
  
  /* Semantic context colors - mode specific */
  --color-background-page: ${
    mode === 'light' ? rawColors.gray[50] : rawColors.gray[950]
  };
  --color-background-card: ${
    mode === 'light' ? '#ffffff' : rawColors.gray[900]
  };
  --color-background-subtle: ${
    mode === 'light' ? rawColors.gray[100] : rawColors.gray[800]
  };
  --color-background-muted: ${
    mode === 'light' ? rawColors.gray[200] : rawColors.gray[700]
  };
  --color-background-elevated: ${
    mode === 'light' ? '#ffffff' : rawColors.gray[800]
  };
  
  --color-surface-primary: ${
    mode === 'light'
      ? rawColors.primary[50]
      : hexToRgba(rawColors.primary[900], 0.4)
  };
  --color-surface-success: ${
    mode === 'light'
      ? rawColors.success[50]
      : hexToRgba(rawColors.success[900], 0.4)
  };
  --color-surface-warning: ${
    mode === 'light'
      ? rawColors.warning[50]
      : hexToRgba(rawColors.warning[900], 0.4)
  };
  --color-surface-error: ${
    mode === 'light'
      ? rawColors.error[50]
      : hexToRgba(rawColors.error[900], 0.4)
  };
  --color-surface-info: ${
    mode === 'light' ? rawColors.info[50] : hexToRgba(rawColors.info[900], 0.4)
  };
  --color-surface-accent: ${
    mode === 'light'
      ? rawColors.accent[50]
      : hexToRgba(rawColors.accent[900], 0.4)
  };
  
  --color-border-subtle: ${
    mode === 'light' ? rawColors.gray[200] : rawColors.gray[700]
  };
  --color-border-moderate: ${
    mode === 'light' ? rawColors.gray[300] : rawColors.gray[600]
  };
  --color-border-strong: ${
    mode === 'light' ? rawColors.gray[400] : rawColors.gray[500]
  };
  --color-border-focus: ${rawColors.primary[500]};
  --color-border-error: ${rawColors.error[500]};
  --color-border-accent: ${rawColors.accent[500]};
  
  --color-text-primary: ${mode === 'light' ? rawColors.gray[900] : '#ffffff'};
  --color-text-secondary: ${
    mode === 'light' ? rawColors.gray[700] : rawColors.gray[300]
  };
  --color-text-tertiary: ${
    mode === 'light' ? rawColors.gray[500] : rawColors.gray[400]
  };
  --color-text-disabled: ${
    mode === 'light' ? rawColors.gray[400] : rawColors.gray[600]
  };
  --color-text-inverted: ${mode === 'light' ? '#ffffff' : rawColors.gray[900]};
  --color-text-link: ${
    mode === 'light' ? rawColors.primary[600] : rawColors.primary[400]
  };
  --color-text-success: ${
    mode === 'light' ? rawColors.success[700] : rawColors.success[400]
  };
  --color-text-error: ${
    mode === 'light' ? rawColors.error[700] : rawColors.error[400]
  };
  --color-text-warning: ${
    mode === 'light' ? rawColors.warning[700] : rawColors.warning[400]
  };
  --color-text-info: ${
    mode === 'light' ? rawColors.info[700] : rawColors.info[400]
  };
  --color-text-accent: ${
    mode === 'light' ? rawColors.accent[700] : rawColors.accent[400]
  };
  
  --color-icon-primary: ${mode === 'light' ? rawColors.gray[900] : '#ffffff'};
  --color-icon-secondary: ${
    mode === 'light' ? rawColors.gray[700] : rawColors.gray[300]
  };
  --color-icon-tertiary: ${
    mode === 'light' ? rawColors.gray[500] : rawColors.gray[500]
  };
  --color-icon-inverted: ${mode === 'light' ? '#ffffff' : rawColors.gray[900]};
  --color-icon-accent: ${
    mode === 'light' ? rawColors.accent[600] : rawColors.accent[400]
  };
  
  --color-glass-light-background: ${
    mode === 'light' ? 'rgba(255, 255, 255, 0.7)' : 'rgba(255, 255, 255, 0.1)'
  };
  --color-glass-light-border: ${
    mode === 'light' ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.05)'
  };
  --color-glass-dark-background: ${
    mode === 'light' ? 'rgba(0, 0, 0, 0.7)' : 'rgba(0, 0, 0, 0.5)'
  };
  --color-glass-dark-border: ${
    mode === 'light' ? 'rgba(0, 0, 0, 0.2)' : 'rgba(0, 0, 0, 0.1)'
  };
  --color-glass-brand-background: ${
    mode === 'light'
      ? hexToRgba(rawColors.primary[500], 0.7)
      : hexToRgba(rawColors.primary[900], 0.5)
  };
  --color-glass-brand-border: ${
    mode === 'light'
      ? hexToRgba(rawColors.primary[500], 0.2)
      : hexToRgba(rawColors.primary[800], 0.2)
  };
  --color-glass-accent-background: ${
    mode === 'light'
      ? hexToRgba(rawColors.accent[500], 0.7)
      : hexToRgba(rawColors.accent[900], 0.5)
  };
  --color-glass-accent-border: ${
    mode === 'light'
      ? hexToRgba(rawColors.accent[500], 0.2)
      : hexToRgba(rawColors.accent[800], 0.2)
  };
}`;
}

// Helper function to convert hex to rgba for glass effects
export function hexToRgba(hex: string, alpha: number): string {
  // Remove # if present
  const cleanHex = hex.replace(/^#/, '');

  // Parse hex values
  const r = parseInt(cleanHex.substring(0, 2), 16);
  const g = parseInt(cleanHex.substring(2, 4), 16);
  const b = parseInt(cleanHex.substring(4, 6), 16);

  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// Export a color scheme API for runtime usage
export const ColorAPI = {
  // Generate CSS variables for a theme
  generateCSS: (
    options: ThemeOptions,
    mode: 'light' | 'dark' = 'light'
  ): string => {
    return generateColorCssVariables(options, mode);
  },

  // Apply theme preset
  applyPreset: applyThemePreset,

  // Generate a dynamic color scheme
  generateScheme: (
    baseColor: string,
    scheme: ThemeOptions['colorScheme'] = 'complementary'
  ): Record<string, string> => {
    return generateHarmonicColor(baseColor, scheme);
  },

  // Check if a color meets accessibility standards
  checkAccessibility: (
    foreground: string,
    background: string,
    level: 'AA' | 'AAA' = 'AA'
  ): boolean => {
    const requiredRatio = level === 'AA' ? 4.5 : 7;
    const contrast = calculateContrastRatio(foreground, background);
    return contrast >= requiredRatio;
  },

  // Get accessible text color for background
  getAccessibleTextColor: (background: string): string => {
    // Remove # if present
    const hex = background.replace(/^#/, '');

    // Calculate luminance
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;

    const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

    // Use white text on dark backgrounds, black on light
    return luminance < 0.5 ? '#ffffff' : '#000000';
  },
};

// Calculate contrast ratio between two colors
function calculateContrastRatio(color1: string, color2: string): number {
  // Remove # if present
  const hex1 = color1.replace(/^#/, '');
  const hex2 = color2.replace(/^#/, '');

  // Calculate luminance for first color
  const r1 = parseInt(hex1.substring(0, 2), 16) / 255;
  const g1 = parseInt(hex1.substring(2, 4), 16) / 255;
  const b1 = parseInt(hex1.substring(4, 6), 16) / 255;

  const R1 = r1 <= 0.03928 ? r1 / 12.92 : Math.pow((r1 + 0.055) / 1.055, 2.4);
  const G1 = g1 <= 0.03928 ? g1 / 12.92 : Math.pow((g1 + 0.055) / 1.055, 2.4);
  const B1 = b1 <= 0.03928 ? b1 / 12.92 : Math.pow((b1 + 0.055) / 1.055, 2.4);

  const L1 = 0.2126 * R1 + 0.7152 * G1 + 0.0722 * B1;

  // Calculate luminance for second color
  const r2 = parseInt(hex2.substring(0, 2), 16) / 255;
  const g2 = parseInt(hex2.substring(2, 4), 16) / 255;
  const b2 = parseInt(hex2.substring(4, 6), 16) / 255;

  const R2 = r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4);
  const G2 = g2 <= 0.03928 ? g2 / 12.92 : Math.pow((g2 + 0.055) / 1.055, 2.4);
  const B2 = b2 <= 0.03928 ? b2 / 12.92 : Math.pow((b2 + 0.055) / 1.055, 2.4);

  const L2 = 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;

  // Return contrast ratio
  return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
}


================================================================================

# .\tokens\themeConfig.ts

export interface CustomThemeOptions {
  brandColor: string;
  grayColor: string;
  accentColor: string; // Added: For additional theming
  colorScheme: string; // Added: Harmony scheme
  contrastThreshold: number; // Added: WCAG standard
  primaryShade: number; // Added: Default shade for primary color
  enableDarkMode: boolean; // Added: Flag for dark mode support
  customBreakpoints: any; // Added: Reference to imported breakpoints for modularity; adjust type as needed
}

// Then create a variable to hold your theme options
export const themeOptions: CustomThemeOptions = {
  brandColor: 'indigo',
  grayColor: 'gray',
  accentColor: 'violet', // Added: Default value for accent color
  colorScheme: 'analogous', // Added: Default value for color scheme
  contrastThreshold: 4.5, // Added: Default value for contrast threshold
  primaryShade: 500, // Added: Default value for primary shade
  enableDarkMode: true, // Added: Default value for dark mode
  customBreakpoints: {}, // Added: Default empty object for custom breakpoints
};


================================================================================

# .\tokens\typography.ts

// src/theme/tokens/typography.ts

// Font family tokens
export const fontFamily = {
  sans: [
    'Inter var',
    'Inter',
    'ui-sans-serif',
    'system-ui',
    '-apple-system',
    'sans-serif',
  ],
  serif: ['ui-serif', 'Georgia', 'Cambria', 'serif'],
  mono: [
    'Fira Code',
    'ui-monospace',
    'SFMono-Regular',
    'Menlo',
    'Monaco',
    'monospace',
  ],
  display: ['Manrope', 'Inter', 'system-ui', 'sans-serif'],
};

// Font size scale with consistent progression
export const fontSize = {
  '2xs': ['0.625rem', { lineHeight: '1rem' }], // 10px
  'xs': ['0.75rem', { lineHeight: '1rem' }], // 12px
  'sm': ['0.875rem', { lineHeight: '1.25rem' }], // 14px
  'base': ['1rem', { lineHeight: '1.5rem' }], // 16px
  'lg': ['1.125rem', { lineHeight: '1.75rem' }], // 18px
  'xl': ['1.25rem', { lineHeight: '1.75rem' }], // 20px
  '2xl': ['1.5rem', { lineHeight: '2rem' }], // 24px
  '3xl': ['1.875rem', { lineHeight: '2.25rem' }], // 30px
  '4xl': ['2.25rem', { lineHeight: '2.5rem' }], // 36px
  '5xl': ['3rem', { lineHeight: '1.16' }], // 48px
  '6xl': ['3.75rem', { lineHeight: '1.08' }], // 60px
  '7xl': ['4.5rem', { lineHeight: '1.05' }], // 72px
  '8xl': ['6rem', { lineHeight: '1' }], // 96px
  '9xl': ['8rem', { lineHeight: '1' }], // 128px
};

// Font weight tokens
export const fontWeight = {
  thin: '100',
  extralight: '200',
  light: '300',
  normal: '400',
  medium: '500',
  semibold: '600',
  bold: '700',
  extrabold: '800',
  black: '900',
};

// Letter spacing tokens
export const letterSpacing = {
  tighter: '-0.05em',
  tight: '-0.025em',
  normal: '0em',
  wide: '0.025em',
  wider: '0.05em',
  widest: '0.1em',
};

// Line height tokens
export const lineHeight = {
  none: '1',
  tight: '1.25',
  snug: '1.375',
  normal: '1.5',
  relaxed: '1.625',
  loose: '2',
  // Absolute values for precise control
  '3': '.75rem',
  '4': '1rem',
  '5': '1.25rem',
  '6': '1.5rem',
  '7': '1.75rem',
  '8': '2rem',
  '9': '2.25rem',
  '10': '2.5rem',
};

// Text style presets for reusable combinations
export const textStyles = {
  // Heading styles
  h1: {
    fontSize: fontSize['5xl'],
    fontWeight: fontWeight.bold,
    letterSpacing: letterSpacing.tight,
    lineHeight: lineHeight.tight,
  },
  h2: {
    fontSize: fontSize['4xl'],
    fontWeight: fontWeight.bold,
    letterSpacing: letterSpacing.tight,
    lineHeight: lineHeight.tight,
  },
  h3: {
    fontSize: fontSize['3xl'],
    fontWeight: fontWeight.semibold,
    letterSpacing: letterSpacing.tight,
    lineHeight: lineHeight.tight,
  },
  h4: {
    fontSize: fontSize['2xl'],
    fontWeight: fontWeight.semibold,
    letterSpacing: letterSpacing.tight,
    lineHeight: lineHeight.tight,
  },
  h5: {
    fontSize: fontSize.xl,
    fontWeight: fontWeight.semibold,
    letterSpacing: letterSpacing.tight,
    lineHeight: lineHeight.tight,
  },
  h6: {
    fontSize: fontSize.lg,
    fontWeight: fontWeight.semibold,
    letterSpacing: letterSpacing.tight,
    lineHeight: lineHeight.normal,
  },

  // Body text styles
  bodyLarge: {
    fontSize: fontSize.lg,
    fontWeight: fontWeight.normal,
    letterSpacing: letterSpacing.normal,
    lineHeight: lineHeight.relaxed,
  },
  bodyBase: {
    fontSize: fontSize.base,
    fontWeight: fontWeight.normal,
    letterSpacing: letterSpacing.normal,
    lineHeight: lineHeight.relaxed,
  },
  bodySmall: {
    fontSize: fontSize.sm,
    fontWeight: fontWeight.normal,
    letterSpacing: letterSpacing.normal,
    lineHeight: lineHeight.relaxed,
  },

  // UI element text styles
  button: {
    fontSize: fontSize.sm,
    fontWeight: fontWeight.medium,
    letterSpacing: letterSpacing.wide,
    lineHeight: lineHeight.none,
  },
  caption: {
    fontSize: fontSize.xs,
    fontWeight: fontWeight.normal,
    letterSpacing: letterSpacing.wide,
    lineHeight: lineHeight.normal,
  },
  overline: {
    fontSize: fontSize.xs,
    fontWeight: fontWeight.medium,
    letterSpacing: letterSpacing.widest,
    lineHeight: lineHeight.normal,
    textTransform: 'uppercase',
  },
  label: {
    fontSize: fontSize.sm,
    fontWeight: fontWeight.medium,
    letterSpacing: letterSpacing.normal,
    lineHeight: lineHeight.none,
  },
  code: {
    fontFamily: fontFamily.mono,
    fontSize: fontSize.sm,
    fontWeight: fontWeight.normal,
    letterSpacing: letterSpacing.normal,
    lineHeight: lineHeight.normal,
  },
};

// Responsive typography generator
export function generateResponsiveTypography() {
  return {
    // Generate fluid typography utilities
    '.text-fluid-xs': {
      'fontSize': 'clamp(0.75rem, 0.7rem + 0.25vw, 0.875rem)',
      'lineHeight': '1.5',
    },
    '.text-fluid-sm': {
      'fontSize': 'clamp(0.875rem, 0.8rem + 0.375vw, 1rem)',
      'lineHeight': '1.5',
    },
    '.text-fluid-base': {
      'fontSize': 'clamp(1rem, 0.9rem + 0.5vw, 1.125rem)',
      'lineHeight': '1.5',
    },
    '.text-fluid-lg': {
      'fontSize': 'clamp(1.125rem, 1rem + 0.625vw, 1.25rem)',
      'lineHeight': '1.5',
    },
    '.text-fluid-xl': {
      'fontSize': 'clamp(1.25rem, 1.1rem + 0.75vw, 1.5rem)',
      'lineHeight': '1.4',
    },
    '.text-fluid-2xl': {
      'fontSize': 'clamp(1.5rem, 1.3rem + 1vw, 1.875rem)',
      'lineHeight': '1.3',
    },
    '.text-fluid-3xl': {
      'fontSize': 'clamp(1.875rem, 1.6rem + 1.375vw, 2.25rem)',
      'lineHeight': '1.2',
    },
    '.text-fluid-4xl': {
      'fontSize': 'clamp(2.25rem, 1.9rem + 1.75vw, 3rem)',
      'lineHeight': '1.1',
    },
    '.text-fluid-5xl': {
      'fontSize': 'clamp(3rem, 2.5rem + 2.5vw, 4rem)',
      'lineHeight': '1',
    },

    // Utilities for high-resolution displays
    '.text-hd': {
      '-webkit-font-smoothing': 'antialiased',
      '-moz-osx-font-smoothing': 'grayscale',
      'font-feature-settings': '"kern" 1, "liga" 1, "calt" 1',
    },

    // Utilities for maximum readability
    '.text-readable': {
      'max-width': '70ch',
      'word-spacing': '0.05em',
      'hyphens': 'auto',
    },
  };
}


================================================================================

# .\utils\colorUtils.ts

// src/theme/utils/colorUtils.ts

import { handleThemeError, ErrorType } from './errorUtils';
import { fallbacks } from '../tokens/constants';

/**
 * Convert hex color to RGB values
 * @param hex - Hex color code (with or without #)
 * @returns RGB values as a comma-separated string
 */
export function hexToRgb(hex: string): string {
  // Safety check for undefined or invalid values
  if (!hex || typeof hex !== 'string') {
    return handleThemeError(
      ErrorType.COLOR,
      `Invalid hex color provided: ${hex}`,
      fallbacks.color.rgb
    );
  }

  try {
    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Validate hex format
    if (!/^([0-9a-f]{3}|[0-9a-f]{6})$/i.test(hex)) {
      return handleThemeError(
        ErrorType.COLOR,
        `Invalid hex format: ${hex}`,
        fallbacks.color.rgb
      );
    }

    // Handle 3-digit hex codes by duplicating each digit
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }

    // Parse hex values
    const bigint = parseInt(hex, 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;

    return `${r}, ${g}, ${b}`;
  } catch (error) {
    return handleThemeError(
      ErrorType.COLOR,
      'Error converting hex to RGB',
      fallbacks.color.rgb,
      error
    );
  }
}

/**
 * Convert HEX color to RGBA string
 * @param hex - Hex color code
 * @param alpha - Alpha/opacity value (0-1)
 * @returns RGBA string suitable for CSS
 */
export /**
 * Helper function to convert hex to rgba string
 * Convenience function for constants.ts
 */
function hexToRgba(hex: string, alpha: number): string {
  // Remove # if present
  hex = hex.replace(/^#/, '');

  // Parse the hex values
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);

  // Return rgba string
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

/**
 * Calculate relative luminance of a color
 * @param hex - Hex color code
 * @returns Relative luminance value (0-1)
 */
export function getLuminance(hex: string): number {
  try {
    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Parse hex values
    const r = parseInt(hex.substring(0, 2), 16) / 255;
    const g = parseInt(hex.substring(2, 4), 16) / 255;
    const b = parseInt(hex.substring(4, 6), 16) / 255;

    // Calculate relative luminance using the formula from WCAG 2.0
    const R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    const G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
    const B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);

    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  } catch (error) {
    console.error(`Error calculating luminance: ${error}`);
    return fallbacks.opacity; // Return middle luminance as fallback
  }
}

/**
 * Calculate contrast ratio between two colors according to WCAG 2.0
 * @param color1 - First hex color code
 * @param color2 - Second hex color code
 * @returns Contrast ratio (1-21)
 */
export function getContrastRatio(color1: string, color2: string): number {
  try {
    const luminance1 = getLuminance(color1);
    const luminance2 = getLuminance(color2);

    // Calculate contrast ratio using the WCAG 2.0 formula
    const lighter = Math.max(luminance1, luminance2);
    const darker = Math.min(luminance1, luminance2);

    return (lighter + 0.05) / (darker + 0.05);
  } catch (error) {
    console.error(`Error calculating contrast ratio: ${error}`);
    return 1; // Return minimum contrast as fallback
  }
}

/**
 * Determine if a color is dark (for choosing text color)
 * @param hex - Hex color code
 * @returns True if color is dark
 */
export function isDarkColor(hex: string): boolean {
  return getLuminance(hex) < 0.5;
}

/**
 * Get appropriate text color for a given background
 * @param bgColor - Background color hex code
 * @param darkColor - Custom dark color (default: black)
 * @param lightColor - Custom light color (default: white)
 * @returns Either light or dark color depending on contrast
 */
export function getAccessibleTextColor(
  bgColor: string,
  darkColor: string = fallbacks.color.hex,
  lightColor: string = '#ffffff'
): string {
  return isDarkColor(bgColor) ? lightColor : darkColor;
}

/**
 * Adjust color lightness
 * @param hex - Hex color code
 * @param amount - Amount to adjust lightness (-1 to 1)
 * @returns Adjusted hex color
 */
export function adjustColorLightness(hex: string, amount: number): string {
  try {
    // Remove # if present
    hex = hex.replace(/^#/, '');

    // Handle shorthand hex
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }

    // Convert to RGB
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);

    // Convert RGB to HSL
    const rgbToHsl = (r: number, g: number, b: number) => {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h = 0,
        s = 0,
        l = (max + min) / 2;

      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }

      return [h, s, l];
    };

    // Convert HSL to RGB
    const hslToRgb = (h: number, s: number, l: number) => {
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p: number, q: number, t: number) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    };

    // Convert to HSL, adjust lightness, convert back to RGB
    const [h, s, l] = rgbToHsl(r, g, b);
    let newL = l + amount;
    newL = Math.max(0, Math.min(1, newL)); // Clamp to 0-1
    const [newR, newG, newB] = hslToRgb(h, s, newL);

    // Convert back to hex
    const toHex = (c: number) => {
      const hex = c.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };

    return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
  } catch (error) {
    console.error(`Error adjusting color lightness: ${error}`);
    return hex; // Return original color as fallback
  }
}

/**
 * Generate a color palette from a base color
 * @param baseColor - Base color in hex format
 * @returns Object with color palette (50-950)
 */
export function generateColorPalette(
  baseColor: string
): Record<number, string> {
  try {
    const baseLuminance = getLuminance(baseColor);
    const palette: Record<number, string> = {};

    // Find the closest shade for the base color
    const baseShade =
      baseLuminance < 0.2
        ? 800
        : baseLuminance < 0.3
        ? 700
        : baseLuminance < 0.4
        ? 600
        : baseLuminance < 0.5
        ? 500
        : baseLuminance < 0.6
        ? 400
        : baseLuminance < 0.7
        ? 300
        : baseLuminance < 0.8
        ? 200
        : baseLuminance < 0.9
        ? 100
        : 50;

    palette[baseShade] = baseColor;

    // Generate lighter shades
    let currentColor = baseColor;
    for (let i = baseShade - 50; i >= 50; i -= 50) {
      const amount = i <= 200 ? 0.1 : 0.07;
      currentColor = adjustColorLightness(currentColor, amount);
      palette[i] = currentColor;
    }

    // Reset and generate darker shades
    currentColor = baseColor;
    for (let i = baseShade + 50; i <= 950; i += 50) {
      const amount = i >= 800 ? -0.1 : -0.07;
      currentColor = adjustColorLightness(currentColor, amount);
      palette[i] = currentColor;
    }

    return palette;
  } catch (error) {
    console.error(`Error generating color palette: ${error}`);
    return {}; // Return empty object as fallback
  }
}


================================================================================

# .\utils\errorUtils.ts

// src/webview/theme/utils/errorUtils.ts

/**
 * Error types for theme system
 */
export enum ErrorType {
  COLOR = 'COLOR',
  TOKEN = 'TOKEN',
  STYLE = 'STYLE',
  COMPONENT = 'COMPONENT',
}

/**
 * Standardized error handler for theme system
 * @param type - Type of error
 * @param message - Error message
 * @param fallback - Fallback value to return
 * @param errorDetails - Additional error details (optional)
 * @returns Fallback value
 */
export function handleThemeError<T>(
  type: ErrorType,
  message: string,
  fallback: T,
  errorDetails?: any
): T {
  // Log with consistent formatting
  console.error(`[Theme System] ${type} Error: ${message}`, errorDetails || '');
  
  // Return fallback value
  return fallback;
}


================================================================================

# .\utils\styleUtils.ts

// src/webview/theme/utils/styleUtils.ts

import { hexToRgb } from './colorUtils';
import { scrollbars, borders } from '../tokens/constants';

/**
 * Glass effect configuration
 */
export interface GlassConfig {
  background: string;
  border: string;
  shadowColor: string;
  shadowOpacity: number;
  borderRadius: string;
  backdropBlur?: string;
}

/**
 * Creates glass effect styles with optimized properties
 * @param config - Glass effect configuration
 * @returns Object with CSS properties for glass effect
 */
export function createGlassStyles(config: GlassConfig) {
  const {
    background,
    border,
    shadowColor,
    shadowOpacity,
    borderRadius,
    backdropBlur = '12px',
  } = config;

  const rgbShadowColor = hexToRgb(shadowColor);

  return {
    'background': background,
    'backdrop-filter': `blur(${backdropBlur})`,
    '-webkit-backdrop-filter': `blur(${backdropBlur})`,
    'border': `${borders.width.thin} solid ${border}`,
    'border-radius': borderRadius,
    'box-shadow': `0 8px 32px rgba(${rgbShadowColor}, ${shadowOpacity})`,
  };
}

/**
 * Scrollbar configuration
 */
export interface ScrollbarConfig {
  width?: string;
  trackColor?: string;
  thumbColor?: string;
  thumbHoverColor?: string;
  borderRadius?: string;
}

/**
 * Creates custom scrollbar styles
 * @param config - Scrollbar configuration
 * @returns Object with CSS properties for custom scrollbar
 */
export function createScrollbarStyles(config: ScrollbarConfig) {
  const {
    width = scrollbars.width.default,
    trackColor = 'transparent',
    thumbColor = 'rgba(100, 116, 139, 0.5)',
    thumbHoverColor = 'rgba(100, 116, 139, 0.7)',
    borderRadius = scrollbars.borderRadius.default,
  } = config;

  return {
    // Firefox
    'scrollbar-width': 'thin',
    'scrollbar-color': `${thumbColor} ${trackColor}`,

    // Webkit/Blink
    '&::-webkit-scrollbar': {
      width,
      height: width,
    },
    '&::-webkit-scrollbar-track': {
      background: trackColor,
    },
    '&::-webkit-scrollbar-thumb': {
      background: thumbColor,
      'border-radius': borderRadius,
    },
    '&::-webkit-scrollbar-thumb:hover': {
      background: thumbHoverColor,
    },
  };
}


--------------------------------------------------------------------------------
Total TypeScript files found: 19
